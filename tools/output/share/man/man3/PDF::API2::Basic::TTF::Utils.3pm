.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PDF::API2::Basic::TTF::Utils 3"
.TH PDF::API2::Basic::TTF::Utils 3 "2014-04-08" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
PDF::API2::Basic::TTF::Utils \- Utility functions to save fingers
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Lots of useful functions to save my fingers, especially for trivial tables
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The following functions are exported
.ie n .Sh "($val, $pos\fP) = TTF_Init_Fields ($str, \f(CW$pos)"
.el .Sh "($val, \f(CW$pos\fP) = TTF_Init_Fields ($str, \f(CW$pos\fP)"
.IX Subsection "($val, $pos) = TTF_Init_Fields ($str, $pos)"
Given a field description from the \f(CW\*(C`DATA\*(C'\fR section, creates an absolute entry
in the fields associative array for the class
.ie n .Sh "TTF_Read_Fields($obj, $dat\fP, \f(CW$fields)"
.el .Sh "TTF_Read_Fields($obj, \f(CW$dat\fP, \f(CW$fields\fP)"
.IX Subsection "TTF_Read_Fields($obj, $dat, $fields)"
Given a block of data large enough to account for all the fields in a table,
processes the data block to convert to the values in the objects instance
variables by name based on the list in the \f(CW\*(C`DATA\*(C'\fR block which has been run
through \f(CW\*(C`TTF_Init_Fields\*(C'\fR
.ie n .Sh "TTF_Unpack($fmt, $dat)"
.el .Sh "TTF_Unpack($fmt, \f(CW$dat\fP)"
.IX Subsection "TTF_Unpack($fmt, $dat)"
A TrueType types equivalent of Perls \f(CW\*(C`unpack\*(C'\fR function. Thus \f(CW$fmt\fR consists of
type followed by an optional number of elements to read including *. The type
may be one of:
.PP
.Vb 8
\&    c       BYTE
\&    C       CHAR
\&    f       FIXED
\&    F       F2DOT14
\&    l       LONG
\&    L       ULONG
\&    s       SHORT
\&    S       USHORT
.Ve
.PP
Note that \f(CW\*(C`FUNIT\*(C'\fR, \f(CW\*(C`FWORD\*(C'\fR and \f(CW\*(C`UFWORD\*(C'\fR are not data types but units.
.PP
Returns array of scalar (first element) depending on context
.ie n .Sh "$dat = TTF_Out_Fields($obj, $fields\fP, \f(CW$len)"
.el .Sh "$dat = TTF_Out_Fields($obj, \f(CW$fields\fP, \f(CW$len\fP)"
.IX Subsection "$dat = TTF_Out_Fields($obj, $fields, $len)"
Given the fields table from \f(CW\*(C`TTF_Init_Fields\*(C'\fR writes out the instance variables from
the object to the filehandle in \s-1TTF\s0 binary form.
.ie n .Sh "$dat = TTF_Pack($fmt, @data)"
.el .Sh "$dat = TTF_Pack($fmt, \f(CW@data\fP)"
.IX Subsection "$dat = TTF_Pack($fmt, @data)"
The TrueType equivalent to Perl's \f(CW\*(C`pack\*(C'\fR function. See details of \f(CW\*(C`TTF_Unpack\*(C'\fR
for how to work the \f(CW$fmt\fR string.
.ie n .Sh "($num, $range\fP, \f(CW$select\fP, \f(CW$shift) = TTF_bininfo($num)"
.el .Sh "($num, \f(CW$range\fP, \f(CW$select\fP, \f(CW$shift\fP) = TTF_bininfo($num)"
.IX Subsection "($num, $range, $select, $shift) = TTF_bininfo($num)"
Calculates binary search information from a number of elements
.Sh "TTF_word_utf8($str)"
.IX Subsection "TTF_word_utf8($str)"
Returns the \s-1UTF8\s0 form of the 16 bit string, assumed to be in big endian order,
including surrogate handling
.Sh "TTF_utf8_word($str)"
.IX Subsection "TTF_utf8_word($str)"
Returns the 16\-bit form in big endian order of the \s-1UTF\s0 8 string, including
surrogate handling to Unicode.
.ie n .Sh "XML_hexdump($context, $dat)"
.el .Sh "XML_hexdump($context, \f(CW$dat\fP)"
.IX Subsection "XML_hexdump($context, $dat)"
Dumps out the given data as a sequence of <data> blocks each 16 bytes wide
.Sh "XML_outhints"
.IX Subsection "XML_outhints"
Converts a binary string of hinting code into a textual representation
.ie n .Sh "make_circle($f, $cmap\fP, [$dia, \f(CW$sb\fP, \f(CW$opts])"
.el .Sh "make_circle($f, \f(CW$cmap\fP, [$dia, \f(CW$sb\fP, \f(CW$opts\fP])"
.IX Subsection "make_circle($f, $cmap, [$dia, $sb, $opts])"
Adds a dotted circle to a font. This function is very configurable. The
parameters passed in are:
.IP "$f" 4
.IX Item "$f"
Font to work with. This is required.
.IP "$cmap" 4
.IX Item "$cmap"
A cmap table (not the 'val' sub-element of a cmap) to add the glyph too. Optional.
.IP "$dia" 4
.IX Item "$dia"
Optional diameter for the main circle. Defaults to 80% em
.IP "$sb" 4
.IX Item "$sb"
Side bearing. The left and right side-bearings are always the same. This value
defaults to 10% em.
.PP
There are various options to control all sorts of interesting aspects of the circle
.IP "numDots" 4
.IX Item "numDots"
Number of dots in the circle
.IP "numPoints" 4
.IX Item "numPoints"
Number of curve points to use to create each dot
.IP "uid" 4
.IX Item "uid"
Unicode reference to store this glyph under in the cmap. Defaults to 0x25CC
.IP "pname" 4
.IX Item "pname"
Postscript name to give the glyph. Defaults to uni25CC.
.IP "\-dRadius" 4
.IX Item "-dRadius"
Radius of each dot.
.SH "BUGS"
.IX Header "BUGS"
No known bugs
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Hosken Martin_Hosken@sil.org. See PDF::API2::Basic::TTF::Font for copyright and
licensing.

.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Cap 3"
.TH Mail::Cap 3 "2014-04-08" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
Mail::Cap \- Parse mailcap files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    my $mc = new Mail::Cap;
.Ve
.PP
.Vb 1
\&    $desc = $mc->description('image/gif');
.Ve
.PP
.Vb 1
\&    print "GIF desc: $desc\en";
.Ve
.PP
.Vb 1
\&    $cmd = $mc->viewCmd('text/plain; charset=iso-8859-1', 'file.txt');
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Parse mailcap files as specified in \s-1RFC\s0 1524 \- \fIA User Agent
Configuration Mechanism For Multimedia Mail Format Information\fR.  In
the description below \f(CW$type\fR refers to the \s-1MIME\s0 type as specified in
the \fIContent-Type\fR header of mail or \s-1HTTP\s0 messages.  Examples of
types are:
.PP
.Vb 3
\&  image/gif
\&  text/html
\&  text/plain; charset=iso-8859-1
.Ve
.SH "METHODS"
.IX Header "METHODS"
.Sh "new(\s-1OPTIONS\s0)"
.IX Subsection "new(OPTIONS)"
.Vb 5
\&  $mcap = new Mail::Cap;
\&  $mcap = new Mail::Cap "/mydir/mailcap";
\&  $mcap = new Mail::Cap filename => "/mydir/mailcap";
\&  $mcap = new Mail::Cap take => 'ALL';
\&  $mcap = Mail::Cap->new(take => 'ALL');
.Ve
.PP
Create and initialize a new Mail::Cap object.  If you give it an
argument it will try to parse the specified file.  Without any
arguments it will search for the mailcap file using the standard
mailcap path, or the \s-1MAILCAPS\s0 environment variable if it is defined.
.PP
There is currently two \s-1OPTION\s0 implemented:
.IP "* take => '\s-1ALL\s0'|'\s-1FIRST\s0'" 4
.IX Item "take => 'ALL'|'FIRST'"
Include all mailcap files you can find.  By default, only the first
file is parsed, however the \s-1RFC\s0 tells us to include \s-1ALL\s0.  To maintain
backwards compatibility, the default only takes the \s-1FIRST\s0.
.IP "* filename => \s-1FILENAME\s0" 4
.IX Item "filename => FILENAME"
Add the specified file to the list to standard locations.  This file
is tried first.
.ie n .Sh "view($type, $file)"
.el .Sh "view($type, \f(CW$file\fP)"
.IX Subsection "view($type, $file)"
.ie n .Sh "compose($type, $file)"
.el .Sh "compose($type, \f(CW$file\fP)"
.IX Subsection "compose($type, $file)"
.ie n .Sh "edit($type, $file)"
.el .Sh "edit($type, \f(CW$file\fP)"
.IX Subsection "edit($type, $file)"
.ie n .Sh "print($type, $file)"
.el .Sh "print($type, \f(CW$file\fP)"
.IX Subsection "print($type, $file)"
These methods invoke a suitable progam presenting or manipulating the
media object in the specified file.  They all return \f(CW1\fR if a command
was found, and \f(CW0\fR otherwise.  You might test \f(CW$?\fR for the outcome
of the command.
.ie n .Sh "viewCmd($type, $file)"
.el .Sh "viewCmd($type, \f(CW$file\fP)"
.IX Subsection "viewCmd($type, $file)"
.ie n .Sh "composeCmd($type, $file)"
.el .Sh "composeCmd($type, \f(CW$file\fP)"
.IX Subsection "composeCmd($type, $file)"
.ie n .Sh "editCmd($type, $file)"
.el .Sh "editCmd($type, \f(CW$file\fP)"
.IX Subsection "editCmd($type, $file)"
.ie n .Sh "printCmd($type, $file)"
.el .Sh "printCmd($type, \f(CW$file\fP)"
.IX Subsection "printCmd($type, $file)"
These methods return a string that is suitable for feeding to \fIsystem()\fR
in order to invoke a suitable progam presenting or manipulating the
media object in the specified file.  It will return \f(CW\*(C`undef\*(C'\fR if no
suitable specification exists.
.ie n .Sh "field($type, $field)"
.el .Sh "field($type, \f(CW$field\fP)"
.IX Subsection "field($type, $field)"
Returns the specified field for the type.  Returns undef if no
specification exsists.
.Sh "description($type)"
.IX Subsection "description($type)"
.Sh "textualnewlines($type)"
.IX Subsection "textualnewlines($type)"
.Sh "x11_bitmap($type)"
.IX Subsection "x11_bitmap($type)"
.Sh "nametemplate($type)"
.IX Subsection "nametemplate($type)"
These methods return the corresponding mailcap field for the type.
These methods should be more convenient to use than the \fIfield()\fR method
for the same fields.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1995 Gisle Aas. All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gisle Aas <aas@oslonett.no> 
.PP
Modified by Graham Barr <gbarr@pobox.com>
.PP
Maintained by Mark Overmeer <mailtools@overmeer.net>

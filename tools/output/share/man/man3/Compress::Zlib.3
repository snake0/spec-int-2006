.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Zlib 3"
.TH Zlib 3 "2014-04-14" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
Compress::Zlib \- Interface to zlib compression library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Compress::Zlib ;
.Ve
.PP
.Vb 8
\&    ($d, $status) = deflateInit( [OPT] ) ;
\&    ($out, $status) = $d->deflate($buffer) ;
\&    $status = $d->deflateParams([OPT]) ;
\&    ($out, $status) = $d->flush() ;
\&    $d->dict_adler() ;
\&    $d->total_in() ;
\&    $d->total_out() ;
\&    $d->msg() ;
.Ve
.PP
.Vb 7
\&    ($i, $status) = inflateInit( [OPT] ) ;
\&    ($out, $status) = $i->inflate($buffer) ;
\&    $status = $i->inflateSync($buffer) ;
\&    $i->dict_adler() ;
\&    $i->total_in() ;
\&    $i->total_out() ;
\&    $i->msg() ;
.Ve
.PP
.Vb 2
\&    $dest = compress($source, [$level]) ;
\&    $dest = uncompress($source) ;
.Ve
.PP
.Vb 10
\&    $gz = gzopen($filename or filehandle, $mode) ;
\&    $bytesread = $gz->gzread($buffer [,$size]) ;
\&    $bytesread = $gz->gzreadline($line) ;
\&    $byteswritten = $gz->gzwrite($buffer) ;
\&    $status = $gz->gzflush($flush) ;
\&    $status = $gz->gzclose() ;
\&    $status = $gz->gzeof() ;
\&    $status = $gz->gzsetparams($level, $strategy) ;
\&    $errstring = $gz->gzerror() ; 
\&    $gzerrno
.Ve
.PP
.Vb 2
\&    $dest = Compress::Zlib::memGzip($buffer) ;
\&    $dest = Compress::Zlib::memGunzip($buffer) ;
.Ve
.PP
.Vb 2
\&    $crc = adler32($buffer [,$crc]) ;
\&    $crc = crc32($buffer [,$crc]) ;
.Ve
.PP
.Vb 1
\&    ZLIB_VERSION
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fICompress::Zlib\fR module provides a Perl interface to the \fIzlib\fR
compression library (see \*(L"\s-1AUTHOR\s0\*(R" for details about where to get
\&\fIzlib\fR). Most of the functionality provided by \fIzlib\fR is available
in \fICompress::Zlib\fR.
.PP
The module can be split into two general areas of functionality, namely
in-memory compression/decompression and read/write access to \fIgzip\fR
files. Each of these areas will be discussed separately below.
.SH "DEFLATE"
.IX Header "DEFLATE"
The interface \fICompress::Zlib\fR provides to the in-memory \fIdeflate\fR
(and \fIinflate\fR) functions has been modified to fit into a Perl model.
.PP
The main difference is that for both inflation and deflation, the Perl
interface will \fIalways\fR consume the complete input buffer before
returning. Also the output buffer returned will be automatically grown
to fit the amount of output available.
.PP
Here is a definition of the interface available:
.ie n .Sh "\fB($d, \fP\fB$status\fP\fB) = deflateInit( [\s-1OPT\s0] )\fP"
.el .Sh "\fB($d, \fP\f(CB$status\fP\fB) = deflateInit( [\s-1OPT\s0] )\fP"
.IX Subsection "($d, $status) = deflateInit( [OPT] )"
Initialises a deflation stream. 
.PP
It combines the features of the \fIzlib\fR functions \fBdeflateInit\fR,
\&\fBdeflateInit2\fR and \fBdeflateSetDictionary\fR.
.PP
If successful, it will return the initialised deflation stream, \fB$d\fR
and \fB$status\fR of \f(CW\*(C`Z_OK\*(C'\fR in a list context. In scalar context it
returns the deflation stream, \fB$d\fR, only.
.PP
If not successful, the returned deflation stream (\fB$d\fR) will be
\&\fIundef\fR and \fB$status\fR will hold the exact \fIzlib\fR error code.
.PP
The function optionally takes a number of named options specified as
\&\f(CW\*(C`\-Name=>value\*(C'\fR pairs. This allows individual options to be
tailored without having to specify them all in the parameter list.
.PP
For backward compatibility, it is also possible to pass the parameters
as a reference to a hash containing the name=>value pairs.
.PP
The function takes one optional parameter, a reference to a hash.  The
contents of the hash allow the deflation interface to be tailored.
.PP
Here is a list of the valid options:
.IP "\fB\-Level\fR" 5
.IX Item "-Level"
Defines the compression level. Valid values are 0 through 9,
\&\f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR, \f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, and
\&\f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
.Sp
The default is \f(CW\*(C`\-Level =>Z_DEFAULT_COMPRESSION\*(C'\fR.
.IP "\fB\-Method\fR" 5
.IX Item "-Method"
Defines the compression method. The only valid value at present (and
the default) is \f(CW\*(C`\-Method =>Z_DEFLATED\*(C'\fR.
.IP "\fB\-WindowBits\fR" 5
.IX Item "-WindowBits"
For a definition of the meaning and valid values for \fBWindowBits\fR
refer to the \fIzlib\fR documentation for \fIdeflateInit2\fR.
.Sp
Defaults to \f(CW\*(C`\-WindowBits =>MAX_WBITS\*(C'\fR.
.IP "\fB\-MemLevel\fR" 5
.IX Item "-MemLevel"
For a definition of the meaning and valid values for \fBMemLevel\fR
refer to the \fIzlib\fR documentation for \fIdeflateInit2\fR.
.Sp
Defaults to \f(CW\*(C`\-MemLevel =>MAX_MEM_LEVEL\*(C'\fR.
.IP "\fB\-Strategy\fR" 5
.IX Item "-Strategy"
Defines the strategy used to tune the compression. The valid values are
\&\f(CW\*(C`Z_DEFAULT_STRATEGY\*(C'\fR, \f(CW\*(C`Z_FILTERED\*(C'\fR and \f(CW\*(C`Z_HUFFMAN_ONLY\*(C'\fR. 
.Sp
The default is \f(CW\*(C`\-Strategy =>Z_DEFAULT_STRATEGY\*(C'\fR.
.IP "\fB\-Dictionary\fR" 5
.IX Item "-Dictionary"
When a dictionary is specified \fICompress::Zlib\fR will automatically
call \fBdeflateSetDictionary\fR directly after calling \fBdeflateInit\fR. The
Adler32 value for the dictionary can be obtained by calling the method 
\&\f(CW\*(C`$d\-\*(C'\fR\fIdict_adler()\fR>.
.Sp
The default is no dictionary.
.IP "\fB\-Bufsize\fR" 5
.IX Item "-Bufsize"
Sets the initial size for the deflation buffer. If the buffer has to be
reallocated to increase the size, it will grow in increments of
\&\fBBufsize\fR.
.Sp
The default is 4096.
.PP
Here is an example of using the \fBdeflateInit\fR optional parameter list
to override the default buffer size and compression level. All other
options will take their default values.
.PP
.Vb 2
\&    deflateInit( -Bufsize => 300, 
\&                 -Level => Z_BEST_SPEED  ) ;
.Ve
.ie n .Sh "\fB($out, \fP\fB$status\fP\fB) = \fP\f(BI$d\fP\fB\->deflate($buffer)\fP"
.el .Sh "\fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$d\fP\fB\->deflate($buffer)\fP"
.IX Subsection "($out, $status) = $d->deflate($buffer)"
Deflates the contents of \fB$buffer\fR. The buffer can either be a scalar
or a scalar reference.  When finished, \fB$buffer\fR will be
completely processed (assuming there were no errors). If the deflation
was successful it returns the deflated output, \fB$out\fR, and a status
value, \fB$status\fR, of \f(CW\*(C`Z_OK\*(C'\fR.
.PP
On error, \fB$out\fR will be \fIundef\fR and \fB$status\fR will contain the
\&\fIzlib\fR error code.
.PP
In a scalar context \fBdeflate\fR will return \fB$out\fR only.
.PP
As with the \fIdeflate\fR function in \fIzlib\fR, it is not necessarily the
case that any output will be produced by this method. So don't rely on
the fact that \fB$out\fR is empty for an error test.
.ie n .Sh "\fB($out, \fP\fB$status\fP\fB) = \fP\f(BI$d\fP\fB\->flush([flush_type])\fP"
.el .Sh "\fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$d\fP\fB\->flush([flush_type])\fP"
.IX Subsection "($out, $status) = $d->flush([flush_type])"
Typically used to finish the deflation. Any pending output will be
returned via \fB$out\fR.
\&\fB$status\fR will have a value \f(CW\*(C`Z_OK\*(C'\fR if successful.
.PP
In a scalar context \fBflush\fR will return \fB$out\fR only.
.PP
Note that flushing can seriously degrade the compression ratio, so it
should only be used to terminate a decompression (using \f(CW\*(C`Z_FINISH\*(C'\fR) or
when you want to create a \fIfull flush point\fR (using \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR).
.PP
By default the \f(CW\*(C`flush_type\*(C'\fR used is \f(CW\*(C`Z_FINISH\*(C'\fR. Other valid values
for \f(CW\*(C`flush_type\*(C'\fR are \f(CW\*(C`Z_NO_FLUSH\*(C'\fR, \f(CW\*(C`Z_PARTIAL_FLUSH\*(C'\fR, \f(CW\*(C`Z_SYNC_FLUSH\*(C'\fR
and \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR. It is strongly recommended that you only set the
\&\f(CW\*(C`flush_type\*(C'\fR parameter if you fully understand the implications of
what it does. See the \f(CW\*(C`zlib\*(C'\fR documentation for details.
.ie n .Sh "\fB$status = \fP\fB$d\fP\fB\->deflateParams([\s-1OPT\s0])\fP"
.el .Sh "\fB$status = \fP\f(CB$d\fP\fB\->deflateParams([\s-1OPT\s0])\fP"
.IX Subsection "$status = $d->deflateParams([OPT])"
Change settings for the deflate stream \f(CW$d\fR.
.PP
The list of the valid options is shown below. Options not specified
will remain unchanged.
.IP "\fB\-Level\fR" 5
.IX Item "-Level"
Defines the compression level. Valid values are 0 through 9,
\&\f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR, \f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, and
\&\f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
.IP "\fB\-Strategy\fR" 5
.IX Item "-Strategy"
Defines the strategy used to tune the compression. The valid values are
\&\f(CW\*(C`Z_DEFAULT_STRATEGY\*(C'\fR, \f(CW\*(C`Z_FILTERED\*(C'\fR and \f(CW\*(C`Z_HUFFMAN_ONLY\*(C'\fR. 
.Sh "\fB$d\->\fP\f(BIdict_adler()\fP\fB\fP"
.IX Subsection "$d->dict_adler()"
Returns the adler32 value for the dictionary.
.Sh "\fB$d\->\fP\f(BImsg()\fP\fB\fP"
.IX Subsection "$d->msg()"
Returns the last error message generated by zlib.
.Sh "\fB$d\->\fP\f(BItotal_in()\fP\fB\fP"
.IX Subsection "$d->total_in()"
Returns the total number of bytes uncompressed bytes input to deflate.
.Sh "\fB$d\->\fP\f(BItotal_out()\fP\fB\fP"
.IX Subsection "$d->total_out()"
Returns the total number of compressed bytes output from deflate.
.Sh "Example"
.IX Subsection "Example"
Here is a trivial example of using \fBdeflate\fR. It simply reads standard
input, deflates it and writes it to standard output.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
.Ve
.PP
.Vb 1
\&    use Compress::Zlib ;
.Ve
.PP
.Vb 4
\&    binmode STDIN;
\&    binmode STDOUT;
\&    my $x = deflateInit()
\&       or die "Cannot create a deflation stream\en" ;
.Ve
.PP
.Vb 4
\&    my ($output, $status) ;
\&    while (<>)
\&    {
\&        ($output, $status) = $x->deflate($_) ;
.Ve
.PP
.Vb 2
\&        $status == Z_OK
\&            or die "deflation failed\en" ;
.Ve
.PP
.Vb 2
\&        print $output ;
\&    }
.Ve
.PP
.Vb 1
\&    ($output, $status) = $x->flush() ;
.Ve
.PP
.Vb 2
\&    $status == Z_OK
\&        or die "deflation failed\en" ;
.Ve
.PP
.Vb 1
\&    print $output ;
.Ve
.SH "INFLATE"
.IX Header "INFLATE"
Here is a definition of the interface:
.ie n .Sh "\fB($i, \fP\fB$status\fP\fB) = \fP\f(BIinflateInit()\fP\fB\fP"
.el .Sh "\fB($i, \fP\f(CB$status\fP\fB) = \fP\f(BIinflateInit()\fP\fB\fP"
.IX Subsection "($i, $status) = inflateInit()"
Initialises an inflation stream. 
.PP
In a list context it returns the inflation stream, \fB$i\fR, and the
\&\fIzlib\fR status code (\fB$status\fR). In a scalar context it returns the
inflation stream only.
.PP
If successful, \fB$i\fR will hold the inflation stream and \fB$status\fR will
be \f(CW\*(C`Z_OK\*(C'\fR.
.PP
If not successful, \fB$i\fR will be \fIundef\fR and \fB$status\fR will hold the
\&\fIzlib\fR error code.
.PP
The function optionally takes a number of named options specified as
\&\f(CW\*(C`\-Name=>value\*(C'\fR pairs. This allows individual options to be
tailored without having to specify them all in the parameter list.
.PP
For backward compatibility, it is also possible to pass the parameters
as a reference to a hash containing the name=>value pairs.
.PP
The function takes one optional parameter, a reference to a hash.  The
contents of the hash allow the deflation interface to be tailored.
.PP
Here is a list of the valid options:
.IP "\fB\-WindowBits\fR" 5
.IX Item "-WindowBits"
For a definition of the meaning and valid values for \fBWindowBits\fR
refer to the \fIzlib\fR documentation for \fIinflateInit2\fR.
.Sp
Defaults to \f(CW\*(C`\-WindowBits =>MAX_WBITS\*(C'\fR.
.IP "\fB\-Bufsize\fR" 5
.IX Item "-Bufsize"
Sets the initial size for the inflation buffer. If the buffer has to be
reallocated to increase the size, it will grow in increments of
\&\fBBufsize\fR. 
.Sp
Default is 4096.
.IP "\fB\-Dictionary\fR" 5
.IX Item "-Dictionary"
The default is no dictionary.
.PP
Here is an example of using the \fBinflateInit\fR optional parameter to
override the default buffer size.
.PP
.Vb 1
\&    inflateInit( -Bufsize => 300 ) ;
.Ve
.ie n .Sh "\fB($out, \fP\fB$status\fP\fB) = \fP\f(BI$i\fP\fB\->inflate($buffer)\fP"
.el .Sh "\fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$i\fP\fB\->inflate($buffer)\fP"
.IX Subsection "($out, $status) = $i->inflate($buffer)"
Inflates the complete contents of \fB$buffer\fR. The buffer can either be
a scalar or a scalar reference.
.PP
Returns \f(CW\*(C`Z_OK\*(C'\fR if successful and \f(CW\*(C`Z_STREAM_END\*(C'\fR if the end of the
compressed data has been successfully reached. 
If not successful, \fB$out\fR will be \fIundef\fR and \fB$status\fR will hold
the \fIzlib\fR error code.
.PP
The \f(CW$buffer\fR parameter is modified by \f(CW\*(C`inflate\*(C'\fR. On completion it
will contain what remains of the input buffer after inflation. This
means that \f(CW$buffer\fR will be an empty string when the return status is
\&\f(CW\*(C`Z_OK\*(C'\fR. When the return status is \f(CW\*(C`Z_STREAM_END\*(C'\fR the \f(CW$buffer\fR
parameter will contains what (if anything) was stored in the input
buffer after the deflated data stream.
.PP
This feature is useful when processing a file format that encapsulates
a  compressed data stream (e.g. gzip, zip).
.ie n .Sh "\fB$status = \fP\fB$i\fP\fB\->inflateSync($buffer)\fP"
.el .Sh "\fB$status = \fP\f(CB$i\fP\fB\->inflateSync($buffer)\fP"
.IX Subsection "$status = $i->inflateSync($buffer)"
Scans \f(CW$buffer\fR until it reaches either a \fIfull flush point\fR or the
end of the buffer.
.PP
If a \fIfull flush point\fR is found, \f(CW\*(C`Z_OK\*(C'\fR is returned and \f(CW$buffer\fR
will be have all data up to the flush point removed. This can then be
passed to the \f(CW\*(C`deflate\*(C'\fR method.
.PP
Any other return code means that a flush point was not found. If more
data is available, \f(CW\*(C`inflateSync\*(C'\fR can be called repeatedly with more
compressed data until the flush point is found.
.Sh "\fB$i\->\fP\f(BIdict_adler()\fP\fB\fP"
.IX Subsection "$i->dict_adler()"
Returns the adler32 value for the dictionary.
.Sh "\fB$i\->\fP\f(BImsg()\fP\fB\fP"
.IX Subsection "$i->msg()"
Returns the last error message generated by zlib.
.Sh "\fB$i\->\fP\f(BItotal_in()\fP\fB\fP"
.IX Subsection "$i->total_in()"
Returns the total number of bytes compressed bytes input to inflate.
.Sh "\fB$i\->\fP\f(BItotal_out()\fP\fB\fP"
.IX Subsection "$i->total_out()"
Returns the total number of uncompressed bytes output from inflate.
.Sh "Example"
.IX Subsection "Example"
Here is an example of using \fBinflate\fR.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
.Ve
.PP
.Vb 1
\&    use Compress::Zlib ;
.Ve
.PP
.Vb 2
\&    my $x = inflateInit()
\&       or die "Cannot create a inflation stream\en" ;
.Ve
.PP
.Vb 3
\&    my $input = '' ;
\&    binmode STDIN;
\&    binmode STDOUT;
.Ve
.PP
.Vb 4
\&    my ($output, $status) ;
\&    while (read(STDIN, $input, 4096))
\&    {
\&        ($output, $status) = $x->inflate(\e$input) ;
.Ve
.PP
.Vb 2
\&        print $output 
\&            if $status == Z_OK or $status == Z_STREAM_END ;
.Ve
.PP
.Vb 2
\&        last if $status != Z_OK ;
\&    }
.Ve
.PP
.Vb 2
\&    die "inflation failed\en"
\&        unless $status == Z_STREAM_END ;
.Ve
.SH "COMPRESS/UNCOMPRESS"
.IX Header "COMPRESS/UNCOMPRESS"
Two high-level functions are provided by \fIzlib\fR to perform in-memory
compression. They are \fBcompress\fR and \fBuncompress\fR. Two Perl subs are
provided which provide similar functionality.
.ie n .IP "\fB$dest = compress($source [, \fB$level\fB] ) ;\fR" 5
.el .IP "\fB$dest = compress($source [, \f(CB$level\fB] ) ;\fR" 5
.IX Item "$dest = compress($source [, $level] ) ;"
Compresses \fB$source\fR. If successful it returns the
compressed data. Otherwise it returns \fIundef\fR.
.Sp
The source buffer can either be a scalar or a scalar reference.
.Sp
The \fB$level\fR paramter defines the compression level. Valid values are
0 through 9, \f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR,
\&\f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, and \f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
If \fB$level\fR is not specified \f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR will be used.
.IP "\fB$dest = uncompress($source) ;\fR" 5
.IX Item "$dest = uncompress($source) ;"
Uncompresses \fB$source\fR. If successful it returns the uncompressed
data. Otherwise it returns \fIundef\fR.
.Sp
The source buffer can either be a scalar or a scalar reference.
.SH "GZIP INTERFACE"
.IX Header "GZIP INTERFACE"
A number of functions are supplied in \fIzlib\fR for reading and writing
\&\fIgzip\fR files. This module provides an interface to most of them. In
general the interface provided by this module operates identically to
the functions provided by \fIzlib\fR. Any differences are explained
below.
.IP "\fB$gz = gzopen(filename or filehandle, mode)\fR" 5
.IX Item "$gz = gzopen(filename or filehandle, mode)"
This function operates identically to the \fIzlib\fR equivalent except
that it returns an object which is used to access the other \fIgzip\fR
methods.
.Sp
As with the \fIzlib\fR equivalent, the \fBmode\fR parameter is used to
specify both whether the file is opened for reading or writing and to
optionally specify a a compression level. Refer to the \fIzlib\fR
documentation for the exact format of the \fBmode\fR parameter.
.Sp
If a reference to an open filehandle is passed in place of the
filename, gzdopen will be called behind the scenes. The third example
at the end of this section, \fIgzstream\fR, uses this feature.
.ie n .IP "\fB$bytesread = \fB$gz\fB\->gzread($buffer [, \f(BI$size\fB]) ;\fR" 5
.el .IP "\fB$bytesread = \f(CB$gz\fB\->gzread($buffer [, \f(CB$size\fB]) ;\fR" 5
.IX Item "$bytesread = $gz->gzread($buffer [, $size]) ;"
Reads \fB$size\fR bytes from the compressed file into \fB$buffer\fR. If
\&\fB$size\fR is not specified, it will default to 4096. If the scalar
\&\fB$buffer\fR is not large enough, it will be extended automatically.
.Sp
Returns the number of bytes actually read. On \s-1EOF\s0 it returns 0 and in
the case of an error, \-1.
.ie n .IP "\fB$bytesread = \fB$gz\fB\->gzreadline($line) ;\fR" 5
.el .IP "\fB$bytesread = \f(CB$gz\fB\->gzreadline($line) ;\fR" 5
.IX Item "$bytesread = $gz->gzreadline($line) ;"
Reads the next line from the compressed file into \fB$line\fR. 
.Sp
Returns the number of bytes actually read. On \s-1EOF\s0 it returns 0 and in
the case of an error, \-1.
.Sp
It is legal to intermix calls to \fBgzread\fR and \fBgzreadline\fR.
.Sp
At this time \fBgzreadline\fR ignores the variable \f(CW$/\fR
(\f(CW$INPUT_RECORD_SEPARATOR\fR or \f(CW$RS\fR when \f(CW\*(C`English\*(C'\fR is in use). The
end of a line is denoted by the C character \f(CW'\en'\fR.
.ie n .IP "\fB$byteswritten = \fB$gz\fB\->gzwrite($buffer) ;\fR" 5
.el .IP "\fB$byteswritten = \f(CB$gz\fB\->gzwrite($buffer) ;\fR" 5
.IX Item "$byteswritten = $gz->gzwrite($buffer) ;"
Writes the contents of \fB$buffer\fR to the compressed file. Returns the
number of bytes actually written, or 0 on error.
.ie n .IP "\fB$status = \fB$gz\fB\->gzflush($flush) ;\fR" 5
.el .IP "\fB$status = \f(CB$gz\fB\->gzflush($flush) ;\fR" 5
.IX Item "$status = $gz->gzflush($flush) ;"
Flushes all pending output to the compressed file.
Works identically to the \fIzlib\fR function it interfaces to. Note that
the use of \fBgzflush\fR can degrade compression.
.Sp
Returns \f(CW\*(C`Z_OK\*(C'\fR if \fB$flush\fR is \f(CW\*(C`Z_FINISH\*(C'\fR and all output could be
flushed. Otherwise the zlib error code is returned.
.Sp
Refer to the \fIzlib\fR documentation for the valid values of \fB$flush\fR.
.ie n .IP "\fB$status = \fB$gz\fB\->\f(BIgzeof()\fB ;\fR" 5
.el .IP "\fB$status = \f(CB$gz\fB\->\f(BIgzeof()\fB ;\fR" 5
.IX Item "$status = $gz->gzeof() ;"
Returns 1 if the end of file has been detected while reading the input
file, otherwise returns 0.
.IP "\fB$gz\->gzclose\fR" 5
.IX Item "$gz->gzclose"
Closes the compressed file. Any pending data is flushed to the file
before it is closed.
.ie n .IP "\fB$gz\->gzsetparams($level, \fB$strategy\fB\fR" 5
.el .IP "\fB$gz\->gzsetparams($level, \f(CB$strategy\fB\fR" 5
.IX Item "$gz->gzsetparams($level, $strategy"
Change settings for the deflate stream \f(CW$gz\fR.
.Sp
The list of the valid options is shown below. Options not specified
will remain unchanged.
.Sp
Note: This method is only available if you are running zlib 1.0.6 or better.
.RS 5
.IP "\fB$level\fR" 5
.IX Item "$level"
Defines the compression level. Valid values are 0 through 9,
\&\f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR, \f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, and
\&\f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
.IP "\fB$strategy\fR" 5
.IX Item "$strategy"
Defines the strategy used to tune the compression. The valid values are
\&\f(CW\*(C`Z_DEFAULT_STRATEGY\*(C'\fR, \f(CW\*(C`Z_FILTERED\*(C'\fR and \f(CW\*(C`Z_HUFFMAN_ONLY\*(C'\fR. 
.RE
.RS 5
.RE
.IP "\fB$gz\->gzerror\fR" 5
.IX Item "$gz->gzerror"
Returns the \fIzlib\fR error message or number for the last operation
associated with \fB$gz\fR. The return value will be the \fIzlib\fR error
number when used in a numeric context and the \fIzlib\fR error message
when used in a string context. The \fIzlib\fR error number constants,
shown below, are available for use.
.Sp
.Vb 7
\&    Z_OK
\&    Z_STREAM_END
\&    Z_ERRNO
\&    Z_STREAM_ERROR
\&    Z_DATA_ERROR
\&    Z_MEM_ERROR
\&    Z_BUF_ERROR
.Ve
.IP "\fB$gzerrno\fR" 5
.IX Item "$gzerrno"
The \fB$gzerrno\fR scalar holds the error code associated with the most
recent \fIgzip\fR routine. Note that unlike \fB\f(BIgzerror()\fB\fR, the error is
\&\fInot\fR associated with a particular file.
.Sp
As with \fB\f(BIgzerror()\fB\fR it returns an error number in numeric context and
an error message in string context. Unlike \fB\f(BIgzerror()\fB\fR though, the
error message will correspond to the \fIzlib\fR message when the error is
associated with \fIzlib\fR itself, or the \s-1UNIX\s0 error message when it is
not (i.e. \fIzlib\fR returned \f(CW\*(C`Z_ERRORNO\*(C'\fR).
.Sp
As there is an overlap between the error numbers used by \fIzlib\fR and
\&\s-1UNIX\s0, \fB$gzerrno\fR should only be used to check for the presence of
\&\fIan\fR error in numeric context. Use \fB\f(BIgzerror()\fB\fR to check for specific
\&\fIzlib\fR errors. The \fIgzcat\fR example below shows how the variable can
be used safely.
.Sh "Examples"
.IX Subsection "Examples"
Here is an example script which uses the interface. It implements a
\&\fIgzcat\fR function.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
.Ve
.PP
.Vb 1
\&    use Compress::Zlib ;
.Ve
.PP
.Vb 2
\&    die "Usage: gzcat file...\en"
\&        unless @ARGV ;
.Ve
.PP
.Vb 1
\&    my $file ;
.Ve
.PP
.Vb 2
\&    foreach $file (@ARGV) {
\&        my $buffer ;
.Ve
.PP
.Vb 2
\&        my $gz = gzopen($file, "rb") 
\&             or die "Cannot open $file: $gzerrno\en" ;
.Ve
.PP
.Vb 1
\&        print $buffer while $gz->gzread($buffer) > 0 ;
.Ve
.PP
.Vb 2
\&        die "Error reading from $file: $gzerrno" . ($gzerrno+0) . "\en" 
\&            if $gzerrno != Z_STREAM_END ;
.Ve
.PP
.Vb 2
\&        $gz->gzclose() ;
\&    }
.Ve
.PP
Below is a script which makes use of \fBgzreadline\fR. It implements a
very simple \fIgrep\fR like script.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
.Ve
.PP
.Vb 1
\&    use Compress::Zlib ;
.Ve
.PP
.Vb 2
\&    die "Usage: gzgrep pattern file...\en"
\&        unless @ARGV >= 2;
.Ve
.PP
.Vb 1
\&    my $pattern = shift ;
.Ve
.PP
.Vb 1
\&    my $file ;
.Ve
.PP
.Vb 3
\&    foreach $file (@ARGV) {
\&        my $gz = gzopen($file, "rb") 
\&             or die "Cannot open $file: $gzerrno\en" ;
.Ve
.PP
.Vb 3
\&        while ($gz->gzreadline($_) > 0) {
\&            print if /$pattern/ ;
\&        }
.Ve
.PP
.Vb 2
\&        die "Error reading from $file: $gzerrno\en" 
\&            if $gzerrno != Z_STREAM_END ;
.Ve
.PP
.Vb 2
\&        $gz->gzclose() ;
\&    }
.Ve
.PP
This script, \fIgzstream\fR, does the opposite of the \fIgzcat\fR script
above. It reads from standard input and writes a gzip file to standard
output.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
.Ve
.PP
.Vb 1
\&    use Compress::Zlib ;
.Ve
.PP
.Vb 1
\&    binmode STDOUT;     # gzopen only sets it on the fd
.Ve
.PP
.Vb 2
\&    my $gz = gzopen(\e*STDOUT, "wb")
\&          or die "Cannot open stdout: $gzerrno\en" ;
.Ve
.PP
.Vb 4
\&    while (<>) {
\&        $gz->gzwrite($_) 
\&        or die "error writing: $gzerrno\en" ;
\&    }
.Ve
.PP
.Vb 1
\&    $gz->gzclose ;
.Ve
.Sh "Compress::Zlib::memGzip"
.IX Subsection "Compress::Zlib::memGzip"
This function is used to create an in-memory gzip file. 
It creates a minimal gzip header.
.PP
.Vb 1
\&    $dest = Compress::Zlib::memGzip($buffer) ;
.Ve
.PP
If successful, it returns the in-memory gzip file, otherwise it returns
undef.
.PP
The buffer parameter can either be a scalar or a scalar reference.
.Sh "Compress::Zlib::memGunzip"
.IX Subsection "Compress::Zlib::memGunzip"
This function is used to uncompress an in-memory gzip file.
.PP
.Vb 1
\&    $dest = Compress::Zlib::memGunzip($buffer) ;
.Ve
.PP
If successful, it returns the uncompressed gzip file, otherwise it
returns undef.
.PP
The buffer parameter can either be a scalar or a scalar reference. The
contents of the buffer parameter are destroyed after calling this
function.
.SH "CHECKSUM FUNCTIONS"
.IX Header "CHECKSUM FUNCTIONS"
Two functions are provided by \fIzlib\fR to calculate a checksum. For the
Perl interface, the order of the two parameters in both functions has
been reversed. This allows both running checksums and one off
calculations to be done.
.PP
.Vb 2
\&    $crc = adler32($buffer [,$crc]) ;
\&    $crc = crc32($buffer [,$crc]) ;
.Ve
.PP
The buffer parameters can either be a scalar or a scalar reference.
.PP
If the \f(CW$crc\fR parameters is \f(CW\*(C`undef\*(C'\fR, the crc value will be reset.
.SH "ACCESSING ZIP FILES"
.IX Header "ACCESSING ZIP FILES"
Although it is possible to use this module to access .zip files, there
is a module on \s-1CPAN\s0 that will do all the hard work for you. Check out
.PP
.Vb 1
\&    http://www.cpan.org/modules/by-module/Archive/Archive-Zip-*.tar.gz
.Ve
.PP
Assuming you don't want to use this module to access zip files there
are a number of undocumented features in the zlib library you need to
be aware of.
.IP "1." 5
When calling \fBinflateInit\fR or \fBdeflateInit\fR the \fBWindowBits\fR parameter
must be set to \f(CW\*(C`\-MAX_WBITS\*(C'\fR. This disables the creation of the zlib
header.
.IP "2." 5
The zlib function \fBinflate\fR, and so the \fBinflate\fR method supplied in
this module, assume that there is at least one trailing byte after the
compressed data stream. Normally this isn't a problem because both
the gzip and zip file formats will guarantee that there is data directly
after the compressed data stream.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
All the \fIzlib\fR constants are automatically imported when you make use
of \fICompress::Zlib\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
The \fICompress::Zlib\fR module was written by Paul Marquess,
\&\fIpmqs@cpan.org\fR. The latest copy of the module can be
found on \s-1CPAN\s0 in \fImodules/by\-module/Compress/Compress\-Zlib\-x.x.tar.gz\fR.
.PP
The primary site for the \fIzlib\fR compression library is
\&\fIhttp://www.zlib.org\fR.
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
See the Changes file.

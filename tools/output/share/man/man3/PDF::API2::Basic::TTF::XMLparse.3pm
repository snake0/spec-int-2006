.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PDF::API2::Basic::TTF::XMLparse 3"
.TH PDF::API2::Basic::TTF::XMLparse 3 "2014-04-08" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
PDF::API2::Basic::TTF::XMLparse \- provides support for XML parsing. Requires Expat module XML::Parser::Expat
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use PDF::API2::Basic::TTF::Font;
\&    use PDF::API2::Basic::TTF::XMLparse;
.Ve
.PP
.Vb 3
\&    $f = PDF::API2::Basic::TTF::Font->new;
\&    read_xml($f, $ARGV[0]);
\&    $f->out($ARGV[1]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module contains the support routines for parsing \s-1XML\s0 and generating the
Truetype font structures as a result. The module has been separated from the rest
of the package in order to reduce the dependency that this would bring, of the
whole package on XML::Parser. This way, people without the XML::Parser can still
use the rest of the package.
.PP
The package interacts with another package through the use of a context containing
and element 'receiver' which is an object which can possibly receive one of the
following messages:
.IP "XML_start" 4
.IX Item "XML_start"
This message is called when an open tag occurs. It is called with the context,
tag name and the attributes. The return value has no meaning.
.IP "XML_end" 4
.IX Item "XML_end"
This messages is called when a close tag occurs. It is called with the context,
tag name and attributes (held over from when the tag was opened). There are 3
possible return values from such a message:
.RS 4
.IP "undef" 8
.IX Item "undef"
This is the default return value indicating that default processing should
occur in which either the current element on the tree, or the text of this element
should be stored in the parent object.
.IP "$context" 8
.IX Item "$context"
This magic value marks that the element should be deleted from the parent.
Nothing is stored in the parent. (This rather than '' is used to allow 0 returns.)
.IP "anything" 8
.IX Item "anything"
Anything else is taken as the element content to be stored in the parent.
.RE
.RS 4
.RE
.PP
In addition, the context hash passed to these messages contains the following
keys:
.IP "xml" 4
.IX Item "xml"
This is the expat xml object. The context is also available as
\&\f(CW$context\fR\->{'xml'}{' mycontext'}. But that is a long winded way of not saying much!
.IP "font" 4
.IX Item "font"
This is the base object that was passed in for \s-1XML\s0 parsing.
.IP "receiver" 4
.IX Item "receiver"
This holds the current receiver of parsing events. It may be set in associated
application to adjust which objects should receive messages when. It is also stored
in the parsing stack to ensure that where an object changes it during XML_start, that
that same object that received XML_start will receive the corresponding XML_end
.IP "stack" 4
.IX Item "stack"
This is the parsing stack, used internally to hold the current receiver and attributes
for each element open, as a complete hierarchy back to the root element.
.IP "tree" 4
.IX Item "tree"
This element contains the storage tree corresponding to the parent of each element
in the stack. The default action is to push undef onto this stack during XML_start
and then to resolve this, either in the associated application (by changing
\&\f(CW$context\fR\->{'tree'}[\-1]) or during XML_end of a child element, by which time we know
whether we are dealing with an array or a hash or what.
.IP "text" 4
.IX Item "text"
Character processing is to insert all the characters into the text element of the
context for available use later.
.SH "METHODS"
.IX Header "METHODS"

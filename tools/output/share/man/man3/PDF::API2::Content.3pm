.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PDF::API2::Content 3"
.TH PDF::API2::Content 3 "2014-04-08" "perl v5.8.7" "User Contributed Perl Documentation"
.ie n .SH "$co = PDF::API2::Content\->new @parameters"
.el .SH "$co = PDF::API2::Content\->new \f(CW@parameters\fP"
.IX Header "$co = PDF::API2::Content->new @parameters"
Returns a new content object (called from \f(CW$page\fR\->text/gfx).
.RE
.ie n .IP "$co\->add @content"
.el .IP "$co\->add \f(CW@content\fR"
.IX Item "$co->add @content"
Adds \f(CW@content\fR to the object.
.RE
.IP "$co\->save"
.IX Item "$co->save"
Saves the state of the object.
.RE
.IP "$co\->restore"
.IX Item "$co->restore"
Restores the state of the object.
.RE
.IP "$co\->compress"
.IX Item "$co->compress"
Marks content for compression on output.
.RE
.ie n .IP "$co\->flatness $flat"
.el .IP "$co\->flatness \f(CW$flat\fR"
.IX Item "$co->flatness $flat"
Sets flatness.
.RE
.ie n .IP "$co\->linecap $cap"
.el .IP "$co\->linecap \f(CW$cap\fR"
.IX Item "$co->linecap $cap"
Sets linecap.
.RE
.ie n .IP "$co\->linedash @dash"
.el .IP "$co\->linedash \f(CW@dash\fR"
.IX Item "$co->linedash @dash"
Sets linedash.
.RE
.ie n .IP "$co\->linejoin $join"
.el .IP "$co\->linejoin \f(CW$join\fR"
.IX Item "$co->linejoin $join"
Sets linejoin.
.RE
.ie n .IP "$co\->linewidth $width"
.el .IP "$co\->linewidth \f(CW$width\fR"
.IX Item "$co->linewidth $width"
Sets linewidth.
.RE
.ie n .IP "$co\->meterlimit $limit"
.el .IP "$co\->meterlimit \f(CW$limit\fR"
.IX Item "$co->meterlimit $limit"
Sets meterlimit.
.RE
.ie n .IP "$co\->matrix $a,$b,$c,$d,$e,$f"
.el .IP "$co\->matrix \f(CW$a\fR,$b,$c,$d,$e,$f"
.IX Item "$co->matrix $a,$b,$c,$d,$e,$f"
Sets matrix transformation.
.RE
.ie n .IP "$co\->translate $x,$y"
.el .IP "$co\->translate \f(CW$x\fR,$y"
.IX Item "$co->translate $x,$y"
Sets translation transformation.
.RE
.ie n .IP "$co\->scale $sx,$sy"
.el .IP "$co\->scale \f(CW$sx\fR,$sy"
.IX Item "$co->scale $sx,$sy"
Sets scaleing transformation.
.RE
.ie n .IP "$co\->skew $sa,$sb"
.el .IP "$co\->skew \f(CW$sa\fR,$sb"
.IX Item "$co->skew $sa,$sb"
Sets skew transformation.
.RE
.ie n .IP "$co\->rotate $rot"
.el .IP "$co\->rotate \f(CW$rot\fR"
.IX Item "$co->rotate $rot"
Sets rotation transformation.
.RE
.ie n .IP "$co\->transform %opts"
.el .IP "$co\->transform \f(CW%opts\fR"
.IX Item "$co->transform %opts"
Sets transformations (eg. translate, rotate, scale, skew) in pdf-canonical order.
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&    $co->transform(
\&        -translate => [$x,$y],
\&        -rotate    => $rot,
\&        -scale     => [$sx,$sy],
\&        -skew      => [$sa,$sb],
\&    )
.Ve
.RE
.ie n .IP "$co\->fillcolor @colors"
.el .IP "$co\->fillcolor \f(CW@colors\fR"
.IX Item "$co->fillcolor @colors"
.RE
.PD 0
.ie n .IP "$co\->strokecolor @colors"
.el .IP "$co\->strokecolor \f(CW@colors\fR"
.IX Item "$co->strokecolor @colors"
.PD
Sets fill\-/strokecolor, see PDF::API2::Util for a list of possible color specifiers.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&    $co->fillcolor('blue');       # blue
\&    $co->strokecolor('#FF0000');  # red
\&    $co->fillcolor('%FFF000000'); # cyan
.Ve
.SH "GRAPHICS METHODS"
.IX Header "GRAPHICS METHODS"
.ie n .IP "$gfx\->move $x\fR, \f(CW$y" 4
.el .IP "$gfx\->move \f(CW$x\fR, \f(CW$y\fR" 4
.IX Item "$gfx->move $x, $y"
.PD 0
.ie n .IP "$gfx\->line $x\fR, \f(CW$y" 4
.el .IP "$gfx\->line \f(CW$x\fR, \f(CW$y\fR" 4
.IX Item "$gfx->line $x, $y"
.ie n .IP "$gfx\->hline $x" 4
.el .IP "$gfx\->hline \f(CW$x\fR" 4
.IX Item "$gfx->hline $x"
.ie n .IP "$gfx\->vline $y" 4
.el .IP "$gfx\->vline \f(CW$y\fR" 4
.IX Item "$gfx->vline $y"
.ie n .IP "$gfx\->curve $cx1\fR, \f(CW$cy1\fR, \f(CW$cx2\fR, \f(CW$cy2\fR, \f(CW$x\fR, \f(CW$y" 4
.el .IP "$gfx\->curve \f(CW$cx1\fR, \f(CW$cy1\fR, \f(CW$cx2\fR, \f(CW$cy2\fR, \f(CW$x\fR, \f(CW$y\fR" 4
.IX Item "$gfx->curve $cx1, $cy1, $cx2, $cy2, $x, $y"
.ie n .IP "$gfx\->spline $cx1\fR, \f(CW$cy1\fR, \f(CW$x\fR, \f(CW$y" 4
.el .IP "$gfx\->spline \f(CW$cx1\fR, \f(CW$cy1\fR, \f(CW$x\fR, \f(CW$y\fR" 4
.IX Item "$gfx->spline $cx1, $cy1, $x, $y"
.ie n .IP "$gfx\->arc $x\fR, \f(CW$y\fR, \f(CW$a\fR, \f(CW$b\fR, \f(CW$alfa\fR, \f(CW$beta\fR, \f(CW$move" 4
.el .IP "$gfx\->arc \f(CW$x\fR, \f(CW$y\fR, \f(CW$a\fR, \f(CW$b\fR, \f(CW$alfa\fR, \f(CW$beta\fR, \f(CW$move\fR" 4
.IX Item "$gfx->arc $x, $y, $a, $b, $alfa, $beta, $move"
.PD
will draw an arc centered at x,y with minor/major\-axis
given by a,b from alfa to beta (degrees). move must be
set to 1, unless you want to continue an existing path.
.ie n .IP "$gfx\->ellipse $x\fR, \f(CW$y\fR, \f(CW$a\fR, \f(CW$b" 4
.el .IP "$gfx\->ellipse \f(CW$x\fR, \f(CW$y\fR, \f(CW$a\fR, \f(CW$b\fR" 4
.IX Item "$gfx->ellipse $x, $y, $a, $b"
.PD 0
.ie n .IP "$gfx\->circle $x\fR, \f(CW$y\fR, \f(CW$r" 4
.el .IP "$gfx\->circle \f(CW$x\fR, \f(CW$y\fR, \f(CW$r\fR" 4
.IX Item "$gfx->circle $x, $y, $r"
.ie n .IP "$gfx\->bogen $x1\fR, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR, \f(CW$r\fR, \f(CW$move\fR, \f(CW$larc\fR, \f(CW$span" 4
.el .IP "$gfx\->bogen \f(CW$x1\fR, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR, \f(CW$r\fR, \f(CW$move\fR, \f(CW$larc\fR, \f(CW$span\fR" 4
.IX Item "$gfx->bogen $x1, $y1, $x2, $y2, $r, $move, $larc, $span"
.PD
will draw an arc of a circle from x1,y1 to x2,y2 with radius r.
move must be set to 1, unless you want to continue an existing path.
larc can be set to 1, if you want to draw the larger instead of the
shorter arc. span can be set to 1, if you want to draw the arc
on the other side. \s-1NOTE:\s0 2*r cannot be smaller than the distance
from x1,y1 to x2,y2.
.ie n .IP "$gfx\->pie $x\fR, \f(CW$y\fR, \f(CW$a\fR, \f(CW$b\fR, \f(CW$alfa\fR, \f(CW$beta" 4
.el .IP "$gfx\->pie \f(CW$x\fR, \f(CW$y\fR, \f(CW$a\fR, \f(CW$b\fR, \f(CW$alfa\fR, \f(CW$beta\fR" 4
.IX Item "$gfx->pie $x, $y, $a, $b, $alfa, $beta"
.PD 0
.ie n .IP "$gfx\->rect $x1\fR,$y1, \f(CW$w1\fR,$h1, ..., \f(CW$xn\fR,$yn, \f(CW$wn,$hn" 4
.el .IP "$gfx\->rect \f(CW$x1\fR,$y1, \f(CW$w1\fR,$h1, ..., \f(CW$xn\fR,$yn, \f(CW$wn\fR,$hn" 4
.IX Item "$gfx->rect $x1,$y1, $w1,$h1, ..., $xn,$yn, $wn,$hn"
.ie n .IP "$gfx\->rectxy $x1\fR,$y1, \f(CW$x2,$y2" 4
.el .IP "$gfx\->rectxy \f(CW$x1\fR,$y1, \f(CW$x2\fR,$y2" 4
.IX Item "$gfx->rectxy $x1,$y1, $x2,$y2"
.ie n .IP "$gfx\->poly $x1\fR,$y1, ..., \f(CW$xn,$yn" 4
.el .IP "$gfx\->poly \f(CW$x1\fR,$y1, ..., \f(CW$xn\fR,$yn" 4
.IX Item "$gfx->poly $x1,$y1, ..., $xn,$yn"
.IP "$gfx\->close" 4
.IX Item "$gfx->close"
.IP "$gfx\->endpath" 4
.IX Item "$gfx->endpath"
.ie n .IP "$gfx\->clip $nonzero" 4
.el .IP "$gfx\->clip \f(CW$nonzero\fR" 4
.IX Item "$gfx->clip $nonzero"
.IP "$gfx\->stroke" 4
.IX Item "$gfx->stroke"
.ie n .IP "$gfx\->fill $nonzero" 4
.el .IP "$gfx\->fill \f(CW$nonzero\fR" 4
.IX Item "$gfx->fill $nonzero"
.ie n .IP "$gfx\->fillstroke $nonzero" 4
.el .IP "$gfx\->fillstroke \f(CW$nonzero\fR" 4
.IX Item "$gfx->fillstroke $nonzero"
.ie n .IP "$gfx\->image $imgobj\fR, \f(CW$x\fR,$y, \f(CW$w,$h" 4
.el .IP "$gfx\->image \f(CW$imgobj\fR, \f(CW$x\fR,$y, \f(CW$w\fR,$h" 4
.IX Item "$gfx->image $imgobj, $x,$y, $w,$h"
.ie n .IP "$gfx\->image $imgobj\fR, \f(CW$x\fR,$y, \f(CW$scale" 4
.el .IP "$gfx\->image \f(CW$imgobj\fR, \f(CW$x\fR,$y, \f(CW$scale\fR" 4
.IX Item "$gfx->image $imgobj, $x,$y, $scale"
.ie n .IP "$gfx\->image $imgobj\fR, \f(CW$x,$y" 4
.el .IP "$gfx\->image \f(CW$imgobj\fR, \f(CW$x\fR,$y" 4
.IX Item "$gfx->image $imgobj, $x,$y"
.PD
\&\fBPlease Note:\fR The width/height or scale given
is in user-space coordinates which is subject to
transformations which may have been specified beforehand.
.Sp
Per default this has a 72dpi resolution, so if you want an
image to have a 150 or 300dpi resolution, you should specify
a scale of 72/150 (or 72/300) or adjust width/height accordingly.
.ie n .IP "$gfx\->formimage $imgobj\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$scale" 4
.el .IP "$gfx\->formimage \f(CW$imgobj\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$scale\fR" 4
.IX Item "$gfx->formimage $imgobj, $x, $y, $scale"
.PD 0
.ie n .IP "$gfx\->formimage $imgobj\fR, \f(CW$x\fR, \f(CW$y" 4
.el .IP "$gfx\->formimage \f(CW$imgobj\fR, \f(CW$x\fR, \f(CW$y\fR" 4
.IX Item "$gfx->formimage $imgobj, $x, $y"
.PD
\&\fBPlease Note:\fR *TODO*
.ie n .IP "$gfx\->shade $shadeobj\fR, \f(CW$x1\fR,$y1, \f(CW$x2,$y2" 4
.el .IP "$gfx\->shade \f(CW$shadeobj\fR, \f(CW$x1\fR,$y1, \f(CW$x2\fR,$y2" 4
.IX Item "$gfx->shade $shadeobj, $x1,$y1, $x2,$y2"
.PD 0
.ie n .IP "$gfx\->egstate $egsobj" 4
.el .IP "$gfx\->egstate \f(CW$egsobj\fR" 4
.IX Item "$gfx->egstate $egsobj"
.IP "$hyb\->textstart" 4
.IX Item "$hyb->textstart"
.ie n .IP "%state = $txt\fR\->textstate \f(CW%state" 4
.el .IP "%state = \f(CW$txt\fR\->textstate \f(CW%state\fR" 4
.IX Item "%state = $txt->textstate %state"
.PD
Sets or gets the current text-object state.
.ie n .IP "($tx,$ty) = $txt\->textpos" 4
.el .IP "($tx,$ty) = \f(CW$txt\fR\->textpos" 4
.IX Item "($tx,$ty) = $txt->textpos"
Gets the current estimated text position.
.Sp
\&\fBNote:\fR This is relative to text\-space.
.ie n .IP "$txt\->transform_rel %opts" 4
.el .IP "$txt\->transform_rel \f(CW%opts\fR" 4
.IX Item "$txt->transform_rel %opts"
Sets transformations (eg. translate, rotate, scale, skew) in pdf-canonical order,
but relative to the previously set values.
.Sp
\&\fBExample:\fR
.Sp
.Vb 6
\&  $txt->transform_rel(
\&    -translate => [$x,$y],
\&    -rotate    => $rot,
\&    -scale     => [$sx,$sy],
\&    -skew      => [$sa,$sb],
\&  )
.Ve
.ie n .IP "$txt\->font $fontobj,$size" 4
.el .IP "$txt\->font \f(CW$fontobj\fR,$size" 4
.IX Item "$txt->font $fontobj,$size"
.PD 0
.ie n .IP "$txt\->fontset $fontobj,$size" 4
.el .IP "$txt\->fontset \f(CW$fontobj\fR,$size" 4
.IX Item "$txt->fontset $fontobj,$size"
.PD
\&\fIThe fontset method \s-1WILL\s0 \s-1NOT\s0 \s-1APPLY\s0 the font+size to the pdf\-stream, but
which will later be done by the text\-methods.\fR
.Sp
\&\fBOnly use fontset if you know what you are doing, there is no super-secret failsave!\fR
.ie n .IP "$spacing = $txt\fR\->charspace \f(CW$spacing" 4
.el .IP "$spacing = \f(CW$txt\fR\->charspace \f(CW$spacing\fR" 4
.IX Item "$spacing = $txt->charspace $spacing"
.PD 0
.ie n .IP "$spacing = $txt\fR\->wordspace \f(CW$spacing" 4
.el .IP "$spacing = \f(CW$txt\fR\->wordspace \f(CW$spacing\fR" 4
.IX Item "$spacing = $txt->wordspace $spacing"
.ie n .IP "$spacing = $txt\fR\->hspace \f(CW$spacing" 4
.el .IP "$spacing = \f(CW$txt\fR\->hspace \f(CW$spacing\fR" 4
.IX Item "$spacing = $txt->hspace $spacing"
.ie n .IP "$leading = $txt\fR\->lead \f(CW$leading" 4
.el .IP "$leading = \f(CW$txt\fR\->lead \f(CW$leading\fR" 4
.IX Item "$leading = $txt->lead $leading"
.ie n .IP "$rise = $txt\fR\->rise \f(CW$rise" 4
.el .IP "$rise = \f(CW$txt\fR\->rise \f(CW$rise\fR" 4
.IX Item "$rise = $txt->rise $rise"
.ie n .IP "$rendering = $txt\fR\->render \f(CW$rendering" 4
.el .IP "$rendering = \f(CW$txt\fR\->render \f(CW$rendering\fR" 4
.IX Item "$rendering = $txt->render $rendering"
.ie n .IP "$txt\->cr $linesize" 4
.el .IP "$txt\->cr \f(CW$linesize\fR" 4
.IX Item "$txt->cr $linesize"
.PD
takes an optional argument giving a custom leading between lines.
.IP "$txt\->nl" 4
.IX Item "$txt->nl"
.PD 0
.ie n .IP "$txt\->distance $dx,$dy" 4
.el .IP "$txt\->distance \f(CW$dx\fR,$dy" 4
.IX Item "$txt->distance $dx,$dy"
.ie n .IP "$width = $txt\fR\->advancewidth \f(CW$string\fR [, \f(CW%textstate]" 4
.el .IP "$width = \f(CW$txt\fR\->advancewidth \f(CW$string\fR [, \f(CW%textstate\fR]" 4
.IX Item "$width = $txt->advancewidth $string [, %textstate]"
.PD
Returns the width of the string based on all currently set text-attributes
or on those overridden by \f(CW%textstate\fR.
.ie n .IP "$width = $txt\fR\->text \f(CW$text\fR, \f(CW%options" 4
.el .IP "$width = \f(CW$txt\fR\->text \f(CW$text\fR, \f(CW%options\fR" 4
.IX Item "$width = $txt->text $text, %options"
Applys text to the content and optionally returns the width of the given text.
.Sp
Options
.IP "\-indent" 4
.IX Item "-indent"
Indent the text by the number of points.
.IP "\-underline" 4
.IX Item "-underline"
If this is a scalar, it is the distance, in points, below the baseline where
the line is drawn. The line thickness is one point. If it is a reference to an
array, each pair is the distance below the baseline and the thickness of the
line (ie., \f(CW\*(C`\-underline=>[2,1,4,2]\*(C'\fR will draw a double underline
with the lower twice as thick as the upper).
.Sp
If thickness is a reference to an array, the first value is the thickness
and the second value is the color of the line (ie., 
\&\f(CW\*(C`\-underline=>[2,[1,'red'],4,[2,'#0000ff']]\*(C'\fR will draw a \*(L"red\*(R" and a 
\&\*(L"blue\*(R" line).
.Sp
You can also use the string \f(CW'auto'\fR for either or both distance and thickness 
values to auto-magically calculate best values from the font\-definition.
.RE
.ie n .IP "$txt\->text_center $text"
.el .IP "$txt\->text_center \f(CW$text\fR"
.IX Item "$txt->text_center $text"
.RE
.PD 0
.ie n .IP "$txt\->text_right $text\fR, \f(CW%options"
.el .IP "$txt\->text_right \f(CW$text\fR, \f(CW%options\fR"
.IX Item "$txt->text_right $text, %options"
.RE
.ie n .IP "$width = $txt\fR\->text_justified \f(CW$text\fR, \f(CW$width\fR, \f(CW%options"
.el .IP "$width = \f(CW$txt\fR\->text_justified \f(CW$text\fR, \f(CW$width\fR, \f(CW%options\fR"
.IX Item "$width = $txt->text_justified $text, $width, %options"
.PD
** \s-1DEVELOPER\s0 \s-1METHOD\s0 **
.RE
.ie n .IP "($width,$chunktext) = $txt\fR\->text_fill_left \f(CW$text\fR, \f(CW$width"
.el .IP "($width,$chunktext) = \f(CW$txt\fR\->text_fill_left \f(CW$text\fR, \f(CW$width\fR"
.IX Item "($width,$chunktext) = $txt->text_fill_left $text, $width"
** \s-1DEVELOPER\s0 \s-1METHOD\s0 **
.RE
.ie n .IP "($width,$chunktext) = $txt\fR\->text_fill_center \f(CW$text\fR, \f(CW$width\fR, \f(CW%options"
.el .IP "($width,$chunktext) = \f(CW$txt\fR\->text_fill_center \f(CW$text\fR, \f(CW$width\fR, \f(CW%options\fR"
.IX Item "($width,$chunktext) = $txt->text_fill_center $text, $width, %options"
** \s-1DEVELOPER\s0 \s-1METHOD\s0 **
.RE
.ie n .IP "($width,$chunktext) = $txt\fR\->text_fill_right \f(CW$text\fR, \f(CW$width"
.el .IP "($width,$chunktext) = \f(CW$txt\fR\->text_fill_right \f(CW$text\fR, \f(CW$width\fR"
.IX Item "($width,$chunktext) = $txt->text_fill_right $text, $width"
** \s-1DEVELOPER\s0 \s-1METHOD\s0 **
.RE
.ie n .IP "($width,$chunktext) = $txt\fR\->text_fill_justified \f(CW$text\fR, \f(CW$width"
.el .IP "($width,$chunktext) = \f(CW$txt\fR\->text_fill_justified \f(CW$text\fR, \f(CW$width\fR"
.IX Item "($width,$chunktext) = $txt->text_fill_justified $text, $width"
** \s-1DEVELOPER\s0 \s-1METHOD\s0 **
.RE
.ie n .IP "$overflow_text = $txt\fR\->paragraph \f(CW$text\fR, \f(CW$width\fR, \f(CW$height\fR, \f(CW%options"
.el .IP "$overflow_text = \f(CW$txt\fR\->paragraph \f(CW$text\fR, \f(CW$width\fR, \f(CW$height\fR, \f(CW%options\fR"
.IX Item "$overflow_text = $txt->paragraph $text, $width, $height, %options"
** \s-1DEVELOPER\s0 \s-1METHOD\s0 **
.PP
Apply the text within the rectangle and return any leftover text.
.PP
\&\fBOptions\fR
.ie n .IP "\-align => $choice" 4
.el .IP "\-align => \f(CW$choice\fR" 4
.IX Item "-align => $choice"
Choice is 'justified', 'right', 'center', 'left'
Default is 'left'
.ie n .IP "\-underline => $distance" 4
.el .IP "\-underline => \f(CW$distance\fR" 4
.IX Item "-underline => $distance"
.PD 0
.ie n .IP "\-underline => [ $distance\fR, \f(CW$thickness, ... ]" 4
.el .IP "\-underline => [ \f(CW$distance\fR, \f(CW$thickness\fR, ... ]" 4
.IX Item "-underline => [ $distance, $thickness, ... ]"
.PD
If a scalar, distance below baseline,
else array reference with pairs of distance and line thickness.
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&    $txt->font($font,$fontsize);
\&    $txt->lead($lead);
\&    $txt->translate($x,$y);
\&    $overflow = $txt->paragraph( 'long paragraph here ...',
\&                                 $width,
\&                                 $y+$lead-$bottom_margin );
.Ve
.RE
.IP "$hyb\->textend"
.IX Item "$hyb->textend"
.RE
.PD 0
.ie n .IP "$width = $txt\fR\->textlabel \f(CW$x\fR, \f(CW$y\fR, \f(CW$font\fR, \f(CW$size\fR, \f(CW$text\fR, \f(CW%options"
.el .IP "$width = \f(CW$txt\fR\->textlabel \f(CW$x\fR, \f(CW$y\fR, \f(CW$font\fR, \f(CW$size\fR, \f(CW$text\fR, \f(CW%options\fR"
.IX Item "$width = $txt->textlabel $x, $y, $font, $size, $text, %options"
.PD
Applys text with options, but without teststart/end and optionally returns the width of the given text.
.PP
\&\fBExample:\fR 
.PP
.Vb 7
\&    $t = $page->gfx;
\&    $t->textlabel(300,700,$myfont,20,'Page Header',
\&        -rotate => -30,
\&        -color => '#FF0000',
\&        -hspace => 120,
\&        -center => 1,
\&    );
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
alfred reibenschuh
.SH "HISTORY"
.IX Header "HISTORY"
.Vb 3
\&    $Log: Content.pm,v $
\&    Revision 1.34  2005/03/15 02:20:46  fredo
\&    added metadata stubs
.Ve
.PP
.Vb 2
\&    Revision 1.33  2005/03/14 22:01:05  fredo
\&    upd 2005
.Ve
.PP
.Vb 3
\&    Revision 1.32  2005/03/14 20:26:44  fredo
\&    added 'auto' value for -underline parameter in text
\&    fixed text line construction to to work under width==0 conditions
.Ve
.PP
.Vb 2
\&    Revision 1.31  2005/02/22 22:59:49  fredo
\&    fixed infinite loop in paragraph if words longer than a paragraph are present.
.Ve
.PP
.Vb 2
\&    Revision 1.30  2005/02/07 19:31:24  fredo
\&    fixed reset of textlinematrix on textmatrix set/resets
.Ve
.PP
.Vb 2
\&    Revision 1.29  2005/01/21 10:19:48  fredo
\&    added spline operator
.Ve
.PP
.Vb 2
\&    Revision 1.28  2005/01/03 01:16:51  fredo
\&    fixed textpos tracking in nl method
.Ve
.PP
.Vb 3
\&    Revision 1.27  2004/12/31 03:59:09  fredo
\&    fixed paragraph and text_fill_* methods
\&    (thanks to Shawn Corey <shawn.corey@sympatico.ca>)
.Ve
.PP
.Vb 2
\&    Revision 1.26  2004/12/31 02:53:18  fredo
\&    minor code corrections
.Ve
.PP
.Vb 4
\&    Revision 1.25  2004/12/31 02:06:37  fredo
\&    fixed textpos calculation,
\&    added underline capability
\&    (thanks to Shawn Corey <shawn.corey@sympatico.ca>)
.Ve
.PP
.Vb 2
\&    Revision 1.24  2004/12/29 22:01:57  fredo
\&    advancewidth now can take a virtual textstate
.Ve
.PP
.Vb 2
\&    Revision 1.23  2004/12/29 01:48:15  fredo
\&    fixed _font method
.Ve
.PP
.Vb 2
\&    Revision 1.22  2004/12/29 01:14:57  fredo
\&    added virtual attribute support
.Ve
.PP
.Vb 2
\&    Revision 1.21  2004/12/20 12:11:54  fredo
\&    added fontset method to not set via 'Tf'
.Ve
.PP
.Vb 2
\&    Revision 1.20  2004/12/16 00:30:51  fredo
\&    added no warn for recursion
.Ve
.PP
.Vb 2
\&    Revision 1.19  2004/12/15 16:44:43  fredo
\&    added condition to apply font (Tf) only when needed
.Ve
.PP
.Vb 2
\&    Revision 1.18  2004/11/25 20:53:59  fredo
\&    fixed unifont registration
.Ve
.PP
.Vb 2
\&    Revision 1.17  2004/11/24 20:10:31  fredo
\&    added virtual font handling, fixed var shadow bug
.Ve
.PP
.Vb 2
\&    Revision 1.16  2004/10/26 11:34:22  fredo
\&    reworked text_fill for paragraph, but still being development
.Ve
.PP
.Vb 2
\&    Revision 1.15  2004/08/31 13:50:09  fredo
\&    fixed space vs. whitespace split bug
.Ve
.PP
.Vb 2
\&    Revision 1.14  2004/07/29 10:46:37  fredo
\&    added new text_fill_* methods and a simple paragraph
.Ve
.PP
.Vb 2
\&    Revision 1.13  2004/06/21 22:33:36  fredo
\&    added basic pattern/shading handling
.Ve
.PP
.Vb 2
\&    Revision 1.12  2004/06/15 09:11:37  fredo
\&    removed cr+lf
.Ve
.PP
.Vb 2
\&    Revision 1.11  2004/06/07 19:44:12  fredo
\&    cleaned out cr+lf for lf
.Ve
.PP
.Vb 2
\&    Revision 1.10  2004/05/31 23:20:48  fredo
\&    added basic platform encoding independency
.Ve
.PP
.Vb 2
\&    Revision 1.9  2004/04/07 10:49:26  fredo
\&    fixed handling of colorSpaces for fill/strokecolor
.Ve
.PP
.Vb 2
\&    Revision 1.8  2004/02/12 14:46:44  fredo
\&    removed duplicate definition of egstate method
.Ve
.PP
.Vb 2
\&    Revision 1.7  2004/02/06 02:01:25  fredo
\&    added save/restore around textlabel
.Ve
.PP
.Vb 2
\&    Revision 1.6  2004/02/05 23:24:00  fredo
\&    fixed lab behavior
.Ve
.PP
.Vb 3
\&    Revision 1.5  2004/02/05 12:26:08  fredo
\&    revised '_makecolor' to use Lab for hsv/hsl,
\&    added textlabel method
.Ve
.PP
.Vb 2
\&    Revision 1.4  2003/12/08 13:05:19  Administrator
\&    corrected to proper licencing statement
.Ve
.PP
.Vb 2
\&    Revision 1.3  2003/11/30 17:09:18  Administrator
\&    merged into default
.Ve
.PP
.Vb 2
\&    Revision 1.2.2.1  2003/11/30 16:56:21  Administrator
\&    merged into default
.Ve
.PP
.Vb 2
\&    Revision 1.2  2003/11/30 11:33:59  Administrator
\&    added CVS id/log
.Ve

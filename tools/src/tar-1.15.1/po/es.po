# Mensajes en español para GNU tar.
# Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
# Federico Rivas <frivas@arrakis.es>, 1997.
# Enrique Melero <melero@iprolink.ch>, 1997.
# Santiago Vila Doncel <sanvila@unex.es>, 1998, 1999, 2000, 2001, 2002.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU tar 1.13.25\n"
"Report-Msgid-Bugs-To: bug-tar@gnu.org\n"
"POT-Creation-Date: 2004-12-21 17:11+0200\n"
"PO-Revision-Date: 2002-04-26 17:02+0200\n"
"Last-Translator: Santiago Vila Doncel <sanvila@unex.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

#: lib/argmatch.c:137
#, c-format
msgid "invalid argument %s for %s"
msgstr "argumento %s inválido para %s"

#: lib/argmatch.c:138
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "argumento %s ambiguo para %s"

#: lib/argmatch.c:157
#, c-format
msgid "Valid arguments are:"
msgstr "Los argumentos válidos son:"

#: lib/error.c:123 rmt/rmt.c:92
msgid "Unknown system error"
msgstr "Error del sistema desconocido"

#: lib/getopt.c:551 lib/getopt.c:570
#, c-format
msgid "%s: option `%s' is ambiguous\n"
msgstr "%s: la opción `%s' es ambigua\n"

#: lib/getopt.c:603 lib/getopt.c:607
#, c-format
msgid "%s: option `--%s' doesn't allow an argument\n"
msgstr "%s: la opción `--%s' no admite ningún argumento\n"

#: lib/getopt.c:616 lib/getopt.c:621
#, c-format
msgid "%s: option `%c%s' doesn't allow an argument\n"
msgstr "%s: la opción `%c%s' no admite ningún argumento\n"

#: lib/getopt.c:667 lib/getopt.c:689 lib/getopt.c:1020 lib/getopt.c:1042
#, c-format
msgid "%s: option `%s' requires an argument\n"
msgstr "%s: la opción `%s' requiere un argumento\n"

#: lib/getopt.c:727 lib/getopt.c:730
#, c-format
msgid "%s: unrecognized option `--%s'\n"
msgstr "%s: opción no reconocida `--%s'\n"

#: lib/getopt.c:738 lib/getopt.c:741
#, c-format
msgid "%s: unrecognized option `%c%s'\n"
msgstr "%s: opción no reconocida `%c%s'\n"

#: lib/getopt.c:796 lib/getopt.c:799
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opción ilegal -- %c\n"

#: lib/getopt.c:805 lib/getopt.c:808
#, c-format
msgid "%s: invalid option -- %c\n"
msgstr "%s: opción inválida -- %c\n"

#: lib/getopt.c:863 lib/getopt.c:882 lib/getopt.c:1095 lib/getopt.c:1116
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: la opción requiere un argumento -- %c\n"

#: lib/getopt.c:935 lib/getopt.c:954
#, c-format
msgid "%s: option `-W %s' is ambiguous\n"
msgstr "%s: la opción `-W %s' es ambigua\n"

#: lib/getopt.c:978 lib/getopt.c:999
#, c-format
msgid "%s: option `-W %s' doesn't allow an argument\n"
msgstr "%s: la opción `-W %s' no admite ningún argumento\n"

#: lib/human.c:484
msgid "block size"
msgstr "tamaño del bloque"

#: lib/quotearg.c:240
msgid "`"
msgstr "`"

#: lib/quotearg.c:241
msgid "'"
msgstr "'"

#: lib/rtapelib.c:297
msgid "exec/tcp: Service not available"
msgstr "exec/tcp: Servicio no disponible"

#: lib/rtapelib.c:301
msgid "stdin"
msgstr "entrada estándar (stdin)"

#: lib/rtapelib.c:304
msgid "stdout"
msgstr "salida estándar (stdout)"

#: lib/rtapelib.c:512
msgid "Cannot execute remote shell"
msgstr "No se puede ejecutar un shell remoto"

#: lib/argp-help.c:194
#, c-format
msgid "%.*s: ARGP_HELP_FMT parameter requires a value"
msgstr ""

#: lib/argp-help.c:203
#, c-format
msgid "%.*s: Unknown ARGP_HELP_FMT parameter"
msgstr ""

#: lib/argp-help.c:215
#, c-format
msgid "Garbage in ARGP_HELP_FMT: %s"
msgstr ""

#: lib/argp-help.c:1188
msgid ""
"Mandatory or optional arguments to long options are also mandatory or "
"optional for any corresponding short options."
msgstr ""

#: lib/argp-help.c:1575
msgid "Usage:"
msgstr ""

#: lib/argp-help.c:1579
msgid "  or: "
msgstr ""

#: lib/argp-help.c:1591
#, fuzzy
msgid " [OPTION...]"
msgstr ""
"\n"
"Modo de empleo: %s [OPCIÓN]...\n"

#: lib/argp-help.c:1618
#, fuzzy, c-format
msgid "Try `%s --help' or `%s --usage' for more information.\n"
msgstr "Pruebe `%s --help' para más información.\n"

# Por favor, no me digáis cómo se traduce bug.
# Gerardo lo ha visto traducido en un libro como "pulgas", y yo
# lo he visto como "chinche" en la "Investigación y Ciencia".
# Está claro que así no vamos a ninguna parte.
# Yo diría simplemente `fallos [ocultos]'. Es lo que significa, en realidad,
# en el contexto informático, razones históricas aparte de bichos anidando
# al calorcito de los tubos de vacío de los primeros computadores. gerardo
# De "ocultos" nada... Este vamos a dejarlo, ¿vale? sv
# Tú mandas, pero ¿cómo que de ocultos nada? Si no fueran ocultos, el progra-
# ma no vería la luz aún, ¿no? Pero observa que he puesto el `ocultos' entre
# corchetes. Yo pondría "bug -> fallo" simplemente. Comunicar fallos a... gerardo
# ¿Que no vería la luz si no fueran ocultos? Ja, ja, ja, ja...
# Mira por ejemplo en http://nl.debian.org/Bugs.
# ¿No tendría sentido catalogarlos entonces?
#
# Véase "A Bug's life".
#: lib/argp-help.c:1646 src/tar.c:1252
#, fuzzy, c-format
msgid "Report bugs to %s.\n"
msgstr ""
"\n"
"Comunicar bichos a <bug-tar@gnu.org>.\n"

#: rmt/rmt.c:144
msgid "rmtd: Cannot allocate buffer space\n"
msgstr "rmtd: No se puede asignar espacio para el búfer\n"

#: rmt/rmt.c:146
msgid "Cannot allocate buffer space"
msgstr "No se puede asignar espacio para el búfer"

#: rmt/rmt.c:256
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "Pruebe `%s --help' para más información.\n"

#: rmt/rmt.c:260
#, c-format
msgid ""
"Usage: %s [OPTION]\n"
"Manipulate a tape drive, accepting commands from a remote process.\n"
"\n"
"  --version  Output version info.\n"
"  --help  Output this help.\n"
msgstr ""
"Modo de empleo: %s [OPCIÓN]\n"
"Manipula una unidad de cinta, aceptando órdenes de un proceso remoto.\n"
"\n"
"  --version  Muestra la versión.\n"
"  --help     Muestra esta ayuda.\n"

# Por favor, no me digáis cómo se traduce bug.
# Gerardo lo ha visto traducido en un libro como "pulgas", y yo
# lo he visto como "chinche" en la "Investigación y Ciencia".
# Está claro que así no vamos a ninguna parte.
# Yo diría simplemente `fallos [ocultos]'. Es lo que significa, en realidad,
# en el contexto informático, razones históricas aparte de bichos anidando
# al calorcito de los tubos de vacío de los primeros computadores. gerardo
# De "ocultos" nada... Este vamos a dejarlo, ¿vale? sv
# Tú mandas, pero ¿cómo que de ocultos nada? Si no fueran ocultos, el progra-
# ma no vería la luz aún, ¿no? Pero observa que he puesto el `ocultos' entre
# corchetes. Yo pondría "bug -> fallo" simplemente. Comunicar fallos a... gerardo
# ¿Que no vería la luz si no fueran ocultos? Ja, ja, ja, ja...
# Mira por ejemplo en http://nl.debian.org/Bugs.
# ¿No tendría sentido catalogarlos entonces?
#
# Véase "A Bug's life".
#: rmt/rmt.c:267
#, fuzzy, c-format
msgid ""
"\n"
"Report bugs to <%s>.\n"
msgstr ""
"\n"
"Comunicar bichos a <bug-tar@gnu.org>.\n"

#: rmt/rmt.c:301
msgid ""
"This program comes with NO WARRANTY, to the extent permitted by law.\n"
"You may redistribute it under the terms of the GNU General Public License;\n"
"see the file named COPYING for details."
msgstr ""
"Este programa viene sin NINGUNA GARANTÍA, hasta donde permite la ley.\n"
"Puede redistribuirse bajo los términos de la Licencia Pública General de "
"GNU;\n"
"vea el fichero llamado COPYING para más información."

#: rmt/rmt.c:400 rmt/rmt.c:520 rmt/rmt.c:530
msgid "Seek offset out of range"
msgstr "Desplazamiento fuera de rango"

#: rmt/rmt.c:413
msgid "Seek direction out of range"
msgstr "Dirección de desplazamiento fuera de rango"

# FIXME. Este es el único eof en minúsculas.
# # Como has puesto más arriba: "EOF"->"Fin de fichero". jmg
#: rmt/rmt.c:452
msgid "rmtd: Premature eof\n"
msgstr "rmtd: EOF prematuro\n"

#: rmt/rmt.c:454
msgid "Premature end of file"
msgstr "Fin de fichero prematuro"

# "no reconocida" me parecía muy suave para "garbage". sv
# OJO: Casi el mismo mensaje.
#: rmt/rmt.c:562
#, c-format
msgid "rmtd: Garbage command %c\n"
msgstr "rmtd: Orden ininteligible %c\n"

#: rmt/rmt.c:564
msgid "Garbage command"
msgstr "Orden ininteligible"

# ¿No es mejor "Total de bytes escritos: "?
# Suena más directo y más similar al original,
# "bytes escritos en total" suena demasiado complejo... Nicolás Lichtmaier.
# Suena algo extraño eso de "total de bytes". "en total" me suena
# mucho más natural. sv
#: src/buffer.c:263
#, fuzzy, c-format
msgid "Total bytes written: %s (%s, %s/s)\n"
msgstr "Bytes escritos en total: %s (%sB, %sB/s)\n"

#: src/buffer.c:340
msgid "(pipe)"
msgstr "(tubería)"

# ¿No queda más bonita la 1ª comilla abierta así: `record_size'?
# Sí. FIXME. Comunicar al autor. sv
#: src/buffer.c:388
msgid "Invalid value for record_size"
msgstr "El valor de `record_size' no es válido"

#: src/buffer.c:391
msgid "No archive name given"
msgstr "No se ha especificado ningún nombre de archivo"

# FIXME: Si la entrada/salida estándar no es un archivo, ¿por qué el
# original se refiere a ella como tal?
#
# En cierto sentido, sí es un archivo, o se puede emplear como tal.
# Tar al menos la trata así, en `tar -f -' (o sin la opción -f en este
# GNU tar)'; luego la E/S std. puede ser un archivo "real" de disco:
# tar ... -f - > arch.tar       gerardo
#
# Esto corresponde a la opción --verify.
# Ejemplos: "tar cWf - ." y "tar xWf -"
# o sea que una traducción correcta se vería más como:
# "No se puede verificar un archivo desde/hacia la entrada/salida estándar"
# o algo así. Quizá "No se puede verificar un archivo tomado de la entrada
# estándar o escrito hacia la salida estándar", pero es un poco largo.. =)
#
#: src/buffer.c:441
msgid "Cannot verify stdin/stdout archive"
msgstr "No se puede verificar la entrada/salida estándar"

#: src/buffer.c:454
#, c-format
msgid "Archive is compressed. Use %s option"
msgstr ""

# Ojo que esto podría referirse a "is not being labelled NOW" en vez de
# "isn't labelled". Pero no tengo los fuentes para ver la intención
# original. nl
# Si no se sabe eso, se podría dejar de forma más neutra como
# "Archivo no etiquetado para concordancia con `%s'" - gerardo (gag)
# FIXME: Preguntar.
#: src/buffer.c:526
#, c-format
msgid "Archive not labeled to match %s"
msgstr "El archivo no está etiquetado para que coincida con %s"

#: src/buffer.c:529 src/buffer.c:896
#, c-format
msgid "Volume %s does not match %s"
msgstr "El volumen %s no coincide con %s"

#: src/buffer.c:567
#, c-format
msgid "Write checkpoint %d"
msgstr "Punto de comprobación de escritura %d"

#: src/buffer.c:654
#, c-format
msgid "%s: file name too long to be stored in a GNU multivolume header"
msgstr ""

#: src/buffer.c:733
msgid "At beginning of tape, quitting now"
msgstr "Al principio de la cinta, se terminará ahora"

#: src/buffer.c:739
msgid "Too many errors, quitting"
msgstr "Demasiados errores, abandono"

#: src/buffer.c:765
#, fuzzy, c-format
msgid "Read %s bytes from %s"
msgstr "Se renombra %s como %s"

#: src/buffer.c:777
#, fuzzy, c-format
msgid "Unaligned block (%lu byte) in archive"
msgid_plural "Unaligned block (%lu bytes) in archive"
msgstr[0] "Bloque no alineado (%lu bytes) dentro del archivo"
msgstr[1] "Bloque no alineado (%lu bytes) dentro del archivo"

#: src/buffer.c:797
#, fuzzy, c-format
msgid "Record size = %lu block"
msgid_plural "Record size = %lu blocks"
msgstr[0] "Tamaño del registro = %lu bloques"
msgstr[1] "Tamaño del registro = %lu bloques"

#: src/buffer.c:814
#, c-format
msgid "Read checkpoint %d"
msgstr "Punto de comprobación de lectura %d"

#: src/buffer.c:905 src/extract.c:1100
#, c-format
msgid "Reading %s\n"
msgstr "Leyendo %s\n"

#: src/buffer.c:909
msgid "WARNING: No volume header"
msgstr "ATENCIÓN: No hay cabecera de volumen"

#: src/buffer.c:917
#, c-format
msgid "%s is not continued on this volume"
msgstr "%s no continúa en este volumen"

#: src/buffer.c:931
#, c-format
msgid "%s is the wrong size (%s != %s + %s)"
msgstr "%s tiene un tamaño erróneo (%s != %s + %s)"

# Sugerencia: está fuera de secuencia -> no está en orden. sv
# Creo recordar que en el CPBackup de Central Point ponía lo de "fuera de
# secuencia". fr
# Buena referencia :-).
# El comentario habrá que conservarlo en la versión final. sv
# Bueno, la verdad es que ahora que lo pienso, me parece una mala
# traducción... ¿opiniones? sv
# Me parece correcta la traducción "literal", pero me gusta
# más tu sugerencia  - gerardo
# El problema es que un volumen individual no puede estar desordenado.
# Lo que está ordenado o no es la sucesión entera.
# Un volumen individual puede estar fuera de lugar, pero no desordenado
# él solito.
# Todavía espero una solución mágica que sea mejor que las dos
# que tenemos hasta ahora.
#: src/buffer.c:943
msgid "This volume is out of sequence"
msgstr "Este volumen está fuera de secuencia"

#: src/buffer.c:1025
msgid "Cannot backspace archive file; it may be unreadable without -i"
msgstr "No se puede ir hacia atrás en el archivo; puede ser ilegible sin -i"

#: src/buffer.c:1057
msgid "rmtlseek not stopped at a record boundary"
msgstr ""

#: src/buffer.c:1108
#, c-format
msgid "%s: contains invalid volume number"
msgstr "%s: contiene un número de volumen inválido"

#: src/buffer.c:1160
msgid "Volume number overflow"
msgstr "Desbordamiento en el número de volumen"

#: src/buffer.c:1179
#, c-format
msgid "`%s' command failed"
msgstr "La orden `%s' falló"

#: src/buffer.c:1188
#, c-format
msgid "Prepare volume #%d for %s and hit return: "
msgstr "Prepare el volumen #%d para %s y pulse intro: "

#: src/buffer.c:1194
msgid "EOF where user reply was expected"
msgstr ""
"Se encontró un final de fichero mientras se esperaba respuesta del usuario"

#: src/buffer.c:1199 src/buffer.c:1229
msgid "WARNING: Archive is incomplete"
msgstr "ATENCIÓN: El archivo está incompleto"

# Antes de que nadie diga nada:
# shell admite muchas traducciones, caparazón, concha, envoltorio, coraza,
# etc. pero ninguna ha prosperado. Además, algunos nombres son innombrables
# en ciertos países, así que mejor dejarlo como está.
# Y si no se traduce, se queda en *el* shell, es decir, *neutro*.
#
# Ya que volúmenes se acentúa, ¿habría que poner "volumen/volúmenes"
# en lugar de "volumen(es)"?
# No me gusta, ya que sólo es plural con la parte entre paréntesis "(y consecutivos)". fr
# Creo que esta bien así Gerardo. em+
# # Cuidadín. ¿El nombre de archivo se le da *al* volumen? Literalmente
# # dice que da un nuevo nombre *para* el sgute. volumen, pero ¿ese
# # nombre es el del volumen? No entiendo bien el contexto; quizá
# # habría que mirar el código fuente o ver cuándo sale este
# # mensaje.
# # Otra cosa es eso de "abortar". No sé si se habrá tratado en
# # spanglish o en es@li.org, pero suena muy feo, ¿no? Quizá "Sale
# # inmediatamente de tar".
#
# "Print this list" es exactamente "Imprime esta lista" o a lo sumo "Muestra
# esta lista". No veo que diga ayuda en ninguna parte, no creo que un
# traductor deba ser más inteligente que el escritor original.. =) nl
# Yo creo que a veces sí :-) sv
# Sí, un programador no tiene por qué ser buen escritor :-) En un fortune me
# salió una vez: "Los que no saben escribir, escriben manuales". :-)
# A mí aquí me da igual lista que ayuda, de las dos formas se entiende. Manda
# el traductor original. gerardo
# ¿A alguien más le parece mal que ponga ayuda en vez de lista? sv
#: src/buffer.c:1213
#, c-format
msgid ""
" n [name]   Give a new file name for the next (and subsequent) volume(s)\n"
" q          Abort tar\n"
" !          Spawn a subshell\n"
" ?          Print this list\n"
msgstr ""
" n [nombre] Da un nuevo nombre de archivo al siguiente\n"
"            (y consecutivos) volumen(es)\n"
" q          Aborta tar\n"
" !          Lanza un subshell\n"
" ?          Muestra esta ayuda\n"

# "saliendo"->"finalizando". jmg
# Je, je, ¿no has leído, Santiago, el `dardo' de Fdo. Lázaro Carreter sobre
# finalizar? No sé por qué quitar lo de salir, to exit es salir, no acabar.
# Uno se sale del programa, y éste acaba. En realidad, también da igual, de
# cualquier forma se entiende, pero mejor acabar o terminar que finalizar,
# total, son sinónimos. gerardo
#: src/buffer.c:1224
msgid "No new volume; exiting.\n"
msgstr "No hay volumen nuevo; finalizando.\n"

#: src/compare.c:105
#, fuzzy, c-format
msgid "Could only read %lu of %lu byte"
msgid_plural "Could only read %lu of %lu bytes"
msgstr[0] "Sólo se pudieron leer %lu de %lu bytes"
msgstr[1] "Sólo se pudieron leer %lu de %lu bytes"

#: src/compare.c:116 src/compare.c:132
msgid "Contents differ"
msgstr "El contenido es distinto"

# # Como has puesto más arriba: "EOF"->"Fin de fichero". jmg
#: src/compare.c:158 src/extract.c:763 src/incremen.c:496 src/list.c:235
#: src/list.c:412 src/list.c:1282
msgid "Unexpected EOF in archive"
msgstr "EOF inesperado en el archivo"

# "Verifica ". Supongo que depende de si se concatena en algún
# mensaje. jmg
# FUZZY. Es verdad, habrá que verlo.
#: src/compare.c:212
#, c-format
msgid "Verify "
msgstr "Verificar "

# # ¿Quizá diffed es el participio de diff, siendo esto un verbo tomado
# # del nombre del programa diff? Entonces querría decir que se ha
# # efectuado un diff como si el *fichero* hubiera sido normal. Yo sólo
# # cambiaría "se toma" por "se ha tomado". gag
# Es norma habitual convertir un pasado en un presente en estos casos.
# Realmente, dice lo que hace y no lo que ha hecho. sv
# FIXME. Decirle al autor que estandarice las comillas: ¿'%c' o `%c'?
# De momento lo estandarizo en la traducción.
#: src/compare.c:219
#, c-format
msgid "%s: Unknown file type '%c', diffed as normal file"
msgstr ""
"%s: Tipo de fichero `%c' desconocido, se toma la diferencia\n"
"como fichero normal"

#: src/compare.c:242 src/compare.c:364 src/compare.c:416 src/compare.c:443
msgid "File type differs"
msgstr "El tipo de fichero es distinto"

# El autor quería un mensaje muy conciso, y en la traducción se expande a una
# oración completa.. ¿Por qué? Debería ser "Distinto modo".
# Porque el idioma inglés es más corto. Si a cada frase corta le hago
# corresponder siempre una frase corta española, el resultado sonará a indio
# completamente (me refiero a los indios esos de las películas del oeste,
# que solamente hablan con sustantivos, verbos y adjetivos). sv
#: src/compare.c:249 src/compare.c:378 src/compare.c:422
msgid "Mode differs"
msgstr "El modo es distinto"

#: src/compare.c:252
msgid "Uid differs"
msgstr "El uid es distinto"

#: src/compare.c:254
msgid "Gid differs"
msgstr "El gid es distinto"

#: src/compare.c:257
msgid "Mod time differs"
msgstr "La fecha de modificación es distinta"

#: src/compare.c:261 src/compare.c:451
msgid "Size differs"
msgstr "El tamaño es distinto"

# Creo que este enlace se efectúa al descomprimir un archivo tar.
# No es que nos diga si está enlazado o no lo está, sino si él hace
# el enlace o no lo hace. sv
#: src/compare.c:319
#, c-format
msgid "Not linked to %s"
msgstr "No se enlaza a %s"

#: src/compare.c:342
msgid "Symlink differs"
msgstr "El enlace simbólico es distinto"

#: src/compare.c:372
msgid "Device number differs"
msgstr "El número de dispositivo es distinto"

#: src/compare.c:500
msgid "Archive contains file names with leading prefixes removed."
msgstr ""

#: src/compare.c:502
msgid "Verification may fail to locate original files."
msgstr ""

#: src/compare.c:572
#, fuzzy, c-format
msgid "VERIFY FAILURE: %d invalid header detected"
msgid_plural "VERIFY FAILURE: %d invalid headers detected"
msgstr[0] "FALLO DE VERIFICACIÓN: %d cabecera(s) inválida(s) detectada(s)"
msgstr[1] "FALLO DE VERIFICACIÓN: %d cabecera(s) inválida(s) detectada(s)"

#: src/create.c:145
msgid "Generating negative octal headers"
msgstr "Generando cabeceras octales negativas"

#: src/create.c:196
#, c-format
msgid "value %s out of %s range %s..%s; substituting %s"
msgstr "valor %s fuera del rango %s %s..%s; se sustituye %s"

#: src/create.c:202
#, c-format
msgid "value %s out of %s range %s..%s"
msgstr "valor %s fuera del rango %s %s..%s"

#: src/create.c:481 src/create.c:544
#, fuzzy, c-format
msgid "%s: file name is too long (max %d); not dumped"
msgstr "%s: el fichero no ha cambiado; no se vuelca"

#: src/create.c:491
#, fuzzy, c-format
msgid "%s: file name is too long (cannot be split); not dumped"
msgstr "%s: el fichero no ha cambiado; no se vuelca"

#: src/create.c:518
#, fuzzy, c-format
msgid "%s: link name is too long; not dumped"
msgstr "%s: el fichero no ha cambiado; no se vuelca"

# "se rellena" debería ser "rellenando". "se rellena" puede entenderse como
# varias cosas, no queda claro que es lo que se esta haciendo, podría indicar
# lo que se suele hacer.. =)   "rellenando con ceros" es perfecto y es
# exactamente lo que está escrito en el original. sv
#
# Que sí, reconozco que la traducción es un poco libre.
# Pero mi intención es que el programa diga lo que va haciendo, no lo que ya
# ha hecho. Ni siquiera el original es consistente en los modos verbales. sv
#: src/create.c:884
#, fuzzy, c-format
msgid "%s: File shrank by %s byte; padding with zeros"
msgid_plural "%s: File shrank by %s bytes; padding with zeros"
msgstr[0] ""
"%s: El tamaño del fichero ha disminuido en %s bytes, se rellena con ceros"
msgstr[1] ""
"%s: El tamaño del fichero ha disminuido en %s bytes, se rellena con ceros"

#: src/create.c:910
#, c-format
msgid "%s: file changed as we read it"
msgstr "%s: el fichero cambió mientras se estaba leyendo"

#: src/create.c:1051
#, c-format
msgid "%s: file is on a different filesystem; not dumped"
msgstr "%s: el fichero está en un sistema de ficheros distinto; no se vuelca"

# FIXME: Decir al autor que ponga el "itself". sv
#: src/create.c:1061
#, fuzzy, c-format
msgid "%s: contains a cache directory tag; not dumped"
msgstr "%s: el fichero es el propio archivo; no se vuelca"

#: src/create.c:1221
#, c-format
msgid "%s: Unknown file type; file ignored"
msgstr "%s: Tipo de fichero desconocido; no se tendrá en cuenta"

#: src/create.c:1320
#, fuzzy, c-format
msgid "Missing links to '%s'.\n"
msgstr " enlace a %s\n"

#: src/create.c:1387
#, c-format
msgid "%s: file is unchanged; not dumped"
msgstr "%s: el fichero no ha cambiado; no se vuelca"

# FIXME: Decir al autor que ponga el "itself". sv
#: src/create.c:1395
#, c-format
msgid "%s: file is the archive; not dumped"
msgstr "%s: el fichero es el propio archivo; no se vuelca"

#: src/create.c:1430
#, c-format
msgid "%s: File removed before we read it"
msgstr "%s: El fichero fue borrado antes de leerlo"

#: src/create.c:1523
#, c-format
msgid "%s: socket ignored"
msgstr "%s: el `socket' no se tendrá en cuenta"

#: src/create.c:1528
#, c-format
msgid "%s: door ignored"
msgstr "%s: no se tendrá en cuenta la puerta"

#: src/delete.c:209 src/list.c:171 src/update.c:163
msgid "This does not look like a tar archive"
msgstr "Esto no parece un archivo tar"

#: src/delete.c:215 src/list.c:185 src/update.c:168
msgid "Skipping to next header"
msgstr "Saltando a la siguiente cabecera"

#: src/delete.c:280
msgid "Deleting non-header from archive"
msgstr "Borrando no-cabecera del archivo"

#: src/extract.c:208
#, fuzzy, c-format
msgid "%s: implausibly old time stamp %s"
msgstr "%s: no se tendrá en cuenta la marca de fecha `%s' inválida"

#: src/extract.c:211
#, c-format
msgid "%s: time stamp %s is %lu s in the future"
msgstr "%s: la marca de tiempo %s está %lu s en el futuro"

#: src/extract.c:359
#, c-format
msgid "%s: Unexpected inconsistency when making directory"
msgstr "%s: Inconsistencia inesperada al crear el directorio"

#: src/extract.c:478
#, c-format
msgid "Current `%s' is newer"
msgstr ""

#: src/extract.c:590
#, c-format
msgid "%s: Directory renamed before its status could be extracted"
msgstr ""
"%s: El directorio fue renombrado antes de que se pudiera extraer su estado"

#: src/extract.c:655
#, c-format
msgid "%s: Was unable to backup this file"
msgstr "%s: No se pudo hacer copia de seguridad de este fichero"

#: src/extract.c:722
msgid "Extracting contiguous files as regular files"
msgstr "Extrayendo ficheros contiguos como ficheros regulares"

# ¿Enlaces fuertes? Aquí los profes. de Sistemas Operativos y otros
# dicen "enlaces duros", y creo que los libros también lo ponen así. gag
# Es una cuestión todavía no dirimida.
# ¿Tienes algún dato más? ¿Qué dicen los libros? sv
# Enlaces duros. Lo acabo de mirar en un libro. gag
#: src/extract.c:908
msgid "Attempting extraction of symbolic links as hard links"
msgstr "Intentando la extracción de enlaces simbólicos como enlaces duros"

#: src/extract.c:1109
#, c-format
msgid "%s: Cannot extract -- file is continued from another volume"
msgstr "%s: No se puede extraer -- el fichero es continuación de otro volumen"

# Me queda la duda de si lo que es visible es el error o el nombre largo... sv
#: src/extract.c:1118
msgid "Visible long name error"
msgstr "Error de nombre largo visible"

# FIXME. Lo de las comillas '%c'.
# Como antes, lo estandarizo en la traducción a pesar de todo.
#: src/extract.c:1126
#, c-format
msgid "%s: Unknown file type '%c', extracted as normal file"
msgstr "%s: Tipo de fichero `%c' desconocido, se extrae como fichero normal"

#: src/extract.c:1211
msgid "Error is not recoverable: exiting now"
msgstr "El error no es recuperable: salida ahora"

#: src/extract.c:1218
msgid "memory exhausted"
msgstr "memoria agotada"

#: src/incremen.c:193
#, c-format
msgid "%s: Directory has been renamed"
msgstr "%s: El directorio ha sido renombrado"

#: src/incremen.c:205
#, c-format
msgid "%s: Directory is new"
msgstr "%s: El directorio es nuevo"

#: src/incremen.c:354
msgid "Invalid time stamp"
msgstr "Marca de tiempo inválida"

#: src/incremen.c:357
msgid "Time stamp out of range"
msgstr "Marca de tiempo fuera de rango"

#: src/incremen.c:381
msgid "Invalid device number"
msgstr "Número de dispositivo inválido"

#: src/incremen.c:385
msgid "Device number out of range"
msgstr "Número de dispositivo fuera de rango"

#: src/incremen.c:393
msgid "Invalid inode number"
msgstr "Número de nodo-i inválido"

#: src/incremen.c:397
msgid "Inode number out of range"
msgstr "Número de nodo-i fuera de rango"

#: src/incremen.c:524
#, c-format
msgid "%s: Not purging directory: unable to stat"
msgstr ""

#: src/incremen.c:531
#, fuzzy, c-format
msgid "%s: directory is on a different device: not purging"
msgstr "%s: el fichero está en un sistema de ficheros distinto; no se vuelca"

#: src/incremen.c:539
#, c-format
msgid "%s: Deleting %s\n"
msgstr "%s: Borrando %s\n"

#: src/incremen.c:544
#, c-format
msgid "%s: Cannot remove"
msgstr "%s: No se puede borrar"

#: src/list.c:117
#, c-format
msgid "%s: Omitting"
msgstr "%s: Se omite"

#: src/list.c:135
#, c-format
msgid "block %s: ** Block of NULs **\n"
msgstr "bloque %s: ** Bloque de NULos **\n"

#: src/list.c:148
#, c-format
msgid "A lone zero block at %s"
msgstr ""

#: src/list.c:159
#, c-format
msgid "block %s: ** End of File **\n"
msgstr "bloque %s: ** Fin de Fichero **\n"

#: src/list.c:182 src/list.c:1017 src/list.c:1244
#, c-format
msgid "block %s: "
msgstr "bloque %s: "

#: src/list.c:644
#, c-format
msgid "Blanks in header where numeric %s value expected"
msgstr "Hay blancos en la cabecera cuando se esperaba el valor numérico %s"

#: src/list.c:698
#, c-format
msgid "Archive octal value %.*s is out of %s range; assuming two's complement"
msgstr ""
"El valor octal %.*s del archivo está fuera del rango %s;\n"
"se supone complemento a dos"

#: src/list.c:708
#, c-format
msgid "Archive octal value %.*s is out of %s range"
msgstr "El valor octal %.*s del archivo está fuera del rango %s"

#: src/list.c:725
msgid "Archive contains obsolescent base-64 headers"
msgstr "El archivo contiene cabeceras base 64 obsoletas"

#: src/list.c:738
#, c-format
msgid "Archive signed base-64 string %s is out of %s range"
msgstr "La cadena firmada en base 64 %s del archivo está fuera del rango %s"

#: src/list.c:769
#, c-format
msgid "Archive base-256 value is out of %s range"
msgstr "El valor en base 256 del archivo está fuera del rango %s"

#: src/list.c:797
#, c-format
msgid "Archive contains %.*s where numeric %s value expected"
msgstr "El archivo contiene %.*s donde se esperaba el valor numérico %s"

#: src/list.c:818
#, fuzzy, c-format
msgid "Archive value %s is out of %s range %s.%s"
msgstr "El valor del archivo %s está fuera del rango %s %s..%s"

# FIXME. Hay otro que se parece muchísimo. sv
#: src/list.c:1048
msgid "Visible longname error"
msgstr "Error de nombre largo visible"

#: src/list.c:1175
#, c-format
msgid " link to %s\n"
msgstr " enlace a %s\n"

#: src/list.c:1183
#, c-format
msgid " unknown file type %s\n"
msgstr " tipo de fichero desconocido %s\n"

#: src/list.c:1201
#, c-format
msgid "--Long Link--\n"
msgstr ""

#: src/list.c:1205
#, c-format
msgid "--Long Name--\n"
msgstr ""

#: src/list.c:1209
#, c-format
msgid "--Volume Header--\n"
msgstr "--Cabecera de Volumen--\n"

#: src/list.c:1217
#, c-format
msgid "--Continued at byte %s--\n"
msgstr "--Continúa en el byte %s--\n"

#: src/list.c:1221
#, c-format
msgid "--Mangled file names--\n"
msgstr "--Nombres de fichero modificados--\n"

#: src/list.c:1249
msgid "Creating directory:"
msgstr "Creando el directorio:"

# Como has puesto más arriba: "EOF"->"Fin de fichero".
# "Fin de fichero inesperado en los nombres modificados.".
# ¿No se referirá al autor a "mangled filenames"?... jmg
# FIXME. Preguntárselo.
#: src/mangle.c:54
msgid "Unexpected EOF in mangled names"
msgstr "EOF inesperado en los nombres modificados"

#: src/mangle.c:90 src/misc.c:399 src/misc.c:417
#, c-format
msgid "%s: Cannot rename to %s"
msgstr "%s: No se puede renombrar a %s"

#: src/mangle.c:93
#, c-format
msgid "Renamed %s to %s"
msgstr "Se renombra %s como %s"

#: src/mangle.c:110
#, c-format
msgid "%s: Cannot symlink to %s"
msgstr "%s: No se puede crear un enlace simbólico a %s"

#: src/mangle.c:113
#, c-format
msgid "Symlinked %s to %s"
msgstr "Se enlaza %s simbólicamente a %s"

# ¿desmutilador? sv. (Perdona mi ignorancia: ¿qué significa?)
# No lo sé, tengo que consultar. Lo encontré en un diccionario raro. fr
# Bueno, yo tampoco sé lo que es, pero "mangling" me suena a:
# "proceso mediante el cual se codifican ciertos nombres de cierta manera."
# Por ejemplo, "name mangling" es lo que hace Linux cuando se instala
# con umsdos. (¿Lo has visto alguna vez?).
# También se habla de "mangling" a la forma que tiene el C++ de incluir
# los nombres de las funciones (o de las clases quizá) en un archivo
# objeto ( .o ).
# Bueno, en realidad no lo sé, pero espero haberte dado alguna idea.
# A ver qué dice Enrique u otro revisor. sv
# Sigo en blanco. fr
# La traducción mas acertada creo que es esta :) , el uso que conozco
# de mangled esta relacionado con codificar o transformar el nombre de una
# función C++ dentro de una biblioteca, de manera que se pueda deshacer la
# referencia a la función al compilar o enlazar dinámicamente, obteniendo
# la función que corresponde al aplicar la sobrecarga de operadores. em+
# # Todo eso es así, lo malo es encontrar la palabra simple más
# # adecuada y  mantenerla. Por ejemplo, antes hemos dicho "mutilar", en
# # otros mensajes; y ahora "desenredar".
#: src/mangle.c:117
#, c-format
msgid "Unknown demangling command %s"
msgstr "Orden desconocida para recuperar el nombre original de %s"

#: src/misc.c:390
#, c-format
msgid "Renaming %s to %s\n"
msgstr "Se renombra %s como %s\n"

#: src/misc.c:422
#, c-format
msgid "Renaming %s back to %s\n"
msgstr "Se vuelve a renombrar %s como %s\n"

#: src/misc.c:502
msgid "Cannot save working directory"
msgstr "No se puede guardar el directorio de trabajo"

#: src/misc.c:508
msgid "Cannot change working directory"
msgstr "No se puede cambiar el directorio de trabajo"

# FIXME: Intraducible.
#: src/misc.c:552 src/misc.c:561
#, c-format
msgid "%s: Cannot %s"
msgstr "%s: No se puede %s"

#: src/misc.c:570
#, c-format
msgid "%s: Warning: Cannot %s"
msgstr "%s: Atención: No se puede %s"

#: src/misc.c:585
#, c-format
msgid "%s: Cannot change mode to %s"
msgstr "%s: No se puede cambiar el modo a %s"

#: src/misc.c:593
#, c-format
msgid "%s: Cannot change ownership to uid %lu, gid %lu"
msgstr "%s: No se puede cambiar el propietario a uid %lu, gid %lu"

#: src/misc.c:628
#, c-format
msgid "%s: Cannot hard link to %s"
msgstr "%s: No se puede crear un enlace duro a %s"

#: src/misc.c:689 src/misc.c:730
#, fuzzy, c-format
msgid "%s: Read error at byte %s, reading %lu byte"
msgid_plural "%s: Read error at byte %s, reading %lu bytes"
msgstr[0] "%s: Error de lectura en el byte %s, leyendo %lu bytes"
msgstr[1] "%s: Error de lectura en el byte %s, leyendo %lu bytes"

#: src/misc.c:702
#, fuzzy, c-format
msgid "%s: Warning: Read error at byte %s, reading %lu byte"
msgid_plural "%s: Warning: Read error at byte %s, reading %lu bytes"
msgstr[0] "%s: Atención: Error de lectura en el byte %s, leyendo %lu bytes"
msgstr[1] "%s: Atención: Error de lectura en el byte %s, leyendo %lu bytes"

#: src/misc.c:790
#, c-format
msgid "%s: Cannot seek to %s"
msgstr "%s: No se puede desplazar a %s"

#: src/misc.c:806
#, c-format
msgid "%s: Warning: Cannot seek to %s"
msgstr "%s: Atención: No se puede desplazar a %s"

#: src/misc.c:824
#, c-format
msgid "%s: Cannot create symlink to %s"
msgstr "%s: No se puede crear el enlace simbólico a %s"

#: src/misc.c:892
#, fuzzy, c-format
msgid "%s: Wrote only %lu of %lu byte"
msgid_plural "%s: Wrote only %lu of %lu bytes"
msgstr[0] "%s: Sólo se escribieron %lu de %lu bytes"
msgstr[1] "%s: Sólo se escribieron %lu de %lu bytes"

#: src/misc.c:918
msgid "child process"
msgstr "proceso hijo"

#: src/misc.c:927
msgid "interprocess channel"
msgstr "canal de interproceso"

#: src/names.c:372 src/names.c:421 src/names.c:465
msgid "Missing file name after -C"
msgstr "Falta el nombre del fichero después de -C"

#: src/names.c:642 src/names.c:658
#, c-format
msgid "%s: Not found in archive"
msgstr "%s: No se encuentra en el archivo"

#: src/names.c:645
#, fuzzy, c-format
msgid "%s: Required occurrence not found in archive"
msgstr "%s: No se encuentra en el archivo"

# FIXME. This might not always work. Is `%.*s' male or female? sv
#: src/names.c:1093
#, fuzzy, c-format
msgid "Removing leading `%s' from member names"
msgstr "Eliminando la `%.*s' inicial de los nombres"

#: src/names.c:1094
#, fuzzy, c-format
msgid "Removing leading `%s' from hard link targets"
msgstr "Eliminando la `/' inicial de los nombres de los enlaces"

# FIXME. This might not always work. Is `%.*s' male or female? sv
#: src/names.c:1107
#, fuzzy
msgid "Substituting `.' for empty member name"
msgstr "Eliminando la `%.*s' inicial de los nombres"

#: src/names.c:1108
msgid "Substituting `.' for empty hard link target"
msgstr ""

#: src/tar.c:71
#, c-format
msgid "Options `-%s' and `-%s' both want standard input"
msgstr "Las opciones `-%s' y `-%s' requieren entrada estándar"

#: src/tar.c:143
#, fuzzy, c-format
msgid "%s: Invalid archive format"
msgstr "Formato de fecha inválido `%s'"

#: src/tar.c:167
msgid "GNU features wanted on incompatible archive format"
msgstr "Se requieren características de GNU en formato de archivo incompatible"

# # la versión de control -> el control de versión
# # nil: numeradas... simples... (en plural)
# # never, simPle (falta una pe): backup -> copia de seguridad. gag
# Estoy de acuerdo con lo de gag (más arriba usas eso mismo). jmg
#: src/tar.c:241
#, fuzzy
msgid ""
"GNU `tar' saves many files together into a single tape or disk archive, and "
"can restore individual files from the archive.\n"
"\n"
"Examples:\n"
"  tar -cf archive.tar foo bar  # Create archive.tar from files foo and bar.\n"
"  tar -tvf archive.tar         # List all files in archive.tar verbosely.\n"
"  tar -xf archive.tar          # Extract all files from archive.tar.\n"
"The backup suffix is `~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control may be set with --backup or VERSION_CONTROL, values "
"are:\n"
"\n"
"  t, numbered     make numbered backups\n"
"  nil, existing   numbered if numbered backups exist, simple otherwise\n"
"  never, simple   always make simple backups\n"
msgstr ""
"\n"
"El sufijo de respaldo es `~', a menos que se especifique con --suffix\n"
"o con SIMPLE_BACKUP_SUFFIX. El control de versiones puede establecerse\n"
"con --backup o con VERSION_CONTROL, los valores son:\n"
"\n"
"  t, numbered     hace copias de seguridad numeradas\n"
"  nil, existing   numerada si existen copias de seguridad numeradas, "
"simples\n"
"                  en otro caso\n"
"  never, simple   siempre hace copias de seguridad simples\n"

#: src/tar.c:270
msgid "Main operation mode:"
msgstr ""

#: src/tar.c:273
msgid "list the contents of an archive"
msgstr ""

#: src/tar.c:275
msgid "extract files from an archive"
msgstr ""

# # Como has puesto más arriba: "EOF"->"Fin de fichero". jmg
#: src/tar.c:278
#, fuzzy
msgid "create a new archive"
msgstr "EOF inesperado en el archivo"

#: src/tar.c:280
msgid "find differences between archive and file system"
msgstr ""

#: src/tar.c:283
#, fuzzy
msgid "append files to the end of an archive"
msgstr "%d bytes superfluos no se tendrán en cuenta al final del archivo"

#: src/tar.c:285
msgid "only append files newer than copy in archive"
msgstr ""

#: src/tar.c:287
msgid "append tar files to an archive"
msgstr ""

#: src/tar.c:290
msgid "delete from the archive (not on mag tapes!)"
msgstr ""

#: src/tar.c:293
msgid "Operation modifiers:"
msgstr ""

#: src/tar.c:296
msgid "attempt to verify the archive after writing it"
msgstr ""

#: src/tar.c:298
#, fuzzy
msgid "remove files after adding them to the archive"
msgstr ""
"Eliminando las especificaciones de unidad de los nombres que hay en el "
"archivo"

#: src/tar.c:300
msgid "don't replace existing files when extracting"
msgstr ""

#: src/tar.c:302
msgid "don't replace existing files that are newer than their archive copies"
msgstr ""

#: src/tar.c:304
msgid "preserve metadata of existing directories"
msgstr ""

#: src/tar.c:306
msgid "overwrite existing files when extracting"
msgstr ""

#: src/tar.c:308
msgid "remove each file prior to extracting over it"
msgstr ""

#: src/tar.c:310
msgid "empty hierarchies prior to extracting directory"
msgstr ""

#: src/tar.c:312
msgid "handle sparse files efficiently"
msgstr ""

#: src/tar.c:314
#, fuzzy
msgid "extract files to standard output"
msgstr "Error al escribir en la salida estándar"

#: src/tar.c:316
msgid "handle old GNU-format incremental backup"
msgstr ""

#: src/tar.c:317 src/tar.c:390 src/tar.c:455 src/tar.c:514
msgid "FILE"
msgstr ""

#: src/tar.c:318
msgid "handle new GNU-format incremental backup"
msgstr ""

#: src/tar.c:320
msgid "do not exit with nonzero on unreadable files"
msgstr ""

#: src/tar.c:321 src/tar.c:385 src/tar.c:398 src/tar.c:484
msgid "NUMBER"
msgstr ""

#: src/tar.c:322
msgid ""
"process only the NUMth occurrence of each file in the archive. This option "
"is valid only in conjunction with one of the subcommands --delete, --diff, --"
"extract or --list and when a list of files is given either on the command "
"line or via -T option. NUMBER defaults to 1."
msgstr ""

#: src/tar.c:324
msgid "Archive is seekable"
msgstr ""

#: src/tar.c:327
msgid "Handling of file attributes:"
msgstr ""

#: src/tar.c:329 src/tar.c:331 src/tar.c:387
msgid "NAME"
msgstr ""

#: src/tar.c:330
msgid "force NAME as owner for added files"
msgstr ""

#: src/tar.c:332
msgid "force NAME as group for added files"
msgstr ""

#: src/tar.c:333
msgid "CHANGES"
msgstr ""

#: src/tar.c:334
msgid "force (symbolic) mode CHANGES for added files"
msgstr ""

#: src/tar.c:336
msgid "don't change access times on dumped files"
msgstr ""

#: src/tar.c:338
msgid "don't extract file modified time"
msgstr ""

#: src/tar.c:340
msgid "try extracting files with the same ownership"
msgstr ""

#: src/tar.c:342
msgid "extract files as yourself"
msgstr ""

#: src/tar.c:344
msgid "always use numbers for user/group names"
msgstr ""

#: src/tar.c:346
msgid "extract permissions information"
msgstr ""

#: src/tar.c:349
msgid "do not extract permissions information"
msgstr ""

#: src/tar.c:351
msgid "sort names to extract to match archive"
msgstr ""

#: src/tar.c:354
msgid "same as both -p and -s"
msgstr ""

#: src/tar.c:357
msgid "Device selection and switching:"
msgstr ""

#: src/tar.c:359
msgid "ARCHIVE"
msgstr ""

#: src/tar.c:360
msgid "use archive file or device ARCHIVE"
msgstr ""

#: src/tar.c:362
msgid "archive file is local even if has a colon"
msgstr ""

#: src/tar.c:363 src/tar.c:365
msgid "COMMAND"
msgstr ""

#: src/tar.c:364
msgid "use given rmt COMMAND instead of rmt"
msgstr ""

#: src/tar.c:366
msgid "use remote COMMAND instead of rsh"
msgstr ""

#: src/tar.c:370
msgid "specify drive and density"
msgstr ""

#: src/tar.c:384
#, fuzzy
msgid "create/list/extract multi-volume archive"
msgstr "No se pueden verificar archivos multivolumen"

#: src/tar.c:386
msgid "change tape after writing NUMBER x 1024 bytes"
msgstr ""

#: src/tar.c:388
msgid "run script at end of each tape (implies -M)"
msgstr ""

#: src/tar.c:391
msgid "use/update the volume number in FILE"
msgstr ""

#: src/tar.c:394
msgid "Device blocking:"
msgstr ""

#: src/tar.c:396
msgid "BLOCKS"
msgstr ""

#: src/tar.c:397
msgid "BLOCKS x 512 bytes per record"
msgstr ""

#: src/tar.c:399
msgid "SIZE bytes per record, multiple of 512"
msgstr ""

#: src/tar.c:401
msgid "ignore zeroed blocks in archive (means EOF)"
msgstr ""

#: src/tar.c:403
msgid "reblock as we read (for 4.2BSD pipes)"
msgstr ""

# ¿Qué será esto? ¿Quizás un fallo en el mensaje original? Porque "to"
# no es "desde", sino "hacia", que yo sepa. Pero `archivo hacia la
# salida estándar' no pega mucho. Está en otros mensajes, como el
# siguiente; no lo entiendo. - gerardo
# FIXME. Tienes razón. Es muy raro.
#: src/tar.c:406
#, fuzzy
msgid "Archive format selection:"
msgstr "Archivo desde la entrada estándar"

#: src/tar.c:408
msgid "FORMAT"
msgstr ""

#: src/tar.c:409
msgid "create archive of the given format."
msgstr ""

#: src/tar.c:411
msgid "FORMAT is one of the following:"
msgstr ""

#: src/tar.c:412
msgid "old V7 tar format"
msgstr ""

#: src/tar.c:414
msgid "GNU format as per tar <= 1.12"
msgstr ""

#: src/tar.c:416
msgid "GNU tar 1.13.x format"
msgstr ""

#: src/tar.c:418
msgid "POSIX 1003.1-1988 (ustar) format"
msgstr ""

#: src/tar.c:420
msgid "POSIX 1003.1-2001 (pax) format"
msgstr ""

#: src/tar.c:421
msgid "Same as pax"
msgstr ""

#: src/tar.c:424
msgid "same as --format=v7"
msgstr ""

#: src/tar.c:427
msgid "same as --format=posix"
msgstr ""

#: src/tar.c:428
msgid "keyword[[:]=value][,keyword[[:]=value], ...]"
msgstr ""

#: src/tar.c:429
msgid "control pax keywords"
msgstr ""

#: src/tar.c:430
msgid "TEXT"
msgstr ""

#: src/tar.c:431
msgid ""
"create archive with volume name NAME. At list/extract time, use TEXT as a "
"globbing pattern"
msgstr ""

#: src/tar.c:433
msgid "filter the archive through bzip2"
msgstr ""

# FIXME: Decir al autor que ponga el "itself". sv
#: src/tar.c:435
#, fuzzy
msgid "filter the archive through gzip"
msgstr "%s: el fichero es el propio archivo; no se vuelca"

# FIXME: Decir al autor que ponga el "itself". sv
#: src/tar.c:439
#, fuzzy
msgid "filter the archive through compress"
msgstr "%s: el fichero es el propio archivo; no se vuelca"

#: src/tar.c:441
msgid "PROG"
msgstr ""

#: src/tar.c:442
msgid "filter through PROG (must accept -d)"
msgstr ""

#: src/tar.c:445
msgid "Local file selection:"
msgstr ""

#: src/tar.c:447
msgid "DIR"
msgstr ""

#: src/tar.c:448
#, fuzzy
msgid "change to directory DIR"
msgstr "No se puede cambiar al directorio %s"

#: src/tar.c:449
msgid "FILE-OF-NAMES"
msgstr ""

#: src/tar.c:450
msgid "get names to extract or create from file NAME"
msgstr ""

#: src/tar.c:452
msgid "-T reads null-terminated names, disable -C"
msgstr ""

#: src/tar.c:453
msgid "PATTERN"
msgstr ""

#: src/tar.c:454
msgid "exclude files, given as a PATTERN"
msgstr ""

#: src/tar.c:456
msgid "exclude patterns listed in FILE"
msgstr ""

#: src/tar.c:458
msgid "exclude directories containing a cache tag"
msgstr ""

#: src/tar.c:460
msgid "exclusion ignores case"
msgstr ""

#: src/tar.c:462
msgid "exclude patterns match file name start"
msgstr ""

#: src/tar.c:464
msgid "exclude patterns match after any / (default)"
msgstr ""

#: src/tar.c:466
msgid "exclusion is case sensitive (default)"
msgstr ""

#: src/tar.c:468
msgid "exclude patterns are plain strings"
msgstr ""

#: src/tar.c:470
msgid "exclude pattern wildcards do not match '/'"
msgstr ""

#: src/tar.c:472
msgid "avoid descending automatically in directories"
msgstr ""

#: src/tar.c:474
msgid "stay in local file system when creating archive"
msgstr ""

#: src/tar.c:477
msgid "recurse into directories (default)"
msgstr ""

#: src/tar.c:479
#, fuzzy
msgid "don't strip leading `/'s from file names"
msgstr "Eliminando la `/' inicial de los nombres de los enlaces"

#: src/tar.c:481
msgid "dump instead the files symlinks point to"
msgstr ""

#: src/tar.c:482
msgid "MEMBER-NAME"
msgstr ""

#: src/tar.c:483
msgid "begin at member MEMBER-NAME in the archive"
msgstr ""

#: src/tar.c:485
msgid "strip NUMBER leading components from file names"
msgstr ""

#: src/tar.c:486
msgid "DATE-OR-FILE"
msgstr ""

#: src/tar.c:487
msgid "only store files newer than DATE-OR-FILE"
msgstr ""

#: src/tar.c:488 src/tar.c:490
msgid "DATE"
msgstr ""

#: src/tar.c:489
msgid "compare date and time when data changed only"
msgstr ""

#: src/tar.c:491
msgid "same as -N"
msgstr ""

#: src/tar.c:492
msgid "CONTROL"
msgstr ""

#: src/tar.c:493
msgid "backup before removal, choose version CONTROL"
msgstr ""

#: src/tar.c:494
msgid "STRING"
msgstr ""

#: src/tar.c:495
msgid ""
"backup before removal, override usual suffix ('~' unless overridden by "
"environment variable SIMPLE_BACKUP_SUFFIX"
msgstr ""

#: src/tar.c:497
msgid "exclude patterns use wildcards (default)"
msgstr ""

#: src/tar.c:499
msgid "exclude pattern wildcards match '/' (default)"
msgstr ""

#: src/tar.c:502
msgid "Informative output:"
msgstr ""

#: src/tar.c:505
msgid "verbosely list files processed"
msgstr ""

#: src/tar.c:507
msgid "display progress messages every 10th record"
msgstr ""

#: src/tar.c:509
msgid "print a message if not all links are dumped"
msgstr ""

#: src/tar.c:511
msgid "print total bytes written while creating archive"
msgstr ""

#: src/tar.c:513
msgid "print file modification dates in UTC"
msgstr ""

#: src/tar.c:515
msgid "send verbose output to FILE"
msgstr ""

#: src/tar.c:517
msgid "show block number within archive with each message"
msgstr ""

#: src/tar.c:519
#, fuzzy
msgid "ask for confirmation for every action"
msgstr "No se puede leer la confirmación del usuario"

#: src/tar.c:522
msgid "Show tar defaults"
msgstr ""

#: src/tar.c:524
msgid ""
"When listing or extracting, list each directory that does not match search "
"criteria"
msgstr ""

#: src/tar.c:527
msgid "Compatibility options:"
msgstr ""

#: src/tar.c:530
msgid ""
"when creating, same as --old-archive. When extracting, same as --no-same-"
"owner"
msgstr ""

#: src/tar.c:533
msgid "Other options:"
msgstr ""

#: src/tar.c:535
msgid "Give this help list"
msgstr ""

#: src/tar.c:536
msgid "Give a short usage message"
msgstr ""

#: src/tar.c:537
msgid "Print license and exit"
msgstr ""

#: src/tar.c:538
msgid "Print program version"
msgstr ""

#: src/tar.c:575
msgid "You may not specify more than one `-Acdtrux' option"
msgstr "No se puede especificar más de una opción `-Acdtrux'"

#: src/tar.c:585
msgid "Conflicting compression options"
msgstr "Opciones de compresión en conflicto"

#: src/tar.c:595
msgid ""
"Based on the work of John Gilmore and Jay Fenlason. See AUTHORS\n"
"for complete list of authors.\n"
msgstr ""

#: src/tar.c:597
#, c-format
msgid ""
"   GNU tar is free software; you can redistribute it and/or modify\n"
"   it under the terms of the GNU General Public License as published by\n"
"   the Free Software Foundation; either version 2 of the License, or\n"
"   (at your option) any later version.\n"
"\n"
"   GNU tar is distributed in the hope that it will be useful,\n"
"   but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"   GNU General Public License for more details.\n"
"\n"
"   You should have received a copy of the GNU General Public License\n"
"   along with GNU tar; if not, write to the Free Software\n"
"   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA\n"
"\n"
msgstr ""

#: src/tar.c:638
msgid "Invalid blocking factor"
msgstr "Factor de bloqueo inválido"

#: src/tar.c:713
msgid "Warning: the -I option is not supported; perhaps you meant -j or -T?"
msgstr "Atención: no se admite la opción -I; ¿no será -j o -T?"

#: src/tar.c:738
msgid "Semantics of -l option will change in the future releases."
msgstr ""

#: src/tar.c:740
msgid "Please use --one-file-system option instead."
msgstr ""

#: src/tar.c:753
msgid "Invalid tape length"
msgstr "Longitud de cinta inválida"

# No sé cómo traducir threshold. fr
# Yo tampoco (los diccionarios los tengo en casa...). sv
# Lo buscaré en un diccionario "güeno". fr
# Es "umbral", pero no sé qué c$%&# es la fecha umbral. :-( gag
# A ver si te vale así. sv
# ¿Qué tal os suena "fecha límite"?. jmg
#: src/tar.c:781
msgid "More than one threshold date"
msgstr "Se ha especificado más de una fecha tope"

#: src/tar.c:791
msgid "Date file not found"
msgstr "No se encontró la fecha del fichero"

#: src/tar.c:800
#, c-format
msgid "Substituting %s for unknown date format %s"
msgstr "Sustituyendo %s por el formato de fecha desconocido %s"

#: src/tar.c:905
msgid "Warning: the -y option is not supported; perhaps you meant -j?"
msgstr "Atención: no se admite la opción -y; ¿no será -j?"

#: src/tar.c:981
#, c-format
msgid "%s: Invalid group"
msgstr "%s: Grupo inválido"

#: src/tar.c:990
msgid "Invalid mode given on option"
msgstr "Se ha especificado un modo no válido en la opción"

#: src/tar.c:1033
#, fuzzy
msgid "Invalid number"
msgstr "Número de nodo-i inválido"

#: src/tar.c:1051
msgid "Invalid owner"
msgstr "Propietario inválido"

#: src/tar.c:1075
msgid "Invalid record size"
msgstr "El tamaño del registro es inválido"

#: src/tar.c:1078
#, c-format
msgid "Record size must be a multiple of %d."
msgstr "El tamaño del registro debe ser múltiplo de %d."

#: src/tar.c:1110
#, fuzzy
msgid "Invalid number of elements"
msgstr "Longitud de cinta inválida"

#: src/tar.c:1185
#, c-format
msgid "Malformed density argument: '%s'"
msgstr ""

#: src/tar.c:1221
#, fuzzy, c-format
msgid "Unknown density: '%c'"
msgstr "El patrón `%s' es desconocido"

#: src/tar.c:1241
msgid "Options `-[0-7][lmh]' not supported by *this* tar"
msgstr "*Esta* versión de tar no admite las opciones `-[0-7][lmh]'"

#: src/tar.c:1249
#, c-format
msgid ""
"\n"
"*This* tar defaults to:\n"
msgstr ""

#: src/tar.c:1278
msgid "[FILE]..."
msgstr ""

#: src/tar.c:1375
#, c-format
msgid "Old option `%c' requires an argument."
msgstr "La opción antigua `%c' requiere un argumento"

#: src/tar.c:1458
msgid "--occurrence is meaningless without a file list"
msgstr ""

#: src/tar.c:1464
msgid "--occurrence cannot be used in the requested operation mode"
msgstr ""

# requieren -> necesitan. gerardo
#: src/tar.c:1494
#, fuzzy
msgid "Multiple archive files require `-M' option"
msgstr "Los archivos múltiples requieren la opción `-M'"

#: src/tar.c:1499
msgid "Cannot combine --listed-incremental with --newer"
msgstr "No se puede combinar --listed-incremental con --newer"

#: src/tar.c:1514
#, fuzzy, c-format
msgid "%s: Volume label is too long (limit is %lu byte)"
msgid_plural "%s: Volume label is too long (limit is %lu bytes)"
msgstr[0] ""
"%s: La etiqueta de volumen es demasiado larga (el límite es %lu bytes)"
msgstr[1] ""
"%s: La etiqueta de volumen es demasiado larga (el límite es %lu bytes)"

#: src/tar.c:1524
msgid "Cannot verify multi-volume archives"
msgstr "No se pueden verificar archivos multivolumen"

#: src/tar.c:1526
msgid "Cannot verify compressed archives"
msgstr "No se pueden verificar archivos comprimidos"

#: src/tar.c:1532
msgid "Cannot use multi-volume compressed archives"
msgstr "No se pueden utilizar archivos multivolumen comprimidos"

#: src/tar.c:1534
msgid "Cannot update compressed archives"
msgstr "No se pueden actualizar archivos comprimidos"

#: src/tar.c:1546
msgid "--pax-option can be used only on POSIX archives"
msgstr ""

# Me gusta más al verrés: cobarde rechazo [de la pradera] a... gerardo
#: src/tar.c:1563
msgid "Cowardly refusing to create an empty archive"
msgstr "Rechazo cobarde a crear un archivo vacío"

#: src/tar.c:1584
msgid "Options `-Aru' are incompatible with `-f -'"
msgstr "Las opciones `-Aru' son incompatibles con `-f -'"

#: src/tar.c:1607
#, c-format
msgid "Treating date `%s' as %s + %ld nanosecond"
msgid_plural "Treating date `%s' as %s + %ld nanoseconds"
msgstr[0] ""
msgstr[1] ""

#: src/tar.c:1663
msgid "You must specify one of the `-Acdtrux' options"
msgstr "Se debe especificar una de las opciones `-Acdtrux'"

#: src/tar.c:1715
msgid "Error in writing to standard output"
msgstr "Error al escribir en la salida estándar"

# Antes decía:
# "La salida con error se demora por los errores anteriores
#
# Quiere decir que hubo errores, pero tar pudo seguir adelante, sin
# embargo va a salir con un estado de error por esos errores que ya pasaron.
# Una traducción:
# "Salida con error demorada desde errores anteriores" (Nicolás L.)
#: src/tar.c:1717
msgid "Error exit delayed from previous errors"
msgstr "Salida con error demorada desde errores anteriores"

# Eso de ¡vaya tela! ¿es una interjección que se entiende en todo el mundo
# hispanoparlante? No vaya a ser específico de Andalucía/Extremadura y...
# ¡oye, déjalo, así expandimos nuestra lengua! gerardo
# Inaceptable, alguien fuera de España no tiene idea de que diablos quiere
# decir ¡vaya tela!. Habrá que buscar alguna interhección de asco/sorpresa
# que sea más `portable'. nl
# Tenéis razón. Habrá que preguntar.
# ¡Ya lo tengo! "¡Carajo!" X-D Eso se utiliza en Colombia, México y otros
# sitios de por ahí a troche y moche, y creo que ni siquiera se entiende como
# "miembro viril masculino". Y en España creo que también se emplea, ¿no?
# (Vaale, vaaale, ¿y qué tal su eufemismo `caramba' o `caray', más neutros
# y cursis, para que no se enfade nadie? Aunque para cursis: `cáspita',
# `caracoles', `cónchales'; no diréis que no os doy opciones.) Por cierto,
# creo que la coma sobra (incluso en el original). gerardo
#: src/update.c:86
#, fuzzy, c-format
msgid "%s: File shrank by %s byte"
msgid_plural "%s: File shrank by %s bytes"
msgstr[0] "%s: El tamaño del fichero ha disminuido en %s bytes"
msgstr[1] "%s: El tamaño del fichero ha disminuido en %s bytes"

#: src/xheader.c:140
#, c-format
msgid "Keyword %s is unknown or not yet imlemented"
msgstr ""

#: src/xheader.c:166
#, c-format
msgid "Pattern %s cannot be used"
msgstr ""

#: src/xheader.c:176
#, c-format
msgid "Keyword %s cannot be overridden"
msgstr ""

#: src/xheader.c:490
msgid "Malformed extended header: missing whitespace after the length"
msgstr ""

#: src/xheader.c:501
msgid "Malformed extended header: missing equal sign"
msgstr ""

#~ msgid "Cannot close"
#~ msgstr "No se puede cerrar"

# FIXME. Comunicar al autor. Con suerte quedará como un mensaje
# parecido que hay en fileutils: "fork system call failed".
# La solución de fileutils no me acaba de convencer (era "llamada
# a fork()" ). Yo pondría: "No se puede crear proceso hijo (fork)"
# que responde a la idea del fork y el paréntesis aclara. jmg
# Pero eso sería "Cannot create child process"...
# Yo creo que la solución de fileutils es la mejor.
# Tanto es así que lo pongo igual que allí. sv
# Literalmente es "No puedo bifurcar", pero como sabemos que
# `bifurcar' se refiere a la primitiva `fork()', está bien como está,
# salvo que se debería conservar la mayúscula inicial, y para mi gusto,
# simplificar, respetando el mensaje original: "Fallo en fork()" - gerardo
# Pongo la mayúscula inicial, pero antes de ser tan respetuoso con el original
# consultaré con el autor. sv
#~ msgid "Cannot dup"
#~ msgstr "Falló la llamada al sistema `dup'"

#~ msgid "Cannot use compressed or remote archives"
#~ msgstr "No se pueden usar archivos comprimidos ni remotos"

# ¿Por qué en todo lugar donde dice "child" se traduce como "proceso hijo" y
# no como "hijo" directamente? nl
# Para que esté más claro. ¿es demasiado libre la traducción? sv
# ¿Gerardo?
# Hola. Hay dos posturas a la hora de traducir:
# a) respetar escrupulosamente el mensaje original y traducir
#       literalmente, o casi.
# b) buscar la mejor interpretación de forma que un hispanohablante lo
#       entienda lo mejor posible, aunque se "corrija" al autor; siempre
#       sin cambiar el sentido o la idea del mensaje, claro.
# Yo prefiero (b) generalmente. Está claro que aquí child se refiere a un
# proceso, un proceso derivado de otro, proceso hijo. Daría igual dejar hijo
# solamente, pero así está mejor expresado. Me gusta más.
#~ msgid "tar (child)"
#~ msgstr "tar (proceso hijo)"

#~ msgid "tar (grandchild)"
#~ msgstr "tar (proceso nieto)"

# ¿Por qué no respetar el original? Couldn't -> No se ha podido,
# Cannot -> No puido, no puido... gerardo
# Porque a continuación hay un montón de "cannot"s.
# No creo que haya que ser tan tan respetuoso con el original. sv
#
# Nota del última hora: El autor ha homogeneizado todo a cannot.
# Esto apoya mi teoría :-)
#~ msgid "Cannot allocate memory for blocking factor %d"
#~ msgstr "No se puede asignar memoria para el factor de bloqueo %d"

#~ msgid "Child died with signal %d"
#~ msgstr "El proceso hijo terminó con la señal %d"

#~ msgid "Child returned status %d"
#~ msgstr "El proceso hijo devolvió el estado %d"

#~ msgid "Member names contain `..'"
#~ msgstr "Los nombres contienen `..'"

#~ msgid "%s: Member name contains `..'"
#~ msgstr "%s: El nombre contiene `..'"

# Yo usaría "recuperar", en vez de "restablecer". Lo de repetir "archivo"
# dos veces en la misma frase no me suena bien, así que pondría "... a
# partir de aquél". jmg
# El original también repite. sv
#
# ¡CUIDADO! sólo no debe llevar tilde en ".. juntos en un solo archivo..."
# `Solo' sólo lleva acento cuando equivale al adverbio de modo `solamente',
# y aun así no es obligatorio ponérselo si no hay ambigüedad (lo siento,
# muchachos, pero saqué sobresaliente en Lingüística de COU :-D ) gerardo
# Lo cambio, pero "no es obligatorio" no es lo mismo que "está mal". sv
#~ msgid ""
#~ "GNU `tar' saves many files together into a single tape or disk archive, "
#~ "and\n"
#~ "can restore individual files from the archive.\n"
#~ msgstr ""
#~ "GNU `tar' guarda varios ficheros juntos en un solo archivo en cinta o "
#~ "disco, y\n"
#~ "puede restablecer ficheros individuales a partir del archivo.\n"

#~ msgid ""
#~ "\n"
#~ "Usage: %s [OPTION]... [FILE]...\n"
#~ "\n"
#~ "Examples:\n"
#~ "  %s -cf archive.tar foo bar  # Create archive.tar from files foo and "
#~ "bar.\n"
#~ "  %s -tvf archive.tar         # List all files in archive.tar verbosely.\n"
#~ "  %s -xf archive.tar          # Extract all files from archive.tar.\n"
#~ msgstr ""
#~ "\n"
#~ "Modo de empleo: %s [OPCIÓN]... [FICHERO]...\n"
#~ "\n"
#~ "Ejemplos:\n"
#~ " %s -cf archivo.tar fu fa # Crea archivo.tar con los ficheros fu y fa.\n"
#~ " %s -tvf archivo.tar      # Lista en detalle todos los ficheros de "
#~ "archivo.tar\n"
#~ " %s -xf archivo.tar       # Extrae todos los ficheros de archivo.tar.\n"

# Es cierto que en la traducción se repite obligatorio, pero es que eso
# mismo ocurre en el original, por lo tanto, lo dejo así.
#~ msgid ""
#~ "\n"
#~ "If a long option shows an argument as mandatory, then it is mandatory\n"
#~ "for the equivalent short option also.  Similarly for optional arguments.\n"
#~ msgstr ""
#~ "\n"
#~ "Si una opción larga muestra un argumento como obligatorio, entonces es\n"
#~ "obligatorio también para la opción corta equivalente. Lo mismo ocurre "
#~ "con\n"
#~ "los argumentos opcionales.\n"

#~ msgid ""
#~ "\n"
#~ "Main operation mode:\n"
#~ "  -t, --list              list the contents of an archive\n"
#~ "  -x, --extract, --get    extract files from an archive\n"
#~ "  -c, --create            create a new archive\n"
#~ "  -d, --diff, --compare   find differences between archive and file "
#~ "system\n"
#~ "  -r, --append            append files to the end of an archive\n"
#~ "  -u, --update            only append files newer than copy in archive\n"
#~ "  -A, --catenate          append tar files to an archive\n"
#~ "      --concatenate       same as -A\n"
#~ "      --delete            delete from the archive (not on mag tapes!)\n"
#~ msgstr ""
#~ "\n"
#~ "Modo de operación principal:\n"
#~ "  -t, --list              lista el contenido de un archivo\n"
#~ "  -x, --extract, --get    extrae ficheros de un archivo\n"
#~ "  -c, --create            crea un nuevo archivo\n"
#~ "  -d, --diff, --compare   encuentra las diferencias entre el archivo y "
#~ "el\n"
#~ "                          sistema de ficheros\n"
#~ "  -r, --append            añade ficheros al final de un archivo\n"
#~ "  -u, --update            sólo añade ficheros más recientes que la copia "
#~ "del\n"
#~ "                          archivo\n"
#~ "  -A, --catenate          añade ficheros tar a un archivo\n"
#~ "      --concatenate       igual que -A\n"
#~ "      --delete            borra de un archivo (¡no en cintas "
#~ "magnéticas!)\n"

# ¿archivos nonzero? sv
# Estupendo Gerardo, se me había pasado, como tantas cosas em+
# # ¡Nooorl! Quiere decir que el programa tar no acaba o sale (exit())
# # devolviendo al sistema un "status" distinto de cero cuando
# # encuentre ficheros ilegibles. (¡Uf! Ahora a ver cómo se pone esto en
# # media línea.) gag
#
#~ msgid ""
#~ "\n"
#~ "Operation modifiers:\n"
#~ "  -W, --verify               attempt to verify the archive after writing "
#~ "it\n"
#~ "      --remove-files         remove files after adding them to the "
#~ "archive\n"
#~ "  -k, --keep-old-files       don't replace existing files when "
#~ "extracting\n"
#~ "      --overwrite            overwrite existing files when extracting\n"
#~ "      --overwrite-dir        overwrite directory metadata when "
#~ "extracting\n"
#~ "  -U, --unlink-first         remove each file prior to extracting over "
#~ "it\n"
#~ "      --recursive-unlink     empty hierarchies prior to extracting "
#~ "directory\n"
#~ "  -S, --sparse               handle sparse files efficiently\n"
#~ "  -O, --to-stdout            extract files to standard output\n"
#~ "  -G, --incremental          handle old GNU-format incremental backup\n"
#~ "  -g, --listed-incremental=FILE\n"
#~ "                             handle new GNU-format incremental backup\n"
#~ "      --ignore-failed-read   do not exit with nonzero on unreadable "
#~ "files\n"
#~ msgstr ""
#~ "\n"
#~ "Modificadores de operación:\n"
#~ "  -W, --verify               intenta verificar el archivo después de "
#~ "escribirlo\n"
#~ "      --remove-files         borra los ficheros después de añadirlos al "
#~ "archivo\n"
#~ "  -k, --keep-old-files       no sobreescribe los ficheros existentes al "
#~ "extraer\n"
#~ "      --overwrite            sobreescribe los ficheros existentes al "
#~ "extraer\n"
#~ "      --overwrite-dir        sobreescribe metadatos de directorios al "
#~ "extraer\n"
#~ "  -U, --unlik-first          borra cada fichero antes de extraer sobre "
#~ "él\n"
#~ "      --recursive-unlink     vacía las jerarquías antes de extraer "
#~ "directorios\n"
#~ "  -S, --sparse               maneja archivos dispersos eficientemente\n"
#~ "  -O, --to-stdout            extrae ficheros hacia la salida estándar\n"
#~ "  -G, --incremental          maneja copias de seguridad incrementales en\n"
#~ "                             formato GNU antiguo\n"
#~ "  -g, --listed-incremental=FICHERO\n"
#~ "                             maneja copias de seguridad incrementales en\n"
#~ "                             el nuevo formato de GNU\n"
#~ "      --ignore-failed-read   no termina con estado de error cuando "
#~ "encuentra\n"
#~ "                             archivos ilegibles\n"

# FUZZY. Tenía un fuzzy. Averiguar por qué. sv
# Sugerencia: para archivos -> para los archivos. sv
# Sugerencia: Estandarizar la traducción de "added files". sv
# En el  --mode=CHANGES  no sé qué poner... sv
# En vez de "force"->"establece", yo dejaría el significado
# original ->"fuerza". jmg
# force es forzar, ¡no establecer! nl
# Gerardo, ¿qué opinas de "forzar"? sv
# Hombre, desde luego to force es forzar u obligar; la verdad es que no sé
# por qué el autor original dice "force" y no "set". Quizá porque si no se
# pusieran estas opciones los ficheros tendrían otros atributos que vendrían
# impuestos por el umask, el UID/GID del usuario, etc., y con esto se "fuerza",
# se cambia esta situación. No es lo mismo que establecer, que sería poner
# esos atributos partiendo de cero. Creo que ése es el matiz, y para conservar-
# lo habría que poner "fuerza NOMBRE como propietario...", etc., o bien
# "obliga a que sea NOMBRE el propietario...", etc. gerardo
# # usa -> emplea - gerardo
#~ msgid ""
#~ "\n"
#~ "Handling of file attributes:\n"
#~ "      --owner=NAME             force NAME as owner for added files\n"
#~ "      --group=NAME             force NAME as group for added files\n"
#~ "      --mode=CHANGES           force (symbolic) mode CHANGES for added "
#~ "files\n"
#~ "      --atime-preserve         don't change access times on dumped files\n"
#~ "  -m, --modification-time      don't extract file modified time\n"
#~ "      --same-owner             try extracting files with the same "
#~ "ownership\n"
#~ "      --no-same-owner          extract files as yourself\n"
#~ "      --numeric-owner          always use numbers for user/group names\n"
#~ "  -p, --same-permissions       extract permissions information\n"
#~ "      --no-same-permissions    do not extract permissions information\n"
#~ "      --preserve-permissions   same as -p\n"
#~ "  -s, --same-order             sort names to extract to match archive\n"
#~ "      --preserve-order         same as -s\n"
#~ "      --preserve               same as both -p and -s\n"
#~ msgstr ""
#~ "\n"
#~ "Manejo de los atributos de los ficheros:\n"
#~ "      --owner=NOMBRE           establece NOMBRE como propietario para "
#~ "los\n"
#~ "                               ficheros que se añaden\n"
#~ "      --group=NOMBRE           establece NOMBRE como grupo para los "
#~ "ficheros que\n"
#~ "                               se añaden\n"
#~ "      --mode=CAMBIOS           establece CAMBIOS como modo (simbólico) "
#~ "para los\n"
#~ "                               ficheros que se añaden\n"
#~ "      --atime-preserve         no cambia la fecha de acceso en los "
#~ "ficheros\n"
#~ "                               volcados\n"
#~ "  -m, --modification-time      no extrae la fecha de modificación de "
#~ "ficheros\n"
#~ "      --same-owner             intenta extraer ficheros con el mismo "
#~ "propietario\n"
#~ "      --no-same-owner          extrae los ficheros como uno mismo\n"
#~ "      --numeric-owner          siempre utiliza números para nombres de\n"
#~ "                               usuario/grupo\n"
#~ "  -p, --same-permissions       extrae la información de los permisos\n"
#~ "      --no-same-permissions    no extrae la información de los permisos\n"
#~ "      --preserve-permissions   igual que -p\n"
#~ "  -s, --same-order             ordena los nombres a extraer para "
#~ "coincidir con\n"
#~ "                               el archivo\n"
#~ "      --preserve-order         igual que -s\n"
#~ "      --preserve               igual que -p y -s a la vez\n"

# Una chorradita, si se me permite; estamos usando ISO-8859-1,
# ¿verdad? Y en ISO-Latin1 existe un carácter que representa la
# multiplicación, ¿verdad? Ya saben , el aspa: '×' ('\327'). Pues
# ¿por qué no usarlo (está bien, "utilizarlo" ;-) en vez de la equis
# en NUM x 1024 -> NUM × 1024?
# En otra parte dices que pones (C) en vez de © porque © no se ve bien en
# la consola. Pues no dirás eso del aspa, que se ve mejor aún que la equis:
# x × - gerardo
# Efectivamente, pero no es transportable, el que use tar bajo DJGPP
# le saldría un churro pues el aspa no existe en la tabla 850. sv
#~ msgid ""
#~ "\n"
#~ "Device selection and switching:\n"
#~ "  -f, --file=ARCHIVE             use archive file or device ARCHIVE\n"
#~ "      --force-local              archive file is local even if has a "
#~ "colon\n"
#~ "      --rsh-command=COMMAND      use remote COMMAND instead of rsh\n"
#~ "  -[0-7][lmh]                    specify drive and density\n"
#~ "  -M, --multi-volume             create/list/extract multi-volume "
#~ "archive\n"
#~ "  -L, --tape-length=NUM          change tape after writing NUM x 1024 "
#~ "bytes\n"
#~ "  -F, --info-script=FILE         run script at end of each tape (implies -"
#~ "M)\n"
#~ "      --new-volume-script=FILE   same as -F FILE\n"
#~ "      --volno-file=FILE          use/update the volume number in FILE\n"
#~ msgstr ""
#~ "\n"
#~ "Selección de dispositivos y conmutadores:\n"
#~ "  -f, --file=ARCHIVO             utiliza el archivo o dispositivo "
#~ "ARCHIVO\n"
#~ "      --force-local              el archivo es local incluso si tiene dos "
#~ "puntos\n"
#~ "      --rsh-command=ORDEN        utiliza la ORDEN remota en vez de rsh\n"
#~ "  -[0-7][lmh]                    especifica unidad y densidad\n"
#~ "  -M, --multi-volume             crea/lista/extrae un archivo "
#~ "multivolumen\n"
#~ "  -L, --tape-length=NUM          cambia la cinta después de escribir NUM "
#~ "x 1024\n"
#~ "                                 bytes\n"
#~ "  -F, --info-script=FICHERO      ejecuta el script al final de cada "
#~ "cinta\n"
#~ "                                  (implica -M)\n"
#~ "      --new-volume-script=FICH   igual que -F FICH\n"
#~ "      --volno-file=ARCHIVO       utiliza/actualiza el número de volumen "
#~ "en\n"
#~ "                                 ARCHIVO\n"

# ¿rebloquea? ¿existe esa palabra? sv
# Que opine el pueblo, no lo sé. fr
# # ¿Existe bloquear? Pues si es así, también existe rebloquear =
# # volver a bloquear. Y requetebloquear, etc. En un artículo de Martin
# # Gardner se preguntaba cuál era la palabra española más larga, y la
# # respuesta era que cualquiera que pudiera ir precedida por
# # requetequetequete... (longitud infinita). Pelín ssagerao, ¿no? gag
# ignore no es ignorar, es "no hacer caso"
# se puede usar: no tener en cuenta, descartar, no tener efecto,
# pasar por alto,
# ignorar es "not to know". sv
# ¿Y cuando se ignora a una persona ;-)? fr
# Lo mismo: Está mal dicho, se dice que no le haces caso a esa persona.
# Si no me crees busca "ignore" en algún buen diccionario.
# O mira la lista de pifias de Ángel Álvarez directamente.
# La tengo en ftp.unex.es.
# Lo siento, Santiago, hemos sido derrotados; "ignorar" ya viene en los
# diccionarios de español, y creo que hasta en el DRAE, con el significado
# que tiene en inglés "to ignore"; aunque nosotros podemos ignorarlo ;-)
# y seguir en la ortodoxia castellana :-) gerardo
# Seguiremos en la ortodoxia, pero aún así, no puedo creerme que venga
# en el DRAE. ¿Estás seguro? sv
# No, no me compré el DRAE. Pregúntalo a spanglish (si te atreves ;-) gerardo
# ¿para pipes de BSD? sv
# # conducciones de BSD. gag
# Como has puesto más arriba: "EOF"->"Fin de fichero".
# Me suena mejor "descartar" que "pasar por alto", para "ignore".
# Respecto a pipes, lo de más arriba: "...en canales (pipes) de...". jmg
# Sigo en mis 13 y en esto no hay quien me baje del burro: BLOQUES x 512 bytes
# debe ser BLOQUES × 512 bytes. gerardo
#~ msgid ""
#~ "\n"
#~ "Device blocking:\n"
#~ "  -b, --blocking-factor=BLOCKS   BLOCKS x 512 bytes per record\n"
#~ "      --record-size=SIZE         SIZE bytes per record, multiple of 512\n"
#~ "  -i, --ignore-zeros             ignore zeroed blocks in archive (means "
#~ "EOF)\n"
#~ "  -B, --read-full-records        reblock as we read (for 4.2BSD pipes)\n"
#~ msgstr ""
#~ "\n"
#~ "Bloques de dispositivos:\n"
#~ "  -b, --blocking-factor=BLOQUES  BLOQUES x 512 bytes por registro\n"
#~ "      --record-size=TAMAÑO       TAMAÑO bytes por registro, múltiplo de "
#~ "512\n"
#~ "  -i, --ignore-zeros             pasa por alto bloques de ceros en "
#~ "archivo\n"
#~ "                                 (significan EOF)\n"
#~ "  -B, --read-full-records        rebloquea mientras se lee (en tuberías\n"
#~ "                                 de 4.2BSD)\n"

# Nota: La diferencia entre un PATRÓN y una EXPREG es que
# el primero se refiere a un "globbing pattern", es decir, patrones
# de expansión de nombres de ficheros, como * y ?, mientras que
# el segundo se refiera a expresiones regulares como las de grep,
# es decir, ^, $, ., *, etc.
#~ msgid ""
#~ "\n"
#~ "Archive format selection:\n"
#~ "  -V, --label=NAME                   create archive with volume name "
#~ "NAME\n"
#~ "              PATTERN                at list/extract time, a globbing "
#~ "PATTERN\n"
#~ "  -o, --old-archive, --portability   write a V7 format archive\n"
#~ "      --posix                        write a POSIX format archive\n"
#~ "  -j, --bzip2                        filter the archive through bzip2\n"
#~ "  -z, --gzip, --ungzip               filter the archive through gzip\n"
#~ "  -Z, --compress, --uncompress       filter the archive through compress\n"
#~ "      --use-compress-program=PROG    filter through PROG (must accept -"
#~ "d)\n"
#~ msgstr ""
#~ "\n"
#~ "Selección de formato de archivo:\n"
#~ "  -V, --label=NOMBRE                 crea un archivo con nombre de "
#~ "volumen\n"
#~ "                                     NOMBRE\n"
#~ "              PATRÓN                 en el momento de listar/extraer, "
#~ "utiliza un\n"
#~ "                                     PATRÓN\n"
#~ "  -o, --old-archive, --portability   escribe un archivo con formato V7\n"
#~ "      --posix                        escribe un archivo con formato "
#~ "POSIX\n"
#~ "  -j, --bzip2                        filtra el archivo a través de bzip2\n"
#~ "  -z, --gzip, --ungzip               filtra el archivo a través de gzip\n"
#~ "  -Z, --compress, --uncompress       filtra el archivo a través de "
#~ "compress\n"
#~ "      --use-compress-program=PROG    filtra a través de PROG (debe "
#~ "aceptar -d)\n"

# He cambiado el "desde" por "del", si te suena raro, se puede cambiar el
# orden: "obtiene del archivo NOMBRE los nombres a crear o extraer". sv
# De todas formas, lo de los nombres "a extraer" es un vicio moderno
# que me encantaría poder evitar. sv
# [ Ahora mismo lo único que se me ocurre es cambiar completamente la frase:
# "extrae o crea los nombres obtenidos del archivo NOMBRE" o algo así. sv ]
# A mí me suena bien, pero no sé... fr
# ¿globbing = globales? sv
# Me parece una buena traducción, es algo que engloba a un grupo. fr
#
# globbing es, por ejemplo, lo que hace el shell cuando pones asteriscos:
# Cuando haces "cat *", el shell se encarga de expandir el *
# en lo que corresponda, y se lo da a cat ya traducido.
# Esto más que globalizar me suena a expandir, no sé.
# Si quieres déjalo que lo vea otro. sv
# Vid. mi comentario del mensaje anterior. gerardo
# quita -> elimina. sv
#~ msgid ""
#~ "\n"
#~ "Local file selection:\n"
#~ "  -C, --directory=DIR          change to directory DIR\n"
#~ "  -T, --files-from=NAME        get names to extract or create from file "
#~ "NAME\n"
#~ "      --null                   -T reads null-terminated names, disable -"
#~ "C\n"
#~ "      --exclude=PATTERN        exclude files, given as a PATTERN\n"
#~ "  -X, --exclude-from=FILE      exclude patterns listed in FILE\n"
#~ "      --anchored               exclude patterns match file name start "
#~ "(default)\n"
#~ "      --no-anchored            exclude patterns match after any /\n"
#~ "      --ignore-case            exclusion ignores case\n"
#~ "      --no-ignore-case         exclusion is case sensitive (default)\n"
#~ "      --wildcards              exclude patterns use wildcards (default)\n"
#~ "      --no-wildcards           exclude patterns are plain strings\n"
#~ "      --wildcards-match-slash  exclude pattern wildcards match "
#~ "'/' (default)\n"
#~ "      --no-wildcards-match-slash exclude pattern wildcards do not match "
#~ "'/'\n"
#~ "  -P, --absolute-names         don't strip leading `/'s from file names\n"
#~ "  -h, --dereference            dump instead the files symlinks point to\n"
#~ "      --no-recursion           avoid descending automatically in "
#~ "directories\n"
#~ "  -l, --one-file-system        stay in local file system when creating "
#~ "archive\n"
#~ "  -K, --starting-file=NAME     begin at file NAME in the archive\n"
#~ msgstr ""
#~ "\n"
#~ "Selección de fichero local:\n"
#~ "  -C, --directory DIR         cambia al directorio DIR\n"
#~ "  -T, --files-from=NOMBRE     obtiene los nombres a extraer o crear del\n"
#~ "                              archivo NOMBRE\n"
#~ "      --null                  -T lee nombres terminados en cero, "
#~ "deshabilita -C\n"
#~ "      --exclude=PATRÓN        excluye ficheros, dados como un PATRÓN\n"
#~ "  -X, --exclude-from=FICHERO  excluye patrones listados en FICHERO\n"
#~ "      --anchored              los patrones de exclusión encajan desde el\n"
#~ "                              comienzo del nombre de fichero "
#~ "(predeterminado)\n"
#~ "      --no-anchored           los patrones de exclusión encajan después "
#~ "de\n"
#~ "                              cualquier /\n"
#~ "      --ignore-case           la exclusión considera iguales minúsculas "
#~ "y\n"
#~ "                              mayúsculas\n"
#~ "      --no-ignore-case        la exclusión distingue minúsculas de "
#~ "mayúsculas\n"
#~ "                              (predeterminado)\n"
#~ "      --wildcards             los patrones de exclusión incluyen "
#~ "comodines\n"
#~ "                              (predeterminado)\n"
#~ "      --no-wildcards          los patrones de exclusión son cadenas "
#~ "normales\n"
#~ "      --wildcards-match-slash los comodines de los patrones de exclusión\n"
#~ "                              encajan con '/' (predeterminado)\n"
#~ "      --wildcards-match-slash los comodines de los patrones de exclusión\n"
#~ "                              no encajan con '/'\n"
#~ "  -P, --absolute-names        no elimina las '/'s iniciales de los "
#~ "nombres de\n"
#~ "                              fichero\n"
#~ "  -h, --dereference           vuelca en su lugar los ficheros a los que "
#~ "apuntan\n"
#~ "                              los enlaces simbólicos.\n"
#~ "      --no-recurse            evita descender automáticamente en "
#~ "directorios\n"
#~ "  -l, --one-file-system       permanece en el sistema de ficheros local\n"
#~ "                              cuando se crea el archivo\n"
#~ "  -K, --starting-file=NOMBRE  comienza en el fichero NOMBRE del archivo\n"

# # "más nuevos"->"más recientes". En el info de tar1.11.8 explica un poco más las
# # opciones --newer-*, sin limitar a "store", sino hablando en general de
# # cualquier operación. En el --newer-mtime debería ser --newer-mtime=DATE, y
# # dice que "limita la operación a los ficheros modificados después de la
# # fecha DATE"... ¿?. jmg
#~ msgid ""
#~ "  -N, --newer=DATE             only store files newer than DATE\n"
#~ "      --newer-mtime=DATE       compare date and time when data changed "
#~ "only\n"
#~ "      --after-date=DATE        same as -N\n"
#~ msgstr ""
#~ "  -N, --newer=FECHA           sólo almacena los ficheros más recientes "
#~ "que FECHA\n"
#~ "      --newer-mtime=FECHA     compara la fecha y hora en que los datos "
#~ "cambiaron\n"
#~ "      --after-date=FECHA      igual que -N\n"

#~ msgid ""
#~ "      --backup[=CONTROL]       backup before removal, choose version "
#~ "control\n"
#~ "      --suffix=SUFFIX          backup before removal, override usual "
#~ "suffix\n"
#~ msgstr ""
#~ "      --backup[=CONTROL]      copia de seguridad antes de eliminar, "
#~ "elige\n"
#~ "                              el control de versión\n"
#~ "      --suffix=SUFIJO         copia de seguridad antes de eliminar, pasa "
#~ "por\n"
#~ "                              alto el sufijo habitual\n"

# # print -> ¿muestra o imprime? Prefiero muestra, pero manténgase
# # siempre; ¡al menos en un mismo mensaje! gag
# Lo de "prolijamente" suena regular. En diffutils hay una laaarga discusión
# sobre ello. Yo usaría "verbosely"->"detalladamente" o "con detalle". jmg
# los bytes totales escritos -> el total de bytes escritos. nl
# O los bytes escritos en total, bien. gerardo
#~ msgid ""
#~ "\n"
#~ "Informative output:\n"
#~ "      --help            print this help, then exit\n"
#~ "      --version         print tar program version number, then exit\n"
#~ "  -v, --verbose         verbosely list files processed\n"
#~ "      --checkpoint      print directory names while reading the archive\n"
#~ "      --totals          print total bytes written while creating archive\n"
#~ "  -R, --block-number    show block number within archive with each "
#~ "message\n"
#~ "  -w, --interactive     ask for confirmation for every action\n"
#~ "      --confirmation    same as -w\n"
#~ msgstr ""
#~ "\n"
#~ "Salida de información:\n"
#~ "     --help           muestra esta ayuda, y finaliza\n"
#~ "     --version        informa de la versión y finaliza\n"
#~ " -v, --verbose        lista prolijamente los ficheros procesados\n"
#~ "     --checkpoint     muestra los nombres de directorio al leer el "
#~ "archivo\n"
#~ "     --totals         muestra los bytes escritos en total al crear el "
#~ "archivo\n"
#~ " -R, --block-number   muestra el número de bloque en el archivo con cada "
#~ "mensaje\n"
#~ " -w, --interactive    pide confirmación para cada acción\n"
#~ "     --confirmation   igual que -w\n"

# por defecto -> por omisión, de forma predeterminada
# HOST -> HUÉSPED, ANFITRIÓN (aquí estoy más perdido que el barco 'el
# arroz, ya lo sé; como con shell y script). gag
#~ msgid ""
#~ "\n"
#~ "GNU tar cannot read nor produce `--posix' archives.  If POSIXLY_CORRECT\n"
#~ "is set in the environment, GNU extensions are disallowed with `--posix'.\n"
#~ "Support for POSIX is only partially implemented, don't count on it yet.\n"
#~ "ARCHIVE may be FILE, HOST:FILE or USER@HOST:FILE; DATE may be a textual "
#~ "date\n"
#~ "or a file name starting with `/' or `.', in which case the file's date is "
#~ "used.\n"
#~ "*This* `tar' defaults to `-f%s -b%d'.\n"
#~ msgstr ""
#~ "\n"
#~ "GNU tar no puede leer ni generar archivos `--posix'. Si POSIXLY_CORRECT "
#~ "está\n"
#~ "definido en el entorno, las extensiones GNU se deshabilitan con `--"
#~ "posix'.\n"
#~ "El soporte para POSIX está sólo parcialmente implementado, no se debe "
#~ "contar \n"
#~ "con él aún.\n"
#~ "ARCHIVO puede ser FICHERO, HOST:FICHERO o USUARIO@HOST:FICHERO; FECHA "
#~ "puede ser\n"
#~ "una fecha textual, o un nombre de fichero que comience con `/' o con `.', "
#~ "en\n"
#~ "cuyo caso se utiliza la fecha del fichero.\n"
#~ "*Este* `tar' utiliza `-f%s -b%d' por omisión.\n"

# Nota aclaratoria: (Gerardo)
# Incluida no lleva tilde.
# Ni ruido ni huida ni güiro (un instrumento musical cubano).
# Sí se parte en in-clu-i-da, pero sin tilde. No existe el hiato.
# Mira en un diccionario `ruido' a ver si tiene tilde, y considera si
# no es el mismo caso (Rui-do no: ru-i-do).
#
# Más arriba has usado "implies"->"implica", así que aquí
# sería "implied by"->"implicada por", o modificar lo otro. jmg
# Pero es que implica suena bien pero implicada por suena fatal. sv
#~ msgid "Obsolete option, now implied by --blocking-factor"
#~ msgstr "Opción obsoleta, ahora incluida en --blocking-factor"

# Pregunta: ¿qué es reemplazado/a el nombre o la opción? sv
# Creo que es el nombre. fr
# # El nombre de la opción; lo que pasa es que en el mensaje en español
# # no se entiende muy bien. Quizá: nombre obsoleto de la opción
# # remplazado por -- ... gag
#~ msgid "Obsolete option name replaced by --blocking-factor"
#~ msgstr "Nombre de opción obsoleta reemplazado por --blocking-factor"

# # Ver msj. anterior
#~ msgid "Obsolete option name replaced by --read-full-records"
#~ msgstr "Nombre de opción obsoleta reemplazado por --read-full-records"

#~ msgid "Obsolete option name replaced by --touch"
#~ msgstr "Nombre de opción obsoleta reemplazado por --touch"

#~ msgid "Conflicting archive format options"
#~ msgstr "Opciones de formato de archivo en conflicto"

#~ msgid "Obsolete option name replaced by --absolute-names"
#~ msgstr "Nombre de opción obsoleta reemplazado por --absolute-names"

#~ msgid "Obsolete option name replaced by --block-number"
#~ msgstr "Nombre de opción obsoleta reemplazado por --block-number"

#~ msgid "Obsolete option name replaced by --backup"
#~ msgstr "Nombre de opción obsoleta reemplazado por --backup"

#~ msgid "Written by John Gilmore and Jay Fenlason."
#~ msgstr "Escrito por John Gilmore y Jay Fenlason."

# Acepto sugerencias para el `test suite'. sv
# "test suite"="paquete/conjunto de pruebas/análisis", en cualquier
# combinación. jmg
#~ msgid "Generate data files for GNU tar test suite.\n"
#~ msgstr "Genera ficheros de datos para el conjunto de pruebas de GNU tar.\n"

#~ msgid ""
#~ "If a long option shows an argument as mandatory, then it is mandatory\n"
#~ "for the equivalent short option also.\n"
#~ "\n"
#~ "  -l, --file-length=LENGTH   LENGTH of generated file\n"
#~ "  -p, --pattern=PATTERN      PATTERN is `default' or `zeros'\n"
#~ "      --help                 display this help and exit\n"
#~ "      --version              output version information and exit\n"
#~ msgstr ""
#~ "Los argumentos obligatorios para las opciones largas son también "
#~ "obligatorios\n"
#~ "para las opciones cortas.\n"
#~ "\n"
#~ "  -l, --file-length=LONGITUD  LONGITUD del fichero generado\n"
#~ "  -p, --pattern=PATRÓN        PATRÓN es `default' o `zeros'\n"
#~ "      --help                  muestra esta ayuda y sale\n"
#~ "      --version               informa de la versión y finaliza\n"

#~ msgid "Written by F. Pinard."
#~ msgstr "Escrito por François Pinard."

#~ msgid "Ambiguous pattern `%s'"
#~ msgstr "El patrón `%s' es ambiguo"

# Me encantaría poder incluir tos propuestas de usar el \372 ( aspa ) y
# el (C) , veremos si lo hacemos algún día. em+
# Estaría bien cambiar el '(C)' por '©', que es otro carácter de
# ISO-Latin1. Como los yanquis usan el ASCII (US ISO-646), que es de
# 7 bits, no lo pueden usar; nosotros sí. gerardo
# Pues eso: que si os encanta, ¿por qué no lo hacéis? ¿Cuál es el problema?
# Bueno, vale, de acuerdo... sv
#~ msgid "Copyright %d Free Software Foundation, Inc."
#~ msgstr "© %d Free Software Foundation, Inc."

#~ msgid ""
#~ "This is free software; see the source for copying conditions.  There is "
#~ "NO\n"
#~ "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR "
#~ "PURPOSE.\n"
#~ msgstr ""
#~ "Esto es software libre; vea el código fuente para las condiciones de "
#~ "copia.\n"
#~ "No hay NINGUNA garantía; ni siquiera de COMERCIABILIDAD o IDONEIDAD PARA "
#~ "UN\n"
#~ "FIN DETERMINADO.\n"

#~ msgid "Write to compression program short %lu bytes"
#~ msgstr "La escritura al programa de compresión acorta %lu bytes"

#~ msgid "Removing `%.*s' prefix from member names"
#~ msgstr "Eliminando el prefijo `%.*s' de los nombres"

#~ msgid "Archive contains future timestamp %s"
#~ msgstr "El archivo contiene la marca de tiempo en el futuro %s"

#~ msgid "%s: Cannot symlink %s %s"
#~ msgstr "%s: No se puede crear el enlace simbólico %s %s"

#~ msgid "Invalid group given on option"
#~ msgstr "Se ha especificado un grupo no válido en la opción"

#~ msgid "Invalid owner given on option"
#~ msgstr "Se ha especificado un propietario no válido en la opción"

#~ msgid "Cannot close file descriptor"
#~ msgstr "No se puede cerrar el descriptor de fichero"

#~ msgid "Cannot properly duplicate %s"
#~ msgstr "No se puede duplicar %s correctamente"

#~ msgid "(child) Pipe to stdin"
#~ msgstr "(proceso hijo) Se abre una tubería desde la entrada estándar"

#~ msgid "Archive to stdout"
#~ msgstr "Archivo hacia la salida estándar"

#~ msgid "((child)) Pipe to stdout"
#~ msgstr "((proceso hijo)) Se abre una tubería hacia la salida estándar"

#~ msgid "(grandchild) Pipe to stdin"
#~ msgstr "(proceso nieto) Se abre una tubería desde la entrada estándar"

#~ msgid "(child) Pipe to stdout"
#~ msgstr "(proceso hijo) Se vuelca el resultado por la salida estándar"

#~ msgid "((child)) Pipe to stdin"
#~ msgstr "((proceso hijo)) Se abre una tubería desde la entrada estándar"

#~ msgid "(grandchild) Pipe to stdout"
#~ msgstr "(proceso nieto) Se abre una tubería hacia la salida estándar"

#~ msgid "Only wrote %lu of %lu bytes to %s"
#~ msgstr "Sólo se escribieron %lu de %lu bytes en %s"

# FIXME: No queda claro si es al cerrar, cerrando, cierre, o qué. sv
#~ msgid "WARNING: %s: close (%d, %d)"
#~ msgstr "ATENCIÓN: %s: se cierra (%d, %d)"

#~ msgid "Cannot allocate memory for diff buffer of %lu bytes"
#~ msgstr ""
#~ "No se puede asignar memoria para el búfer de diferencias de %lu bytes"

# # Como has puesto más arriba: "EOF"->"Fin de fichero". jmg
#~ msgid "Unexpected EOF on archive file"
#~ msgstr "EOF inesperado en archivo"

# Lo mismo que con stat() em+
# seek() es otra función. seek = "hacer seek()" ¡Estos
# angloparlantes!
#~ msgid "Cannot seek to %s in file %s"
#~ msgstr "No se puede acceder a la posición %s en el fichero %s"

#~ msgid "Wrote %s of %s bytes to file %s"
#~ msgstr "Se escribieron %s de %s bytes en el fichero %s"

#~ msgid "lseek error at byte %s in file %s"
#~ msgstr "Error de lectura en el byte %s en el fichero %s"

# "se rellena" debería ser "rellenando". "se rellena" puede entenderse como
# varias cosas, no queda claro que es lo que se esta haciendo, podría indicar
# lo que se suele hacer.. =)   "rellenando con ceros" es perfecto y es
# exactamente lo que está escrito en el original. sv
#
# Que sí, reconozco que la traducción es un poco libre.
# Pero mi intención es que el programa diga lo que va haciendo, no lo que ya
# ha hecho. Ni siquiera el original es consistente en los modos verbales. sv
#~ msgid "File %s shrunk, padding with zeros"
#~ msgstr "El tamaño del fichero %s ha disminuido, se rellena con ceros"

# OK em+
# Can't = no se puede; couldn't: no se ha podido. gag
# O no se pudo. sv
# Esa forma verbal se debería usar para cosas ocurridas hace mucho más tiempo.
# No pude hacer la Primera Comunión vestido de hombre-rana, no he podido
# escribir esta frase en caracteres jeroglíficos. gag
#
#~ msgid "Cannot reposition archive file"
#~ msgstr "No se puede reposicionar el archivo"

#~ msgid "%s: Cannot change access and modification times"
#~ msgstr "%s: No se pueden cambiar las fechas de acceso y modificación"

#~ msgid "%s: Cannot lchown to uid %lu gid %lu"
#~ msgstr ""
#~ "%s: No se puede cambiar el propietario y grupo con `lchown' a uid %lu gid "
#~ "%lu"

#~ msgid "%s: Cannot chown to uid %lu gid %lu"
#~ msgstr ""
#~ "%s: No se puede cambiar el propietario y grupo con `chown' a uid %lu gid %"
#~ "lu"

#~ msgid "%s: lseek error at byte %s"
#~ msgstr "%s: error de desplazamiento en el byte %s"

#~ msgid "%s: Could only write %s of %s bytes"
#~ msgstr "%s: Sólo se pudieron escribir %s de %s bytes"

#~ msgid "Error while deleting %s"
#~ msgstr "Error al borrar %s"

# # Como has puesto más arriba: "EOF"->"Fin de fichero". jmg
#~ msgid "EOF in archive file"
#~ msgstr "EOF en el archivo"

#~ msgid "Only wrote %lu of %lu bytes to file %s"
#~ msgstr "Sólo se escribieron %lu de %lu bytes al archivo %s"

#~ msgid "Renaming previous %s to %s\n"
#~ msgstr "Se renombra el anterior %s como %s\n"

#~ msgid "%s: Cannot rename for backup"
#~ msgstr "%s: No se puede renombrar para hacer una copia de seguridad"

#~ msgid "%s: Cannot rename from backup"
#~ msgstr "%s: No se puede renombrar de la copia de seguridad"

# FIXME. No es traducible.
#~ msgid "Cannot %s %s"
#~ msgstr "No se puede %s %s"

#~ msgid "Read error at byte %s reading %lu bytes in file %s"
#~ msgstr "Error de lectura en el byte %s leyendo %lu bytes en el fichero %s"

# Antes de que nadie diga nada:
#
# Si a alguien no le gusta la palabra tubería (que aparece en algunos
# libros sobre MS-DOS y es la que venimos usando desde el principio) que
# haga una propuesta seria de cambio, pero que sepa que abriríamos la caja
# de Pandora, pues hay muchas palabras posibles para pipe: tubería,
# conducto, cañería, canal, etc.
#
# En cuanto a poner (pipe) entre paréntesis, es una mala costumbre que
# deberíamos desterrar ya. Eso se hace en los libros la primera vez, pero
# aquí no sólo no hay primera vez, sino que el mismo mensaje puede
# aparecer *varias* veces, y entonces sí que es una paliza.
# Ejemplo de paliza: "tubería rota" en libc. Sale muchísimo y no es
# cuestión de ver (pipe) cuarenta veces al día...
#~ msgid "Cannot open pipe"
#~ msgstr "No se puede abrir la tubería"

#~ msgid "Cannot open archive %s"
#~ msgstr "No se puede abrir el archivo %s"

#~ msgid "Cannot exec %s"
#~ msgstr "No se puede ejecutar %s"

# lo mismo de antes. sv
#~ msgid "Child cannot fork"
#~ msgstr "El proceso hijo no puede bifurcarse"

#~ msgid "Cannot read from compression program"
#~ msgstr "No se puede leer del programa de compresión"

#~ msgid "Cannot write to compression program"
#~ msgstr "No se puede escribir al programa de compresión"

#~ msgid "Cannot write to %s"
#~ msgstr "No se puede escribir en %s"

#~ msgid "Read error on %s"
#~ msgstr "Error de lectura en %s"

#~ msgid "WARNING: Cannot truncate %s"
#~ msgstr "ATENCIÓN: No se puede truncar %s"

#~ msgid "While waiting for child"
#~ msgstr "Mientras se esperaba al hijo"

# Estos errores son para el debug del programa. A quien le pueda
# interesar sabe lo que quiere decir em+
# ¡Otras veces se ha puesto bifurcar sin el (fork)! Esto es difícil,
# porque también podría ponerse: "No se puede hacer fork()", ya que
# fork() es un punto de entrada a una primitiva Unix; vaya, una
# función. gag
# FIXME. Hablar con el autor.
# en fileutils-3.16.es.po, el autor cambió el "Cannot fork" por "fork
# system call failed", con lo que podría pasar lo mismo ahora. Si no
# hay cambios, yo preferiría: "¡No se puede crear proceso hijo (fork)!"
# jmg
#~ msgid "Cannot fork!"
#~ msgstr "¡No se puede bifurcar!"

#~ msgid "Cannot exec a shell %s"
#~ msgstr "No se puede ejecutar un shell %s"

#~ msgid "Cannot open %s"
#~ msgstr "No se puede abrir %s"

#~ msgid "Cannot read %s"
#~ msgstr "No se puede leer %s"

#~ msgid "Error while closing %s"
#~ msgstr "Error al cerrar %s"

#~ msgid "Cannot read link %s"
#~ msgstr "No se puede leer el enlace %s"

#~ msgid "Could not rewind archive file for verify"
#~ msgstr "No se pudo rebobinar el archivo para verificar"

#~ msgid "Removing leading `/' from archive names"
#~ msgstr "Eliminando la `/' inicial de los nombres del archivo"

#~ msgid "Cannot add file %s"
#~ msgstr "No se puede añadir el fichero %s"

#~ msgid "Cannot add directory %s"
#~ msgstr "No se puede añadir el directorio %s"

#~ msgid "Cannot open directory %s"
#~ msgstr "No se puede abrir el directorio %s"

#~ msgid "%s: Could not write to file"
#~ msgstr "%s: No se pudo escribir en el fichero"

#~ msgid "%s: Could not create file"
#~ msgstr "%s: No se pudo crear el fichero"

#~ msgid "%s: Error while closing"
#~ msgstr "%s: Error al cerrar"

#~ msgid "%s: Could not make node"
#~ msgstr "%s: No se pudo crear el nodo"

# Pongo comitas porque no es una palabra española.
# A quien no le guste que abra el debate sobre cuándo sí y cuándo no
# deben ponerse comitas en es@li.org.
#~ msgid "%s: Could not make fifo"
#~ msgstr "%s: No se pudo crear el `fifo'"

#~ msgid "%s: Could not create directory"
#~ msgstr "%s: No se pudo crear el directorio"

#~ msgid "Added write and execute permission to directory %s"
#~ msgstr "Añadidos permisos de escritura y ejecución al directorio %s"

#~ msgid "Cannot open file %s"
#~ msgstr "No se puede abrir el fichero %s"

#~ msgid ""
#~ "\n"
#~ "Usage: %s [OPTION]... [FILE]...\n"
#~ msgstr ""
#~ "\n"
#~ "Modo de empleo: %s [OPCIÓN]... [FICHERO]...\n"

# Me encantaría poder incluir tos propuestas de usar el \372 ( aspa ) y
# el (C) , veremos si lo hacemos algún día. em+
# Estaría bien cambiar el '(C)' por '©', que es otro carácter de
# ISO-Latin1. Como los yanquis usan el ASCII (US ISO-646), que es de
# 7 bits, no lo pueden usar; nosotros sí. Incluso "Copyright" por
# "Derechos de copia". Ya lo de FSF por Fundación del Logical Libre
# es demasiado, ¿verdad? :-) gag
# < ¿Puede alguien explicarme por qué no se hace ya, o no se ha hecho
# antes? ¿Qué diferencia hay, bajo el punto de vista de ser caracteres
# válidos, entre 'ó' y 'ß' o entre 'ñ' y '¤' o entre 'º' y '©' o entre
# '¿' y '¼'? Lo único que se me ocurre es que es algo difícil introducir
# esos caracteres porque no están en el teclado del PC. No hay más que
# irse a una terminal o teclado con tecla de Componer o usar el Emacs con
# C-q ooo (ooo = número octal) con la tabla (man iso_8859_1) al lado.
# ¿Alguien tiene otra explicación?
#
# Se ven peor. Estas cosas deben ser bien legibles desde consola, y el
# Copyright ese © no se ve demasiado bien. sv
# Nostoy dacuerdo. Protesto enérgicamente. gerardo
# No tendría ningún inconveniente en usar ese carácter si el objetivo final
# fuera que apareciese por una láser de 300ppp, pero el objetivo es que se
# vea por consola, y con la poca resolución que tiene no es un Copyright
# hecho y derecho sino una C dentro de algo que parece más bien un cuadrado
# con los bordes redondeados. Incluso el (C) Sinclair Research...
# se veía mejor que el de los PCs. sv
# Bueno, eso es un problema del tipo de letra, no del traductor. Además (C)
# es el sucedáneo legal del ©, como TeX cuando no se puede poner como \TeX{}.
# Pero es un sucedáneo, no el original. Es un copyright light. A más a más,
# como dicen los catalanes, que ya aparece delante la palabra Copyright, por
# lo que no debe haber ambigüedad. gerardo
#
# Hombre, el objetivo del traductor es que se entienda, y por ser (C)
# el "sucedáneo legal", como tú le dices, es razonable usarlo.
# En cambio la "ñ" no tiene sucedáneo legal, por lo que poner
# "espagna" o "espa~na" sería completamente inaceptable.
# Y si lo miras bien, todos son sucedáneos, pues las letras no "son"
# pixelizadas. Lo que yo digo es que © no es un sucedáneo más bonito que (C)
# para el símbolo de copyright. sv
#~ msgid ""
#~ "\n"
#~ "Copyright 1988, 92,93,94,95,96,97,98, 1999 Free Software Foundation, "
#~ "Inc.\n"
#~ msgstr ""
#~ "\n"
#~ "Copyright 1988, 92,93,94,95,96,97,98, 1999 Free Software Foundation, "
#~ "Inc.\n"

# Tengo que plantearme seriamente si pongo "fin de fichero" siempre
# siempre en vez de EOF. sv
#
# Según gag y jmg, hay que decir: "no está en un límite de bloque", pues
# no estamos hablando de un bloque concreto (el bloque) sino de uno cualquiera.
# FIXME: Entonces tal vez el original debería decir "on a block boundary". sv
#~ msgid "Archive %s EOF not on block boundary"
#~ msgstr "El fin del archivo %s no está en un límite de bloque"

# ¿por qué convertir las oraciones unimembres en bimembres? Ya vi
# otro caso en donde se hace y no veo por qué. Bien podría quedar como:
# "Nombre de fichero %s%s demasiado largo". nl
# Algunas de esas frases suenan a "indio" sv
# Hombre, esto no es una novela (del Oeste :-), la forma "india" es
# más literal y más corta, lo que quizá sea más apropiado para mensajes
# concisos como éstos; pero en realidad es más agradable de leer así.
# El traductor manda. gerardo
#~ msgid "File name %s%s too long"
#~ msgstr "El nombre de fichero %s%s es demasiado largo"

#~ msgid "Hmm, this doesn't look like a tar archive"
#~ msgstr "Mmm, esto no parece un archivo tar"

#~ msgid "Skipping to next file header"
#~ msgstr "Saltando a la siguiente cabecera de fichero"

#~ msgid "Cannot determine initial working directory"
#~ msgstr "No se puede determinar el directorio de trabajo inicial"

#~ msgid "Could not get current directory"
#~ msgstr "No se pudo obtener el directorio actual"

#~ msgid "Could not get current directory: %s"
#~ msgstr "No se pudo obtener el directorio actual: %s"

#~ msgid "File name %s/%s too long"
#~ msgstr "El nombre del fichero %s/%s es demasiado largo"

#~ msgid "%s: out-of-range timestamp `%s' ignored"
#~ msgstr "%s: no se tendrá en cuenta la marca de fecha `%s' fuera de rango"

#~ msgid "Cannot chdir to %s"
#~ msgstr "No se puede cambiar al directorio %s"

#~ msgid "Arithmetic overflow"
#~ msgstr "Sobrepasamiento aritmético"

# Se vuelca la *memoria* del proceso en un fichero llamado `core'.
#~ msgid " (core dumped)"
#~ msgstr " (memoria volcada)"

#~ msgid "Data differs"
#~ msgstr "Los datos son distintos"

#~ msgid "File does not exist"
#~ msgstr "El fichero no existe"

# Uff, a lo mejor se asusta el usuario si ponemos 'no se pudo leer con stat()
# el estado del fichero em+
# stat() es una primitiva Unix que acaba de fallar; también podría
# ser: "No se puede hacer stat() del fichero %s", o "stat() ha fallado..."
# Aunque tal como está es más descriptivo para el neófito, desde
# luego. gag
#~ msgid "Cannot stat file %s"
#~ msgstr "No se puede leer el estado del fichero %s"

# Nota: En Unix, se llama fichero *regular* al que no es ni un directorio,
# ni un dispositivo (de bloques o de caracteres) ni un fifo, etc.
# Uno puede pensar que son los ficheros "normales", pero eso depende,
# pues un directorio es de lo más "normal"...
#~ msgid "Not a regular file"
#~ msgstr "No es un fichero regular"

#~ msgid "Does not exist"
#~ msgstr "No existe"

#~ msgid "No such file or directory"
#~ msgstr "No existe el fichero o el directorio"

#~ msgid "Mode or device-type changed"
#~ msgstr "El modo o el tipo de dispositivo ha cambiado"

#~ msgid "No longer a directory"
#~ msgstr "Ya no es un directorio"

# Lo mismo. sv
# Sugerencia: Sendero -> Ruta, camino. sv
# Lo siento, no me salía la palabra. Esperaba correción. fr
# Siempre he estado usando ruta en otras traducciones em+
# # Esta vez sugiero "camino", por seguir la terminología de
# # Microsoft, ya que da lo mismo, ¿no? gag
# Quedaría igualmente claro si no se hace referencia a ruta:
# "... de los nombres absolutos en el archivo". jmg
#~ msgid "Removing leading `/' from absolute path names in the archive"
#~ msgstr ""
#~ "Borrando la `/' inicial de los nombres absolutos de ruta en el archivo"

#~ msgid "Amount actually written is (I hope) %d.\n"
#~ msgstr "La cantidad realmente escrita (esperemos) es %d.\n"

#~ msgid "%d at %d\n"
#~ msgstr "%d en %d\n"

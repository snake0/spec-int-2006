/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of Typemap.xs. Do not edit this file, edit Typemap.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Typemap.xs"

/*
   XS code to test the typemap entries

   Copyright (C) 2001 Tim Jenness.
   All Rights Reserved

*/

#include "EXTERN.h"   /* std perl include */
#include "perl.h"     /* std perl include */
#include "XSUB.h"     /* XSUB include */

/* Prototypes for external functions */
FILE * xsfopen( const char * );
int xsfclose( FILE * );
int xsfprintf( FILE *, const char *);

/* Type definitions required for the XS typemaps */
typedef SV * SVREF; /* T_SVREF */
typedef int SysRet; /* T_SYSRET */
typedef int Int;    /* T_INT */
typedef int intRef; /* T_PTRREF */
typedef int intObj; /* T_PTROBJ */
typedef int intRefIv; /* T_REF_IV_PTR */
typedef int intArray; /* T_ARRAY */
typedef short shortOPQ;   /* T_OPAQUE */
typedef int intOpq;   /* T_OPAQUEPTR */

/* A structure to test T_OPAQUEPTR */
struct t_opaqueptr {
  int a;
  int b;
  double c;
};

typedef struct t_opaqueptr astruct;

/* Some static memory for the tests */
static I32 xst_anint;
static intRef xst_anintref;
static intObj xst_anintobj;
static intRefIv xst_anintrefiv;
static intOpq xst_anintopq;

/* Helper functions */

/* T_ARRAY - allocate some memory */
intArray * intArrayPtr( int nelem ) {
    intArray * array;
    New(0, array, nelem, intArray);
    return array;
}


#line 66 "Typemap.c"
XS(XS_XS__Typemap_T_SV); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_SV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_SV(sv)");
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 80 "Typemap.xs"
  /* create a new sv for return that is a copy of the input
     do not simply copy the pointer since the SV will be marked
     mortal by the INPUT typemap when it is pushed back onto the stack */
  RETVAL = sv_mortalcopy( sv );
  /* increment the refcount since the default INPUT typemap mortalizes
     by default and we don't want to decrement the ref count twice
     by mistake */
  SvREFCNT_inc(RETVAL);
#line 85 "Typemap.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_SVREF); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_SVREF)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_SVREF(svref)");
    {
	SVREF	svref;
	SVREF	RETVAL;

	if (SvROK(ST(0)))
	    svref = (SV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "svref is not a reference");
#line 101 "Typemap.xs"
  RETVAL = svref;
#line 108 "Typemap.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_AVREF); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_AVREF)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_AVREF(av)");
    {
	AV *	av;
	AV *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVAV)
	    av = (AV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "av is not an array reference");
#line 116 "Typemap.xs"
  RETVAL = av;
#line 131 "Typemap.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_HVREF); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_HVREF)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_HVREF(hv)");
    {
	HV *	hv;
	HV *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    hv = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "hv is not a hash reference");
#line 131 "Typemap.xs"
  RETVAL = hv;
#line 154 "Typemap.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_CVREF); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_CVREF)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_CVREF(cv)");
    {
	CV *	cv;
	CV *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVCV)
	    cv = (CV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "cv is not a code reference");
#line 147 "Typemap.xs"
  RETVAL = cv;
#line 177 "Typemap.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_SYSRET_pass); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_SYSRET_pass)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_SYSRET_pass()");
    {
	SysRet	RETVAL;
#line 174 "Typemap.xs"
  RETVAL = 0;
#line 194 "Typemap.c"
	ST(0) = sv_newmortal();
	if (RETVAL != -1) {
	    if (RETVAL == 0)
		sv_setpvn(ST(0), "0 but true", 10);
	    else
		sv_setiv(ST(0), (IV)RETVAL);
	}
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_SYSRET_fail); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_SYSRET_fail)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_SYSRET_fail()");
    {
	SysRet	RETVAL;
#line 183 "Typemap.xs"
  RETVAL = -1;
#line 216 "Typemap.c"
	ST(0) = sv_newmortal();
	if (RETVAL != -1) {
	    if (RETVAL == 0)
		sv_setpvn(ST(0), "0 but true", 10);
	    else
		sv_setiv(ST(0), (IV)RETVAL);
	}
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_UV); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_UV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_UV(uv)");
    {
	unsigned int	uv = (unsigned int)SvUV(ST(0));
	unsigned int	RETVAL;
	dXSTARG;
#line 197 "Typemap.xs"
  RETVAL = uv;
#line 240 "Typemap.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_IV); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_IV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_IV(iv)");
    {
	long	iv = (long)SvIV(ST(0));
	long	RETVAL;
	dXSTARG;
#line 212 "Typemap.xs"
  RETVAL = iv;
#line 258 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_ENUM); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_ENUM)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_ENUM()");
    {
	svtype	RETVAL;
	dXSTARG;
#line 239 "Typemap.xs"
  RETVAL = SVt_PVHV;
#line 275 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_BOOL); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_BOOL)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_BOOL(in)");
    {
	bool	in = (bool)SvTRUE(ST(0));
	bool	RETVAL;
#line 254 "Typemap.xs"
  RETVAL = in;
#line 292 "Typemap.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_U_SHORT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_U_SHORT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_U_SHORT(in)");
    {
	U16	in = (unsigned short)SvUV(ST(0));
	U16	RETVAL;
	dXSTARG;
#line 284 "Typemap.xs"
  RETVAL = in;
#line 311 "Typemap.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_U_LONG); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_U_LONG)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_U_LONG(in)");
    {
	U32	in = (unsigned long)SvUV(ST(0));
	U32	RETVAL;
	dXSTARG;
#line 309 "Typemap.xs"
  RETVAL = in;
#line 329 "Typemap.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_CHAR); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_CHAR)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_CHAR(in)");
    {
	char	in = (char)*SvPV_nolen(ST(0));
	char	RETVAL;
	dXSTARG;
#line 323 "Typemap.xs"
  RETVAL = in;
#line 347 "Typemap.c"
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_U_CHAR); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_U_CHAR)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_U_CHAR(in)");
    {
	unsigned char	in = (unsigned char)SvUV(ST(0));
	unsigned char	RETVAL;
	dXSTARG;
#line 338 "Typemap.xs"
  RETVAL = in;
#line 365 "Typemap.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_FLOAT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_FLOAT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_FLOAT(in)");
    {
	float	in = (float)SvNV(ST(0));
	float	RETVAL;
	dXSTARG;
#line 354 "Typemap.xs"
  RETVAL = in;
#line 383 "Typemap.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_NV); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_NV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_NV(in)");
    {
	NV	in = (NV)SvNV(ST(0));
	NV	RETVAL;
	dXSTARG;
#line 370 "Typemap.xs"
  RETVAL = in;
#line 401 "Typemap.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_DOUBLE); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_DOUBLE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_DOUBLE(in)");
    {
	double	in = (double)SvNV(ST(0));
	double	RETVAL;
	dXSTARG;
#line 385 "Typemap.xs"
  RETVAL = in;
#line 419 "Typemap.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_PV); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_PV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_PV(in)");
    {
	char *	in = (char *)SvPV_nolen(ST(0));
	char *	RETVAL;
	dXSTARG;
#line 399 "Typemap.xs"
  RETVAL = in;
#line 437 "Typemap.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_PTR_OUT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_PTR_OUT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_PTR_OUT(in)");
    {
	int	in = (int)SvIV(ST(0));
	void *	RETVAL;
	dXSTARG;
#line 417 "Typemap.xs"
  xst_anint = in;
  RETVAL = &xst_anint;
#line 456 "Typemap.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_PTR_IN); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_PTR_IN)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_PTR_IN(ptr)");
    {
	void *	ptr = INT2PTR(void *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;
#line 428 "Typemap.xs"
  RETVAL = *(int *)ptr;
#line 474 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_PTRREF_OUT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_PTRREF_OUT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_PTRREF_OUT(in)");
    {
	intRef	in = (intRef)SvIV(ST(0));
	intRef *	RETVAL;
#line 451 "Typemap.xs"
  xst_anintref = in;
  RETVAL = &xst_anintref;
#line 492 "Typemap.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), Nullch, (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_PTRREF_IN); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_PTRREF_IN)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_PTRREF_IN(ptr)");
    {
	intRef *	ptr;
	intRef	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ptr = INT2PTR(intRef *,tmp);
	}
	else
	    Perl_croak(aTHX_ "ptr is not a reference");
#line 462 "Typemap.xs"
  RETVAL = *ptr;
#line 518 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_PTROBJ_OUT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_PTROBJ_OUT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_PTROBJ_OUT(in)");
    {
	intObj	in = (intObj)SvIV(ST(0));
	intObj *	RETVAL;
#line 489 "Typemap.xs"
  xst_anintobj = in;
  RETVAL = &xst_anintobj;
#line 536 "Typemap.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "intObjPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_intObjPtr_T_PTROBJ_IN); /* prototype to pass -Wmissing-prototypes */
XS(XS_intObjPtr_T_PTROBJ_IN)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: intObjPtr::T_PTROBJ_IN(ptr)");
    {
	intObj *	ptr;
	intObj	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "intObjPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ptr = INT2PTR(intObj *,tmp);
	}
	else
	    Perl_croak(aTHX_ "ptr is not of type intObjPtr");
#line 502 "Typemap.xs"
  RETVAL = *ptr;
#line 562 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_REF_IV_PTR_OUT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_REF_IV_PTR_OUT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_REF_IV_PTR_OUT(in)");
    {
	intRefIv	in = (intRefIv)SvIV(ST(0));
	intRefIv *	RETVAL;
#line 532 "Typemap.xs"
  xst_anintrefiv = in;
  RETVAL = &xst_anintrefiv;
#line 580 "Typemap.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "intRefIvPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_intRefIvPtr_T_REF_IV_PTR_IN); /* prototype to pass -Wmissing-prototypes */
XS(XS_intRefIvPtr_T_REF_IV_PTR_IN)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: intRefIvPtr::T_REF_IV_PTR_IN(ptr)");
    {
	intRefIv *	ptr;
	intRefIv	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "intRefIvPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ptr = INT2PTR(intRefIv *, tmp);
	}
	else
	    Perl_croak(aTHX_ "ptr is not of type intRefIvPtr");
#line 545 "Typemap.xs"
  RETVAL = *ptr;
#line 606 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_OPAQUEPTR_IN); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUEPTR_IN)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_OPAQUEPTR_IN(val)");
    {
	intOpq	val = (intOpq)SvIV(ST(0));
	intOpq *	RETVAL;
	dXSTARG;
#line 588 "Typemap.xs"
  xst_anintopq = val;
  RETVAL = &xst_anintopq;
#line 625 "Typemap.c"
	XSprePUSH; PUSHp((char *)RETVAL, sizeof(*RETVAL));
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_OPAQUEPTR_OUT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUEPTR_OUT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_OPAQUEPTR_OUT(ptr)");
    {
	intOpq *	ptr = (intOpq *)SvPV_nolen(ST(0));
	intOpq	RETVAL;
	dXSTARG;
#line 597 "Typemap.xs"
  RETVAL = *ptr;
#line 643 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_OPAQUEPTR_OUT_short); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUEPTR_OUT_short)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_OPAQUEPTR_OUT_short(ptr)");
    {
	shortOPQ *	ptr = (shortOPQ *)SvPV_nolen(ST(0));
	short	RETVAL;
	dXSTARG;
#line 605 "Typemap.xs"
  RETVAL = *ptr;
#line 661 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_OPAQUEPTR_IN_struct); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUEPTR_IN_struct)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_OPAQUEPTR_IN_struct(a, b, c)");
    {
	int	a = (int)SvIV(ST(0));
	int	b = (int)SvIV(ST(1));
	double	c = (double)SvNV(ST(2));
#line 616 "Typemap.xs"
  struct t_opaqueptr test;
#line 679 "Typemap.c"
	astruct *	RETVAL;
	dXSTARG;
#line 618 "Typemap.xs"
  test.a = a;
  test.b = b;
  test.c = c;
  RETVAL = &test;
#line 687 "Typemap.c"
	XSprePUSH; PUSHp((char *)RETVAL, sizeof(*RETVAL));
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_OPAQUEPTR_OUT_struct); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUEPTR_OUT_struct)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_OPAQUEPTR_OUT_struct(test)");
    SP -= items;
    {
	astruct *	test = (astruct *)SvPV_nolen(ST(0));
#line 629 "Typemap.xs"
  XPUSHs(sv_2mortal(newSViv(test->a)));
  XPUSHs(sv_2mortal(newSViv(test->b)));
  XPUSHs(sv_2mortal(newSVnv(test->c)));
#line 706 "Typemap.c"
	PUTBACK;
	return;
    }
}

XS(XS_XS__Typemap_T_OPAQUE_IN); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUE_IN)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_OPAQUE_IN(val)");
    {
	int	val = (int)SvIV(ST(0));
	shortOPQ	RETVAL;
	dXSTARG;
#line 657 "Typemap.xs"
  RETVAL = (shortOPQ)val;
#line 724 "Typemap.c"
	XSprePUSH; PUSHp((char *)&RETVAL, sizeof(RETVAL));
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_OPAQUE_OUT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUE_OUT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_OPAQUE_OUT(val)");
    {
	shortOPQ	val = *(shortOPQ *)SvPV_nolen(ST(0));
	IV	RETVAL;
	dXSTARG;
#line 665 "Typemap.xs"
  RETVAL = (IV)val;
#line 742 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_OPAQUE_array); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUE_array)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_OPAQUE_array(a, b, c)");
    {
	int	a = (int)SvIV(ST(0));
	int	b = (int)SvIV(ST(1));
	int	c = (int)SvIV(ST(2));
#line 694 "Typemap.xs"
  int array[3];
#line 760 "Typemap.c"
	int *	RETVAL;
#line 696 "Typemap.xs"
  array[0] = a;
  array[1] = b;
  array[2] = c;
  RETVAL = array;
#line 767 "Typemap.c"
	ST(0) = sv_newmortal();
	sv_setpvn(ST(0), (char *)RETVAL, 3 * sizeof(int));
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_ARRAY)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_ARRAY(dummy, array, ...)");
    {
	int	dummy = 0;
	intArray *	array;
#line 770 "Typemap.xs"
  U32 size_RETVAL;
#line 785 "Typemap.c"
	intArray *	RETVAL;

	U32 ix_array = 1;
	array = intArrayPtr(items -= 1);
	while (items--) {
	    	array[ix_array - 1] = (int)SvIV(ST(ix_array));
	    ix_array++;
	}
        /* this is the number of elements in the array */
        ix_array -= 1;
#line 772 "Typemap.xs"
  dummy += 0; /* Fix -Wall */
  size_RETVAL = ix_array;
  RETVAL = array;
#line 800 "Typemap.c"
        {
	    U32 ix_RETVAL;
	    EXTEND(SP,size_RETVAL);
	    for (ix_RETVAL = 0; ix_RETVAL < size_RETVAL; ix_RETVAL++) {
		ST(ix_RETVAL) = sv_newmortal();
		sv_setiv(ST(ix_RETVAL), (IV)RETVAL[ix_RETVAL]);
	    }
        }
#line 778 "Typemap.xs"
  Safefree(array);
  XSRETURN(size_RETVAL);
#line 812 "Typemap.c"
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_STDIO_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_STDIO_open)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_STDIO_open(file)");
    {
	const char *	file = (const char *)SvPV_nolen(ST(0));
	FILE *	RETVAL;
#line 793 "Typemap.xs"
  RETVAL = xsfopen( file );
#line 828 "Typemap.c"
	ST(0) = sv_newmortal();
	{
	    GV *gv = newGVgen("XS::Typemap");
	    PerlIO *fp = PerlIO_importFILE(RETVAL,0);
	    if ( fp && do_open(gv, "+<&", 3, FALSE, 0, 0, fp) )
		sv_setsv(ST(0), sv_bless(newRV((SV*)gv), gv_stashpv("XS::Typemap",1)));
	    else
		ST(0) = &PL_sv_undef;
	}
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_STDIO_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_STDIO_close)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_STDIO_close(f)");
    {
	PerlIO *	f = IoIFP(sv_2io(ST(0)));
#line 801 "Typemap.xs"
  FILE * stream;
#line 852 "Typemap.c"
	SysRet	RETVAL;
#line 803 "Typemap.xs"
  /* Get the FILE* */
  stream = PerlIO_findFILE( f );  
  RETVAL = xsfclose( stream );
  /* Release the FILE* from the PerlIO system so that we do
     not close the file twice */
  PerlIO_releaseFILE(f,stream);
#line 861 "Typemap.c"
	ST(0) = sv_newmortal();
	if (RETVAL != -1) {
	    if (RETVAL == 0)
		sv_setpvn(ST(0), "0 but true", 10);
	    else
		sv_setiv(ST(0), (IV)RETVAL);
	}
    }
    XSRETURN(1);
}

XS(XS_XS__Typemap_T_STDIO_print); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_STDIO_print)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: XS::Typemap::T_STDIO_print(stream, string)");
    {
	FILE *	stream = PerlIO_findFILE(IoIFP(sv_2io(ST(0))));
	const char *	string = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;
#line 817 "Typemap.xs"
  RETVAL = xsfprintf( stream, string );
#line 886 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_XS__Typemap); /* prototype to pass -Wmissing-prototypes */
XS(boot_XS__Typemap)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("XS::Typemap::T_SV", XS_XS__Typemap_T_SV, file);
        newXS("XS::Typemap::T_SVREF", XS_XS__Typemap_T_SVREF, file);
        newXS("XS::Typemap::T_AVREF", XS_XS__Typemap_T_AVREF, file);
        newXS("XS::Typemap::T_HVREF", XS_XS__Typemap_T_HVREF, file);
        newXS("XS::Typemap::T_CVREF", XS_XS__Typemap_T_CVREF, file);
        newXS("XS::Typemap::T_SYSRET_pass", XS_XS__Typemap_T_SYSRET_pass, file);
        newXS("XS::Typemap::T_SYSRET_fail", XS_XS__Typemap_T_SYSRET_fail, file);
        newXS("XS::Typemap::T_UV", XS_XS__Typemap_T_UV, file);
        newXS("XS::Typemap::T_IV", XS_XS__Typemap_T_IV, file);
        newXS("XS::Typemap::T_ENUM", XS_XS__Typemap_T_ENUM, file);
        newXS("XS::Typemap::T_BOOL", XS_XS__Typemap_T_BOOL, file);
        newXS("XS::Typemap::T_U_SHORT", XS_XS__Typemap_T_U_SHORT, file);
        newXS("XS::Typemap::T_U_LONG", XS_XS__Typemap_T_U_LONG, file);
        newXS("XS::Typemap::T_CHAR", XS_XS__Typemap_T_CHAR, file);
        newXS("XS::Typemap::T_U_CHAR", XS_XS__Typemap_T_U_CHAR, file);
        newXS("XS::Typemap::T_FLOAT", XS_XS__Typemap_T_FLOAT, file);
        newXS("XS::Typemap::T_NV", XS_XS__Typemap_T_NV, file);
        newXS("XS::Typemap::T_DOUBLE", XS_XS__Typemap_T_DOUBLE, file);
        newXS("XS::Typemap::T_PV", XS_XS__Typemap_T_PV, file);
        newXS("XS::Typemap::T_PTR_OUT", XS_XS__Typemap_T_PTR_OUT, file);
        newXS("XS::Typemap::T_PTR_IN", XS_XS__Typemap_T_PTR_IN, file);
        newXS("XS::Typemap::T_PTRREF_OUT", XS_XS__Typemap_T_PTRREF_OUT, file);
        newXS("XS::Typemap::T_PTRREF_IN", XS_XS__Typemap_T_PTRREF_IN, file);
        newXS("XS::Typemap::T_PTROBJ_OUT", XS_XS__Typemap_T_PTROBJ_OUT, file);
        newXS("intObjPtr::T_PTROBJ_IN", XS_intObjPtr_T_PTROBJ_IN, file);
        newXS("XS::Typemap::T_REF_IV_PTR_OUT", XS_XS__Typemap_T_REF_IV_PTR_OUT, file);
        newXS("intRefIvPtr::T_REF_IV_PTR_IN", XS_intRefIvPtr_T_REF_IV_PTR_IN, file);
        newXS("XS::Typemap::T_OPAQUEPTR_IN", XS_XS__Typemap_T_OPAQUEPTR_IN, file);
        newXS("XS::Typemap::T_OPAQUEPTR_OUT", XS_XS__Typemap_T_OPAQUEPTR_OUT, file);
        newXS("XS::Typemap::T_OPAQUEPTR_OUT_short", XS_XS__Typemap_T_OPAQUEPTR_OUT_short, file);
        newXS("XS::Typemap::T_OPAQUEPTR_IN_struct", XS_XS__Typemap_T_OPAQUEPTR_IN_struct, file);
        newXS("XS::Typemap::T_OPAQUEPTR_OUT_struct", XS_XS__Typemap_T_OPAQUEPTR_OUT_struct, file);
        newXS("XS::Typemap::T_OPAQUE_IN", XS_XS__Typemap_T_OPAQUE_IN, file);
        newXS("XS::Typemap::T_OPAQUE_OUT", XS_XS__Typemap_T_OPAQUE_OUT, file);
        newXS("XS::Typemap::T_OPAQUE_array", XS_XS__Typemap_T_OPAQUE_array, file);
        newXS("XS::Typemap::T_ARRAY", XS_XS__Typemap_T_ARRAY, file);
        newXS("XS::Typemap::T_STDIO_open", XS_XS__Typemap_T_STDIO_open, file);
        newXS("XS::Typemap::T_STDIO_close", XS_XS__Typemap_T_STDIO_close, file);
        newXS("XS::Typemap::T_STDIO_print", XS_XS__Typemap_T_STDIO_print, file);
    XSRETURN_YES;
}


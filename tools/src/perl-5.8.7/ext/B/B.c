/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of B.xs. Do not edit this file, edit B.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "B.xs"
/*	B.xs
 *
 *	Copyright (c) 1996 Malcolm Beattie
 *
 *	You may distribute under the terms of either the GNU General Public
 *	License or the Artistic License, as specified in the README file.
 *
 */

#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifdef PerlIO
typedef PerlIO * InputStream;
#else
typedef FILE * InputStream;
#endif


static char *svclassnames[] = {
    "B::NULL",
    "B::IV",
    "B::NV",
    "B::RV",
    "B::PV",
    "B::PVIV",
    "B::PVNV",
    "B::PVMG",
    "B::BM",
#if PERL_VERSION >= 9
    "B::GV",
#endif
    "B::PVLV",
    "B::AV",
    "B::HV",
    "B::CV",
#if PERL_VERSION <= 8
    "B::GV",
#endif
    "B::FM",
    "B::IO",
};

typedef enum {
    OPc_NULL,	/* 0 */
    OPc_BASEOP,	/* 1 */
    OPc_UNOP,	/* 2 */
    OPc_BINOP,	/* 3 */
    OPc_LOGOP,	/* 4 */
    OPc_LISTOP,	/* 5 */
    OPc_PMOP,	/* 6 */
    OPc_SVOP,	/* 7 */
    OPc_PADOP,	/* 8 */
    OPc_PVOP,	/* 9 */
    OPc_LOOP,	/* 10 */
    OPc_COP	/* 11 */
} opclass;

static char *opclassnames[] = {
    "B::NULL",
    "B::OP",
    "B::UNOP",
    "B::BINOP",
    "B::LOGOP",
    "B::LISTOP",
    "B::PMOP",
    "B::SVOP",
    "B::PADOP",
    "B::PVOP",
    "B::LOOP",
    "B::COP"	
};

static size_t opsizes[] = {
    0,	
    sizeof(OP),
    sizeof(UNOP),
    sizeof(BINOP),
    sizeof(LOGOP),
    sizeof(LISTOP),
    sizeof(PMOP),
    sizeof(SVOP),
    sizeof(PADOP),
    sizeof(PVOP),
    sizeof(LOOP),
    sizeof(COP)	
};

#define MY_CXT_KEY "B::_guts" XS_VERSION

typedef struct {
    int		x_walkoptree_debug;	/* Flag for walkoptree debug hook */
    SV *	x_specialsv_list[7];
} my_cxt_t;

START_MY_CXT

#define walkoptree_debug	(MY_CXT.x_walkoptree_debug)
#define specialsv_list		(MY_CXT.x_specialsv_list)

static opclass
cc_opclass(pTHX_ OP *o)
{
    if (!o)
	return OPc_NULL;

    if (o->op_type == 0)
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    if (o->op_type == OP_SASSIGN)
	return ((o->op_private & OPpASSIGN_BACKWARDS) ? OPc_UNOP : OPc_BINOP);

#ifdef USE_ITHREADS
    if (o->op_type == OP_GV || o->op_type == OP_GVSV ||
	o->op_type == OP_AELEMFAST || o->op_type == OP_RCATLINE)
	return OPc_PADOP;
#endif

    switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
    case OA_BASEOP:
	return OPc_BASEOP;

    case OA_UNOP:
	return OPc_UNOP;

    case OA_BINOP:
	return OPc_BINOP;

    case OA_LOGOP:
	return OPc_LOGOP;

    case OA_LISTOP:
	return OPc_LISTOP;

    case OA_PMOP:
	return OPc_PMOP;

    case OA_SVOP:
	return OPc_SVOP;

    case OA_PADOP:
	return OPc_PADOP;

    case OA_PVOP_OR_SVOP:
        /*
         * Character translations (tr///) are usually a PVOP, keeping a 
         * pointer to a table of shorts used to look up translations.
         * Under utf8, however, a simple table isn't practical; instead,
         * the OP is an SVOP, and the SV is a reference to a swash
         * (i.e., an RV pointing to an HV).
         */
	return (o->op_private & (OPpTRANS_TO_UTF|OPpTRANS_FROM_UTF))
		? OPc_SVOP : OPc_PVOP;

    case OA_LOOP:
	return OPc_LOOP;

    case OA_COP:
	return OPc_COP;

    case OA_BASEOP_OR_UNOP:
	/*
	 * UNI(OP_foo) in toke.c returns token UNI or FUNC1 depending on
	 * whether parens were seen. perly.y uses OPf_SPECIAL to
	 * signal whether a BASEOP had empty parens or none.
	 * Some other UNOPs are created later, though, so the best
	 * test is OPf_KIDS, which is set in newUNOP.
	 */
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    case OA_FILESTATOP:
	/*
	 * The file stat OPs are created via UNI(OP_foo) in toke.c but use
	 * the OPf_REF flag to distinguish between OP types instead of the
	 * usual OPf_SPECIAL flag. As usual, if OPf_KIDS is set, then we
	 * return OPc_UNOP so that walkoptree can find our children. If
	 * OPf_KIDS is not set then we check OPf_REF. Without OPf_REF set
	 * (no argument to the operator) it's an OP; with OPf_REF set it's
	 * an SVOP (and op_sv is the GV for the filehandle argument).
	 */
	return ((o->op_flags & OPf_KIDS) ? OPc_UNOP :
#ifdef USE_ITHREADS
		(o->op_flags & OPf_REF) ? OPc_PADOP : OPc_BASEOP);
#else
		(o->op_flags & OPf_REF) ? OPc_SVOP : OPc_BASEOP);
#endif
    case OA_LOOPEXOP:
	/*
	 * next, last, redo, dump and goto use OPf_SPECIAL to indicate that a
	 * label was omitted (in which case it's a BASEOP) or else a term was
	 * seen. In this last case, all except goto are definitely PVOP but
	 * goto is either a PVOP (with an ordinary constant label), an UNOP
	 * with OPf_STACKED (with a non-constant non-sub) or an UNOP for
	 * OP_REFGEN (with goto &sub) in which case OPf_STACKED also seems to
	 * get set.
	 */
	if (o->op_flags & OPf_STACKED)
	    return OPc_UNOP;
	else if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
	    return OPc_PVOP;
    }
    warn("can't determine class of operator %s, assuming BASEOP\n",
	 PL_op_name[o->op_type]);
    return OPc_BASEOP;
}

static char *
cc_opclassname(pTHX_ OP *o)
{
    return opclassnames[cc_opclass(aTHX_ o)];
}

static SV *
make_sv_object(pTHX_ SV *arg, SV *sv)
{
    char *type = 0;
    IV iv;
    dMY_CXT;
    
    for (iv = 0; iv < sizeof(specialsv_list)/sizeof(SV*); iv++) {
	if (sv == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (!type) {
	type = svclassnames[SvTYPE(sv)];
	iv = PTR2IV(sv);
    }
    sv_setiv(newSVrv(arg, type), iv);
    return arg;
}

static SV *
make_mg_object(pTHX_ SV *arg, MAGIC *mg)
{
    sv_setiv(newSVrv(arg, "B::MAGIC"), PTR2IV(mg));
    return arg;
}

static SV *
cstring(pTHX_ SV *sv, bool perlstyle)
{
    SV *sstr = newSVpvn("", 0);
    STRLEN len;
    char *s;
    char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */

    if (!SvOK(sv))
	sv_setpvn(sstr, "0", 1);
    else if (perlstyle && SvUTF8(sv))
    {
	SV *tmpsv = sv_newmortal(); /* Temporary SV to feed sv_uni_display */
	len = SvCUR(sv);
	s = sv_uni_display(tmpsv, sv, 8*len, UNI_DISPLAY_QQ);
	sv_setpv(sstr,"\"");
	while (*s)
	{
	    if (*s == '"')
		sv_catpv(sstr, "\\\"");
	    else if (*s == '$')
		sv_catpv(sstr, "\\$");
	    else if (*s == '@')
		sv_catpv(sstr, "\\@");
	    else if (*s == '\\')
	    {
		if (strchr("nrftax\\",*(s+1)))
		    sv_catpvn(sstr, s++, 2);
		else
		    sv_catpv(sstr, "\\\\");
	    }
	    else /* should always be printable */
		sv_catpvn(sstr, s, 1);
	    ++s;
	}
	sv_catpv(sstr, "\"");
	return sstr;
    }
    else
    {
	/* XXX Optimise? */
	s = SvPV(sv, len);
	sv_catpv(sstr, "\"");
	for (; len; len--, s++)
	{
	    /* At least try a little for readability */
	    if (*s == '"')
		sv_catpv(sstr, "\\\"");
	    else if (*s == '\\')
		sv_catpv(sstr, "\\\\");
            /* trigraphs - bleagh */
            else if (!perlstyle && *s == '?' && len>=3 && s[1] == '?')
            {
                sprintf(escbuff, "\\%03o", '?');
                sv_catpv(sstr, escbuff);
            }
	    else if (perlstyle && *s == '$')
		sv_catpv(sstr, "\\$");
	    else if (perlstyle && *s == '@')
		sv_catpv(sstr, "\\@");
#ifdef EBCDIC
	    else if (isPRINT(*s))
#else
	    else if (*s >= ' ' && *s < 127)
#endif /* EBCDIC */
		sv_catpvn(sstr, s, 1);
	    else if (*s == '\n')
		sv_catpv(sstr, "\\n");
	    else if (*s == '\r')
		sv_catpv(sstr, "\\r");
	    else if (*s == '\t')
		sv_catpv(sstr, "\\t");
	    else if (*s == '\a')
		sv_catpv(sstr, "\\a");
	    else if (*s == '\b')
		sv_catpv(sstr, "\\b");
	    else if (*s == '\f')
		sv_catpv(sstr, "\\f");
	    else if (!perlstyle && *s == '\v')
		sv_catpv(sstr, "\\v");
	    else
	    {
		/* Don't want promotion of a signed -1 char in sprintf args */
		unsigned char c = (unsigned char) *s;
		sprintf(escbuff, "\\%03o", c);
		sv_catpv(sstr, escbuff);
	    }
	    /* XXX Add line breaks if string is long */
	}
	sv_catpv(sstr, "\"");
    }
    return sstr;
}

static SV *
cchar(pTHX_ SV *sv)
{
    SV *sstr = newSVpvn("'", 1);
    STRLEN n_a;
    char *s = SvPV(sv, n_a);

    if (*s == '\'')
	sv_catpv(sstr, "\\'");
    else if (*s == '\\')
	sv_catpv(sstr, "\\\\");
#ifdef EBCDIC
    else if (isPRINT(*s))
#else
    else if (*s >= ' ' && *s < 127)
#endif /* EBCDIC */
	sv_catpvn(sstr, s, 1);
    else if (*s == '\n')
	sv_catpv(sstr, "\\n");
    else if (*s == '\r')
	sv_catpv(sstr, "\\r");
    else if (*s == '\t')
	sv_catpv(sstr, "\\t");
    else if (*s == '\a')
	sv_catpv(sstr, "\\a");
    else if (*s == '\b')
	sv_catpv(sstr, "\\b");
    else if (*s == '\f')
	sv_catpv(sstr, "\\f");
    else if (*s == '\v')
	sv_catpv(sstr, "\\v");
    else
    {
	/* no trigraph support */
	char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
	/* Don't want promotion of a signed -1 char in sprintf args */
	unsigned char c = (unsigned char) *s;
	sprintf(escbuff, "\\%03o", c);
	sv_catpv(sstr, escbuff);
    }
    sv_catpv(sstr, "'");
    return sstr;
}

void
walkoptree(pTHX_ SV *opsv, char *method)
{
    dSP;
    OP *o, *kid;
    dMY_CXT;

    if (!SvROK(opsv))
	croak("opsv is not a reference");
    opsv = sv_mortalcopy(opsv);
    o = INT2PTR(OP*,SvIV((SV*)SvRV(opsv)));
    if (walkoptree_debug) {
	PUSHMARK(sp);
	XPUSHs(opsv);
	PUTBACK;
	perl_call_method("walkoptree_debug", G_DISCARD);
    }
    PUSHMARK(sp);
    XPUSHs(opsv);
    PUTBACK;
    perl_call_method(method, G_DISCARD);
    if (o && (o->op_flags & OPf_KIDS)) {
	for (kid = ((UNOP*)o)->op_first; kid; kid = kid->op_sibling) {
	    /* Use the same opsv. Rely on methods not to mess it up. */
	    sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ kid)), PTR2IV(kid));
	    walkoptree(aTHX_ opsv, method);
	}
    }
    if (o && (cc_opclass(aTHX_ o) == OPc_PMOP) && o->op_type != OP_PUSHRE
	    && (kid = cPMOPo->op_pmreplroot))
    {
	sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ kid)), PTR2IV(kid));
	walkoptree(aTHX_ opsv, method);
    }
}

SV **
oplist(pTHX_ OP *o, SV **SP)
{
    for(; o; o = o->op_next) {
	SV *opsv;
#if PERL_VERSION >= 9
	if (o->op_opt == 0)
	    break;
	o->op_opt = 0;
#else
	if (o->op_seq == 0)
	    break;
	o->op_seq = 0;
#endif
	opsv = sv_newmortal();
	sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ (OP*)o)), PTR2IV(o));
	XPUSHs(opsv);
        switch (o->op_type) {
	case OP_SUBST:
            SP = oplist(aTHX_ cPMOPo->op_pmreplstart, SP);
            continue;
	case OP_SORT:
	    if (o->op_flags & OPf_STACKED && o->op_flags & OPf_SPECIAL) {
		OP *kid = cLISTOPo->op_first->op_sibling;   /* pass pushmark */
		kid = kUNOP->op_first;                      /* pass rv2gv */
		kid = kUNOP->op_first;                      /* pass leave */
		SP = oplist(aTHX_ kid->op_next, SP);
	    }
	    continue;
        }
	switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
	case OA_LOGOP:
	    SP = oplist(aTHX_ cLOGOPo->op_other, SP);
	    break;
	case OA_LOOP:
	    SP = oplist(aTHX_ cLOOPo->op_lastop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_nextop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_redoop, SP);
	    break;
	}
    }
    return SP;
}

typedef OP	*B__OP;
typedef UNOP	*B__UNOP;
typedef BINOP	*B__BINOP;
typedef LOGOP	*B__LOGOP;
typedef LISTOP	*B__LISTOP;
typedef PMOP	*B__PMOP;
typedef SVOP	*B__SVOP;
typedef PADOP	*B__PADOP;
typedef PVOP	*B__PVOP;
typedef LOOP	*B__LOOP;
typedef COP	*B__COP;

typedef SV	*B__SV;
typedef SV	*B__IV;
typedef SV	*B__PV;
typedef SV	*B__NV;
typedef SV	*B__PVMG;
typedef SV	*B__PVLV;
typedef SV	*B__BM;
typedef SV	*B__RV;
typedef SV	*B__FM;
typedef AV	*B__AV;
typedef HV	*B__HV;
typedef CV	*B__CV;
typedef GV	*B__GV;
typedef IO	*B__IO;

typedef MAGIC	*B__MAGIC;

#line 502 "B.c"
#define B_main_cv()	PL_main_cv
#define B_init_av()	PL_initav
#define B_inc_gv()	PL_incgv
#define B_check_av()	PL_checkav_save
#define B_begin_av()	PL_beginav_save
#define B_end_av()	PL_endav
#define B_main_root()	PL_main_root
#define B_main_start()	PL_main_start
#define B_amagic_generation()	PL_amagic_generation
#define B_defstash()	PL_defstash
#define B_curstash()	PL_curstash
#define B_dowarn()	PL_dowarn
#define B_comppadlist()	(PL_main_cv ? CvPADLIST(PL_main_cv) : CvPADLIST(PL_compcv))
#define B_sv_undef()	&PL_sv_undef
#define B_sv_yes()	&PL_sv_yes
#define B_sv_no()	&PL_sv_no
#define B_formfeed()	PL_formfeed
#ifdef USE_ITHREADS
#define B_regex_padav()	PL_regex_padav
#endif
XS(XS_B_init_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_init_av)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::init_av()");
    {
	B__AV	RETVAL;

	RETVAL = B_init_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B_check_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_check_av)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::check_av()");
    {
	B__AV	RETVAL;

	RETVAL = B_check_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B_begin_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_begin_av)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::begin_av()");
    {
	B__AV	RETVAL;

	RETVAL = B_begin_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B_end_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_end_av)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::end_av()");
    {
	B__AV	RETVAL;

	RETVAL = B_end_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B_inc_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_inc_gv)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::inc_gv()");
    {
	B__GV	RETVAL;

	RETVAL = B_inc_gv();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#ifdef USE_ITHREADS
#define XSubPPtmpAAAA 1

XS(XS_B_regex_padav); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_regex_padav)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::regex_padav()");
    {
	B__AV	RETVAL;

	RETVAL = B_regex_padav();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif
XS(XS_B_main_cv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_cv)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::main_cv()");
    {
	B__CV	RETVAL;

	RETVAL = B_main_cv();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B_main_root); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_root)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::main_root()");
    {
	B__OP	RETVAL;

	RETVAL = B_main_root();
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B_main_start); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_start)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::main_start()");
    {
	B__OP	RETVAL;

	RETVAL = B_main_start();
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B_amagic_generation); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_amagic_generation)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::amagic_generation()");
    {
	long	RETVAL;
	dXSTARG;

	RETVAL = B_amagic_generation();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B_comppadlist); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_comppadlist)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::comppadlist()");
    {
	B__AV	RETVAL;

	RETVAL = B_comppadlist();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B_sv_undef); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sv_undef)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::sv_undef()");
    {
	B__SV	RETVAL;

	RETVAL = B_sv_undef();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B_sv_yes); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sv_yes)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::sv_yes()");
    {
	B__SV	RETVAL;

	RETVAL = B_sv_yes();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B_sv_no); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sv_no)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::sv_no()");
    {
	B__SV	RETVAL;

	RETVAL = B_sv_no();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B_curstash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_curstash)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::curstash()");
    {
	B__HV	RETVAL;

	RETVAL = B_curstash();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B_defstash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_defstash)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::defstash()");
    {
	B__HV	RETVAL;

	RETVAL = B_defstash();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B_dowarn); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_dowarn)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::dowarn()");
    {
	U8	RETVAL;
	dXSTARG;

	RETVAL = B_dowarn();
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B_formfeed); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_formfeed)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::formfeed()");
    {
	B__SV	RETVAL;

	RETVAL = B_formfeed();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B_warnhook); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_warnhook)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::warnhook()");
    {
#line 596 "B.xs"
	ST(0) = make_sv_object(aTHX_ sv_newmortal(), PL_warnhook);
#line 854 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B_diehook); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_diehook)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::diehook()");
    {
#line 601 "B.xs"
	ST(0) = make_sv_object(aTHX_ sv_newmortal(), PL_diehook);
#line 868 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B_walkoptree); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_walkoptree)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: B::walkoptree(opsv, method)");
    {
	SV *	opsv = ST(0);
	char *	method = (char *)SvPV_nolen(ST(1));
#line 610 "B.xs"
	walkoptree(aTHX_ opsv, method);
#line 884 "B.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_B_walkoptree_debug); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_walkoptree_debug)
{
    dXSARGS;
    {
	int	RETVAL;
	dXSTARG;
#line 615 "B.xs"
	dMY_CXT;
	RETVAL = walkoptree_debug;
	if (items > 0 && SvTRUE(ST(1)))
	    walkoptree_debug = 1;
#line 901 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define address(sv) PTR2IV(sv)
XS(XS_B_address); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_address)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::address(sv)");
    {
	SV *	sv = ST(0);
	IV	RETVAL;
	dXSTARG;

	RETVAL = address(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B_svref_2object); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_svref_2object)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::svref_2object(sv)");
    {
	SV *	sv = ST(0);
	B__SV	RETVAL;
#line 632 "B.xs"
	if (!SvROK(sv))
	    croak("argument is not a reference");
	RETVAL = (SV*)SvRV(sv);
#line 938 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B_opnumber); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_opnumber)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::opnumber(name)");
    {
	char *	name = (char *)SvPV_nolen(ST(0));
#line 642 "B.xs"
{
 int i; 
 IV  result = -1;
 ST(0) = sv_newmortal();
 if (strncmp(name,"pp_",3) == 0)
   name += 3;
 for (i = 0; i < PL_maxo; i++)
  {
   if (strcmp(name, PL_op_name[i]) == 0)
    {
     result = i;
     break;
    }
  }
 sv_setiv(ST(0),result);
}
#line 972 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B_ppname); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_ppname)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::ppname(opnum)");
    {
	int	opnum = (int)SvIV(ST(0));
#line 663 "B.xs"
	ST(0) = sv_newmortal();
	if (opnum >= 0 && opnum < PL_maxo) {
	    sv_setpvn(ST(0), "pp_", 3);
	    sv_catpv(ST(0), PL_op_name[opnum]);
	}
#line 991 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_hash)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::hash(sv)");
    {
	SV *	sv = ST(0);
#line 673 "B.xs"
	char *s;
	STRLEN len;
	U32 hash = 0;
	char hexhash[19]; /* must fit "0xffffffffffffffff" plus trailing \0 */
	s = SvPV(sv, len);
	PERL_HASH(hash, s, len);
	sprintf(hexhash, "0x%"UVxf, (UV)hash);
	ST(0) = sv_2mortal(newSVpv(hexhash, 0));
#line 1013 "B.c"
    }
    XSRETURN(1);
}

#define cast_I32(foo) (I32)foo
XS(XS_B_cast_I32); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_cast_I32)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::cast_I32(i)");
    {
	IV	i = (IV)SvIV(ST(0));
	IV	RETVAL;
	dXSTARG;

	RETVAL = cast_I32(i);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B_minus_c); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_minus_c)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::minus_c()");
    {
#line 690 "B.xs"
	PL_minus_c = TRUE;
#line 1045 "B.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_B_save_BEGINs); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_save_BEGINs)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::save_BEGINs()");
    {
#line 695 "B.xs"
	PL_savebegin = TRUE;
#line 1059 "B.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_B_cstring); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_cstring)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::cstring(sv)");
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 701 "B.xs"
	RETVAL = cstring(aTHX_ sv, 0);
#line 1075 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_B_perlstring); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_perlstring)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::perlstring(sv)");
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 709 "B.xs"
	RETVAL = cstring(aTHX_ sv, 1);
#line 1093 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_B_cchar); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_cchar)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::cchar(sv)");
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 717 "B.xs"
	RETVAL = cchar(aTHX_ sv);
#line 1111 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_B_threadsv_names); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_threadsv_names)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::threadsv_names()");
   PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 724 "B.xs"
#if PERL_VERSION <= 8
# ifdef USE_5005THREADS
	int i;
	STRLEN len = strlen(PL_threadsv_names);

	EXTEND(sp, len);
	for (i = 0; i < len; i++)
	    PUSHs(sv_2mortal(newSVpvn(&PL_threadsv_names[i], 1)));
# endif
#endif
#line 1138 "B.c"
	PUTBACK;
	return;
    }
}

#define OP_next(o)	o->op_next
#define OP_sibling(o)	o->op_sibling
#define OP_desc(o)	PL_op_desc[o->op_type]
#define OP_targ(o)	o->op_targ
#define OP_type(o)	o->op_type
#if PERL_VERSION >= 9
#  define OP_opt(o)	o->op_opt
#  define OP_static(o)	o->op_static
#else
#  define OP_seq(o)	o->op_seq
#endif
#define OP_flags(o)	o->op_flags
#define OP_private(o)	o->op_private
#define OP_spare(o)	o->op_spare
XS(XS_B__OP_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_size)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::size(o)");
    {
	B__OP	o;
	size_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 756 "B.xs"
	RETVAL = opsizes[cc_opclass(aTHX_ o)];
#line 1177 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__OP_next); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_next)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::next(o)");
    {
	B__OP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_next(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__OP_sibling); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_sibling)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::sibling(o)");
    {
	B__OP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_sibling(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__OP_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_name)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::name(o)");
    {
	B__OP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 772 "B.xs"
	RETVAL = PL_op_name[o->op_type];
#line 1252 "B.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__OP_ppaddr); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_ppaddr)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::ppaddr(o)");
    {
	B__OP	o;
#line 781 "B.xs"
	int i;
	SV *sv = sv_newmortal();
#line 1269 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 784 "B.xs"
	sv_setpvn(sv, "PL_ppaddr[OP_", 13);
	sv_catpv(sv, PL_op_name[o->op_type]);
	for (i=13; (STRLEN)i < SvCUR(sv); ++i)
	    SvPVX(sv)[i] = toUPPER(SvPVX(sv)[i]);
	sv_catpv(sv, "]");
	ST(0) = sv;
#line 1284 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B__OP_desc); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_desc)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::desc(o)");
    {
	B__OP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_desc(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__OP_targ); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_targ)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::targ(o)");
    {
	B__OP	o;
	PADOFFSET	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_targ(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__OP_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_type)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::type(o)");
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_type(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAB 1

XS(XS_B__OP_opt); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_opt)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::opt(o)");
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_opt(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__OP_static); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_static)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::static(o)");
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_static(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAC 1

XS(XS_B__OP_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_seq)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::seq(o)");
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_seq(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif
XS(XS_B__OP_flags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_flags)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::flags(o)");
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_flags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__OP_private); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_private)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::private(o)");
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_private(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAD 1

XS(XS_B__OP_spare); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_spare)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::spare(o)");
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_spare(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif
XS(XS_B__OP_oplist); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_oplist)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::oplist(o)");
    SP -= items;
    {
	B__OP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 841 "B.xs"
	SP = oplist(aTHX_ o, SP);
#line 1534 "B.c"
	PUTBACK;
	return;
    }
}

#define UNOP_first(o)	o->op_first
XS(XS_B__UNOP_first); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__UNOP_first)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::UNOP::first(o)");
    {
	B__UNOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__UNOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = UNOP_first(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define BINOP_last(o)	o->op_last
XS(XS_B__BINOP_last); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BINOP_last)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::BINOP::last(o)");
    {
	B__BINOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__BINOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = BINOP_last(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define LOGOP_other(o)	o->op_other
XS(XS_B__LOGOP_other); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOGOP_other)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::LOGOP::other(o)");
    {
	B__LOGOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOGOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOGOP_other(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__LISTOP_children); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LISTOP_children)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::LISTOP::children(o)");
    {
	B__LISTOP	o;
	OP *	kid;
	int	i;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LISTOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 875 "B.xs"
	i = 0;
	for (kid = o->op_first; kid; kid = kid->op_sibling)
	    i++;
	RETVAL = i;
#line 1642 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#define PMOP_pmreplroot(o)	o->op_pmreplroot
#define PMOP_pmreplstart(o)	o->op_pmreplstart
#define PMOP_pmnext(o)		o->op_pmnext
#define PMOP_pmregexp(o)	PM_GETRE(o)
#ifdef USE_ITHREADS
#define PMOP_pmoffset(o)	o->op_pmoffset
#define PMOP_pmstashpv(o)	o->op_pmstashpv
#else
#define PMOP_pmstash(o)		o->op_pmstash
#endif
#define PMOP_pmflags(o)		o->op_pmflags
#define PMOP_pmpermflags(o)	o->op_pmpermflags
#define PMOP_pmdynflags(o)      o->op_pmdynflags
XS(XS_B__PMOP_pmreplroot); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmreplroot)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmreplroot(o)");
    {
	B__PMOP	o;
	OP *	root;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 903 "B.xs"
	ST(0) = sv_newmortal();
	root = o->op_pmreplroot;
	/* OP_PUSHRE stores an SV* instead of an OP* in op_pmreplroot */
	if (o->op_type == OP_PUSHRE) {
#ifdef USE_ITHREADS
            sv_setiv(ST(0), INT2PTR(PADOFFSET,root) );
#else
	    sv_setiv(newSVrv(ST(0), root ?
			     svclassnames[SvTYPE((SV*)root)] : "B::SV"),
		     PTR2IV(root));
#endif
	}
	else {
	    sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ root)), PTR2IV(root));
	}
#line 1693 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B__PMOP_pmreplstart); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmreplstart)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmreplstart(o)");
    {
	B__PMOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmreplstart(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__PMOP_pmnext); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmnext)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmnext(o)");
    {
	B__PMOP	o;
	B__PMOP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmnext(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#ifdef USE_ITHREADS
#define XSubPPtmpAAAE 1

XS(XS_B__PMOP_pmoffset); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmoffset)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmoffset(o)");
    {
	B__PMOP	o;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmoffset(o);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__PMOP_pmstashpv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmstashpv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmstashpv(o)");
    {
	B__PMOP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmstashpv(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAF 1

XS(XS_B__PMOP_pmstash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmstash)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmstash(o)");
    {
	B__PMOP	o;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmstash(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif
XS(XS_B__PMOP_pmflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmflags)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmflags(o)");
    {
	B__PMOP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__PMOP_pmpermflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmpermflags)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmpermflags(o)");
    {
	B__PMOP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmpermflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__PMOP_pmdynflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmdynflags)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmdynflags(o)");
    {
	B__PMOP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmdynflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__PMOP_precomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_precomp)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::precomp(o)");
    {
	B__PMOP	o;
	REGEXP *	rx;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 962 "B.xs"
	ST(0) = sv_newmortal();
	rx = PM_GETRE(o);
	if (rx)
	    sv_setpvn(ST(0), rx->precomp, rx->prelen);
#line 1922 "B.c"
    }
    XSRETURN(1);
}

#define SVOP_sv(o)     cSVOPo->op_sv
#define SVOP_gv(o)     ((GV*)cSVOPo->op_sv)
XS(XS_B__SVOP_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SVOP_sv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::SVOP::sv(o)");
    {
	B__SVOP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__SVOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = SVOP_sv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__SVOP_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SVOP_gv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::SVOP::gv(o)");
    {
	B__SVOP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__SVOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = SVOP_gv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#define PADOP_padix(o)	o->op_padix
#define PADOP_sv(o)	(o->op_padix ? PAD_SVl(o->op_padix) : Nullsv)
#define PADOP_gv(o)	((o->op_padix \
			  && SvTYPE(PAD_SVl(o->op_padix)) == SVt_PVGV) \
			 ? (GV*)PAD_SVl(o->op_padix) : Nullgv)
XS(XS_B__PADOP_padix); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_padix)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PADOP::padix(o)");
    {
	B__PADOP	o;
	PADOFFSET	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_padix(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__PADOP_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_sv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PADOP::sv(o)");
    {
	B__PADOP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_sv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__PADOP_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_gv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PADOP::gv(o)");
    {
	B__PADOP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_gv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__PVOP_pv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVOP_pv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PVOP::pv(o)");
    {
	B__PVOP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PVOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1006 "B.xs"
	/*
	 * OP_TRANS uses op_pv to point to a table of 256 or >=258 shorts
	 * whereas other PVOPs point to a null terminated string.
	 */
	if (o->op_type == OP_TRANS &&
		(o->op_private & OPpTRANS_COMPLEMENT) &&
		!(o->op_private & OPpTRANS_DELETE))
	{
	    short* tbl = (short*)o->op_pv;
	    short entries = 257 + tbl[256];
	    ST(0) = sv_2mortal(newSVpv(o->op_pv, entries * sizeof(short)));
	}
	else if (o->op_type == OP_TRANS) {
	    ST(0) = sv_2mortal(newSVpv(o->op_pv, 256 * sizeof(short)));
	}
	else
	    ST(0) = sv_2mortal(newSVpv(o->op_pv, 0));
#line 2095 "B.c"
    }
    XSRETURN(1);
}

#define LOOP_redoop(o)	o->op_redoop
#define LOOP_nextop(o)	o->op_nextop
#define LOOP_lastop(o)	o->op_lastop
XS(XS_B__LOOP_redoop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_redoop)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::LOOP::redoop(o)");
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOOP_redoop(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__LOOP_nextop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_nextop)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::LOOP::nextop(o)");
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOOP_nextop(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__LOOP_lastop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_lastop)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::LOOP::lastop(o)");
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOOP_lastop(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define COP_label(o)	o->cop_label
#define COP_stashpv(o)	CopSTASHPV(o)
#define COP_stash(o)	CopSTASH(o)
#define COP_file(o)	CopFILE(o)
#define COP_filegv(o)	CopFILEGV(o)
#define COP_cop_seq(o)	o->cop_seq
#define COP_arybase(o)	o->cop_arybase
#define COP_line(o)	CopLINE(o)
#define COP_warnings(o)	o->cop_warnings
#define COP_io(o)	o->cop_io
XS(XS_B__COP_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_label)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::label(o)");
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_label(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__COP_stashpv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_stashpv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::stashpv(o)");
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_stashpv(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__COP_stash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_stash)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::stash(o)");
    {
	B__COP	o;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_stash(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__COP_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_file)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::file(o)");
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_file(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__COP_filegv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_filegv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::filegv(o)");
    {
	B__COP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_filegv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__COP_cop_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_cop_seq)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::cop_seq(o)");
    {
	B__COP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_cop_seq(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__COP_arybase); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_arybase)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::arybase(o)");
    {
	B__COP	o;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_arybase(o);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__COP_line); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_line)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::line(o)");
    {
	B__COP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_line(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__COP_warnings); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_warnings)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::warnings(o)");
    {
	B__COP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_warnings(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__COP_io); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_io)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::io(o)");
    {
	B__COP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_io(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__SV_SvTYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_SvTYPE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::SV::SvTYPE(sv)");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvTYPE(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#define object_2svref(sv)	sv
#define SVREF SV *
XS(XS_B__SV_object_2svref); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_object_2svref)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::SV::object_2svref(sv)");
    {
	B__SV	sv;
	SVREF	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = object_2svref(sv);
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_B__SV_REFCNT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_REFCNT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::SV::REFCNT(sv)");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvREFCNT(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__SV_FLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_FLAGS)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::SV::FLAGS(sv)");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvFLAGS(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__SV_POK); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_POK)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::SV::POK(sv)");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvPOK(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__SV_ROK); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_ROK)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::SV::ROK(sv)");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvROK(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__SV_MAGICAL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_MAGICAL)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::SV::MAGICAL(sv)");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvMAGICAL(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__IV_IV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_IV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IV::IV(sv)");
    {
	B__IV	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvIV(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__IV_IVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_IVX)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IV::IVX(sv)");
    {
	B__IV	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvIVX(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__IV_UVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_UVX)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IV::UVX(sv)");
    {
	B__IV	sv;
	UV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvUVX(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#define needs64bits(sv) ((I32)SvIVX(sv) != SvIVX(sv))
XS(XS_B__IV_needs64bits); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_needs64bits)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IV::needs64bits(sv)");
    {
	B__IV	sv;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = needs64bits(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__IV_packiv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_packiv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IV::packiv(sv)");
    {
	B__IV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1159 "B.xs"
	if (sizeof(IV) == 8) {
	    U32 wp[2];
	    IV iv = SvIVX(sv);
	    /*
	     * The following way of spelling 32 is to stop compilers on
	     * 32-bit architectures from moaning about the shift count
	     * being >= the width of the type. Such architectures don't
	     * reach this code anyway (unless sizeof(IV) > 8 but then
	     * everything else breaks too so I'm not fussed at the moment).
	     */
#ifdef UV_IS_QUAD
	    wp[0] = htonl(((UV)iv) >> (sizeof(UV)*4));
#else
	    wp[0] = htonl(((U32)iv) >> (sizeof(UV)*4));
#endif
	    wp[1] = htonl(iv & 0xffffffff);
	    ST(0) = sv_2mortal(newSVpvn((char *)wp, 8));
	} else {
	    U32 w = htonl((U32)SvIVX(sv));
	    ST(0) = sv_2mortal(newSVpvn((char *)&w, 4));
	}
#line 2740 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B__NV_NV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_NV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::NV::NV(sv)");
    {
	B__NV	sv;
	NV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvNV(sv);
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__NV_NVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_NVX)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::NV::NVX(sv)");
    {
	B__NV	sv;
	NV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvNVX(sv);
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__RV_RV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__RV_RV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::RV::RV(sv)");
    {
	B__RV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__RV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvRV(sv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__PV_PVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_PVX)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PV::PVX(sv)");
    {
	B__PV	sv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvPVX(sv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__PV_RV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_RV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PV::RV(sv)");
    {
	B__PV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1207 "B.xs"
        if( SvROK(sv) ) {
            RETVAL = SvRV(sv);
        }
        else {
            croak( "argument is not SvROK" );
        }
#line 2866 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__PV_PV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_PV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PV::PV(sv)");
    {
	B__PV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1220 "B.xs"
        ST(0) = sv_newmortal();
        if( SvPOK(sv) ) { 
            sv_setpvn(ST(0), SvPVX(sv), SvCUR(sv));
            SvFLAGS(ST(0)) |= SvUTF8(sv);
        }
        else {
            /* XXX for backward compatibility, but should fail */
            /* croak( "argument is not SvPOK" ); */
            sv_setpvn(ST(0), NULL, 0);
        }
#line 2901 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B__PV_PVBM); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_PVBM)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PV::PVBM(sv)");
    {
	B__PV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1235 "B.xs"
        ST(0) = sv_newmortal();
	sv_setpvn(ST(0), SvPVX(sv),
	    SvCUR(sv) + (SvTYPE(sv) == SVt_PVBM ? 257 : 0));
#line 2925 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B__PV_LEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_LEN)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PV::LEN(sv)");
    {
	B__PV	sv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvLEN(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__PV_CUR); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_CUR)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PV::CUR(sv)");
    {
	B__PV	sv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvCUR(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__PVMG_MAGIC); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVMG_MAGIC)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PVMG::MAGIC(sv)");
    SP -= items;
    {
	B__PVMG	sv;
	MAGIC *	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVMG,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1255 "B.xs"
	for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic)
	    XPUSHs(make_mg_object(aTHX_ sv_newmortal(), mg));
#line 2998 "B.c"
	PUTBACK;
	return;
    }
}

XS(XS_B__PVMG_SvSTASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVMG_SvSTASH)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PVMG::SvSTASH(sv)");
    {
	B__PVMG	sv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVMG,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvSTASH(sv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#define MgMOREMAGIC(mg) mg->mg_moremagic
#define MgPRIVATE(mg) mg->mg_private
#define MgTYPE(mg) mg->mg_type
#define MgFLAGS(mg) mg->mg_flags
#define MgOBJ(mg) mg->mg_obj
#define MgLENGTH(mg) mg->mg_len
#define MgREGEX(mg) PTR2IV(mg->mg_obj)
XS(XS_B__MAGIC_MOREMAGIC); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_MOREMAGIC)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::MAGIC::MOREMAGIC(mg)");
    {
	B__MAGIC	mg;
	B__MAGIC	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1278 "B.xs"
	if( MgMOREMAGIC(mg) ) {
	    RETVAL = MgMOREMAGIC(mg);
	}
	else {
	    XSRETURN_UNDEF;
	}
#line 3060 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), "B::MAGIC"), PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

XS(XS_B__MAGIC_PRIVATE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_PRIVATE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::MAGIC::PRIVATE(mg)");
    {
	B__MAGIC	mg;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgPRIVATE(mg);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__MAGIC_TYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_TYPE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::MAGIC::TYPE(mg)");
    {
	B__MAGIC	mg;
	char	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgTYPE(mg);
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}

XS(XS_B__MAGIC_FLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_FLAGS)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::MAGIC::FLAGS(mg)");
    {
	B__MAGIC	mg;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgFLAGS(mg);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__MAGIC_OBJ); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_OBJ)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::MAGIC::OBJ(mg)");
    {
	B__MAGIC	mg;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgOBJ(mg);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__MAGIC_REGEX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_REGEX)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::MAGIC::REGEX(mg)");
    {
	B__MAGIC	mg;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1307 "B.xs"
        if( mg->mg_type == 'r' ) {
            RETVAL = MgREGEX(mg);
        }
        else {
            croak( "REGEX is only meaningful on r-magic" );
        }
#line 3189 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__MAGIC_precomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_precomp)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::MAGIC::precomp(mg)");
    {
	B__MAGIC	mg;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1320 "B.xs"
        if (mg->mg_type == 'r') {
            REGEXP* rx = (REGEXP*)mg->mg_obj;
            if( rx )
                RETVAL = newSVpvn( rx->precomp, rx->prelen );
        }
        else {
            croak( "precomp is only meaningful on r-magic" );
        }
#line 3220 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_B__MAGIC_LENGTH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_LENGTH)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::MAGIC::LENGTH(mg)");
    {
	B__MAGIC	mg;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgLENGTH(mg);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__MAGIC_PTR); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_PTR)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::MAGIC::PTR(mg)");
    {
	B__MAGIC	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1339 "B.xs"
	ST(0) = sv_newmortal();
 	if (mg->mg_ptr){
		if (mg->mg_len >= 0){
	    		sv_setpvn(ST(0), mg->mg_ptr, mg->mg_len);
		} else if (mg->mg_len == HEf_SVKEY) {
			ST(0) = make_sv_object(aTHX_
				    sv_newmortal(), (SV*)mg->mg_ptr);
		}
	}
#line 3276 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B__PVLV_TARGOFF); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TARGOFF)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PVLV::TARGOFF(sv)");
    {
	B__PVLV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTARGOFF(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__PVLV_TARGLEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TARGLEN)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PVLV::TARGLEN(sv)");
    {
	B__PVLV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTARGLEN(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__PVLV_TYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TYPE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PVLV::TYPE(sv)");
    {
	B__PVLV	sv;
	char	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTYPE(sv);
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}

XS(XS_B__PVLV_TARG); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TARG)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PVLV::TARG(sv)");
    {
	B__PVLV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTARG(sv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__BM_USEFUL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_USEFUL)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::BM::USEFUL(sv)");
    {
	B__BM	sv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = BmUSEFUL(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__BM_PREVIOUS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_PREVIOUS)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::BM::PREVIOUS(sv)");
    {
	B__BM	sv;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = BmPREVIOUS(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__BM_RARE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_RARE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::BM::RARE(sv)");
    {
	B__BM	sv;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = BmRARE(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__BM_TABLE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_TABLE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::BM::TABLE(sv)");
    {
	B__BM	sv;
	STRLEN	len;
	char *	str;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1387 "B.xs"
	str = SvPV(sv, len);
	/* Boyer-Moore table is just after string and its safety-margin \0 */
	ST(0) = sv_2mortal(newSVpvn(str + len + 1, 256));
#line 3472 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B__GV_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_NAME)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::NAME(gv)");
    {
	B__GV	gv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1397 "B.xs"
	ST(0) = sv_2mortal(newSVpvn(GvNAME(gv), GvNAMELEN(gv)));
#line 3494 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B__GV_is_empty); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_is_empty)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::is_empty(gv)");
    {
	B__GV	gv;
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1403 "B.xs"
        RETVAL = GvGP(gv) == Null(GP*);
#line 3517 "B.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_B__GV_GP); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_GP)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::GP(gv)");
    {
	B__GV	gv;
	void *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvGP(gv);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

XS(XS_B__GV_STASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_STASH)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::STASH(gv)");
    {
	B__GV	gv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvSTASH(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__GV_SV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_SV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::SV(gv)");
    {
	B__GV	gv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvSV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__GV_IO); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_IO)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::IO(gv)");
    {
	B__GV	gv;
	B__IO	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvIO(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__GV_FORM); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_FORM)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::FORM(gv)");
    {
	B__GV	gv;
	B__FM	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1427 "B.xs"
	RETVAL = (SV*)GvFORM(gv);
#line 3644 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__GV_AV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_AV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::AV(gv)");
    {
	B__GV	gv;
	B__AV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvAV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__GV_HV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_HV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::HV(gv)");
    {
	B__GV	gv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvHV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__GV_EGV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_EGV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::EGV(gv)");
    {
	B__GV	gv;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvEGV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__GV_CV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_CV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::CV(gv)");
    {
	B__GV	gv;
	B__CV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvCV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__GV_CVGEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_CVGEN)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::CVGEN(gv)");
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvCVGEN(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__GV_LINE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_LINE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::LINE(gv)");
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvLINE(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__GV_FILE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_FILE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::FILE(gv)");
    {
	B__GV	gv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvFILE(gv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__GV_FILEGV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_FILEGV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::FILEGV(gv)");
    {
	B__GV	gv;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvFILEGV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__GV_GvREFCNT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_GvREFCNT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::GvREFCNT(gv)");
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvREFCNT(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__GV_GvFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_GvFLAGS)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::GV::GvFLAGS(gv)");
    {
	B__GV	gv;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvFLAGS(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__IO_LINES); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_LINES)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IO::LINES(io)");
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoLINES(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__IO_PAGE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_PAGE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IO::PAGE(io)");
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoPAGE(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__IO_PAGE_LEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_PAGE_LEN)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IO::PAGE_LEN(io)");
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoPAGE_LEN(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__IO_LINES_LEFT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_LINES_LEFT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IO::LINES_LEFT(io)");
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoLINES_LEFT(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__IO_TOP_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_TOP_NAME)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IO::TOP_NAME(io)");
    {
	B__IO	io;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoTOP_NAME(io);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__IO_TOP_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_TOP_GV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IO::TOP_GV(io)");
    {
	B__IO	io;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoTOP_GV(io);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__IO_FMT_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_FMT_NAME)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IO::FMT_NAME(io)");
    {
	B__IO	io;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoFMT_NAME(io);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__IO_FMT_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_FMT_GV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IO::FMT_GV(io)");
    {
	B__IO	io;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoFMT_GV(io);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__IO_BOTTOM_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_BOTTOM_NAME)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IO::BOTTOM_NAME(io)");
    {
	B__IO	io;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoBOTTOM_NAME(io);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__IO_BOTTOM_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_BOTTOM_GV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IO::BOTTOM_GV(io)");
    {
	B__IO	io;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoBOTTOM_GV(io);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__IO_SUBPROCESS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_SUBPROCESS)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IO::SUBPROCESS(io)");
    {
	B__IO	io;
	short	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoSUBPROCESS(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__IO_IsSTD); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_IsSTD)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: B::IO::IsSTD(io, name)");
    {
	B__IO	io;
	char*	name = (char *)SvPV_nolen(ST(1));
#line 1524 "B.xs"
	PerlIO* handle = 0;
#line 4184 "B.c"
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");
#line 1526 "B.xs"
	if( strEQ( name, "stdin" ) ) {
	    handle = PerlIO_stdin();
	}
	else if( strEQ( name, "stdout" ) ) {
	    handle = PerlIO_stdout();
	}
	else if( strEQ( name, "stderr" ) ) {
	    handle = PerlIO_stderr();
	}
	else {
	    croak( "Invalid value '%s'", name );
	}
	RETVAL = handle == IoIFP(io);
#line 4207 "B.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_B__IO_IoTYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_IoTYPE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IO::IoTYPE(io)");
    {
	B__IO	io;
	char	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoTYPE(io);
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}

XS(XS_B__IO_IoFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_IoFLAGS)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::IO::IoFLAGS(io)");
    {
	B__IO	io;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoFLAGS(io);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__AV_FILL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_FILL)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::AV::FILL(av)");
    {
	B__AV	av;
	SSize_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvFILL(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__AV_MAX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_MAX)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::AV::MAX(av)");
    {
	B__AV	av;
	SSize_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvMAX(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define AvOFF(av) ((XPVAV*)SvANY(av))->xof_off
XS(XS_B__AV_OFF); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_OFF)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::AV::OFF(av)");
    {
	B__AV	av;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvOFF(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__AV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_ARRAY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::AV::ARRAY(av)");
    SP -= items;
    {
	B__AV	av;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");
#line 1572 "B.xs"
	if (AvFILL(av) >= 0) {
	    SV **svp = AvARRAY(av);
	    I32 i;
	    for (i = 0; i <= AvFILL(av); i++)
		XPUSHs(make_sv_object(aTHX_ sv_newmortal(), svp[i]));
	}
#line 4358 "B.c"
	PUTBACK;
	return;
    }
}

XS(XS_B__AV_ARRAYelt); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_ARRAYelt)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: B::AV::ARRAYelt(av, idx)");
    SP -= items;
    {
	B__AV	av;
	int	idx = (int)SvIV(ST(1));

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");
#line 1584 "B.xs"
    	if (idx >= 0 && AvFILL(av) >= 0 && idx <= AvFILL(av))
	    XPUSHs(make_sv_object(aTHX_ sv_newmortal(), (AvARRAY(av)[idx])));
	else
	    XPUSHs(make_sv_object(aTHX_ sv_newmortal(), NULL));
#line 4386 "B.c"
	PUTBACK;
	return;
    }
}

XS(XS_B__AV_AvFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_AvFLAGS)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::AV::AvFLAGS(av)");
    {
	B__AV	av;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvFLAGS(av);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__FM_LINES); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__FM_LINES)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::FM::LINES(form)");
    {
	B__FM	form;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    form = INT2PTR(B__FM,tmp);
	}
	else
	    croak("form is not a reference");

	RETVAL = FmLINES(form);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__CV_CONST); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_CONST)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::CONST(cv)");
    {
	B__CV	cv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvCONST(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__CV_STASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_STASH)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::STASH(cv)");
    {
	B__CV	cv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvSTASH(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__CV_START); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_START)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::START(cv)");
    {
	B__CV	cv;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvSTART(cv);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__CV_ROOT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_ROOT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::ROOT(cv)");
    {
	B__CV	cv;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvROOT(cv);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__CV_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_GV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::GV(cv)");
    {
	B__CV	cv;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvGV(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__CV_FILE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_FILE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::FILE(cv)");
    {
	B__CV	cv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvFILE(cv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__CV_DEPTH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_DEPTH)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::DEPTH(cv)");
    {
	B__CV	cv;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvDEPTH(cv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__CV_PADLIST); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_PADLIST)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::PADLIST(cv)");
    {
	B__CV	cv;
	B__AV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvPADLIST(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__CV_OUTSIDE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_OUTSIDE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::OUTSIDE(cv)");
    {
	B__CV	cv;
	B__CV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvOUTSIDE(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__CV_OUTSIDE_SEQ); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_OUTSIDE_SEQ)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::OUTSIDE_SEQ(cv)");
    {
	B__CV	cv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvOUTSIDE_SEQ(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__CV_XSUB); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_XSUB)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::XSUB(cv)");
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1648 "B.xs"
	ST(0) = sv_2mortal(newSViv(PTR2IV(CvXSUB(cv))));
#line 4707 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B__CV_XSUBANY); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_XSUBANY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::XSUBANY(cv)");
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1655 "B.xs"
	ST(0) = CvCONST(cv) ?
	    make_sv_object(aTHX_ sv_newmortal(),CvXSUBANY(cv).any_ptr) :
	    sv_2mortal(newSViv(CvXSUBANY(cv).any_iv));
#line 4731 "B.c"
    }
    XSRETURN(1);
}

XS(XS_B__CV_CvFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_CvFLAGS)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::CvFLAGS(cv)");
    {
	B__CV	cv;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvFLAGS(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__CV_const_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_const_sv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::const_sv(cv)");
    {
	B__CV	cv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = cv_const_sv(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__HV_FILL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_FILL)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::HV::FILL(hv)");
    {
	B__HV	hv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvFILL(hv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__HV_MAX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_MAX)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::HV::MAX(hv)");
    {
	B__HV	hv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvMAX(hv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__HV_KEYS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_KEYS)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::HV::KEYS(hv)");
    {
	B__HV	hv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvKEYS(hv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__HV_RITER); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_RITER)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::HV::RITER(hv)");
    {
	B__HV	hv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvRITER(hv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__HV_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_NAME)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::HV::NAME(hv)");
    {
	B__HV	hv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvNAME(hv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__HV_PMROOT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_PMROOT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::HV::PMROOT(hv)");
    {
	B__HV	hv;
	B__PMOP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvPMROOT(hv);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__HV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_ARRAY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::HV::ARRAY(hv)");
    SP -= items;
    {
	B__HV	hv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");
#line 1702 "B.xs"
	if (HvKEYS(hv) > 0) {
	    SV *sv;
	    char *key;
	    I32 len;
	    (void)hv_iterinit(hv);
	    EXTEND(sp, HvKEYS(hv) * 2);
	    while ((sv = hv_iternextsv(hv, &key, &len))) {
		PUSHs(newSVpvn(key, len));
		PUSHs(make_sv_object(aTHX_ sv_newmortal(), sv));
	    }
	}
#line 4959 "B.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_B); /* prototype to pass -Wmissing-prototypes */
XS(boot_B)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("B::init_av", XS_B_init_av, file);
        newXS("B::check_av", XS_B_check_av, file);
        newXS("B::begin_av", XS_B_begin_av, file);
        newXS("B::end_av", XS_B_end_av, file);
        newXS("B::inc_gv", XS_B_inc_gv, file);
#if XSubPPtmpAAAA
        newXS("B::regex_padav", XS_B_regex_padav, file);
#endif
        newXS("B::main_cv", XS_B_main_cv, file);
        newXS("B::main_root", XS_B_main_root, file);
        newXS("B::main_start", XS_B_main_start, file);
        newXS("B::amagic_generation", XS_B_amagic_generation, file);
        newXS("B::comppadlist", XS_B_comppadlist, file);
        newXS("B::sv_undef", XS_B_sv_undef, file);
        newXS("B::sv_yes", XS_B_sv_yes, file);
        newXS("B::sv_no", XS_B_sv_no, file);
        newXS("B::curstash", XS_B_curstash, file);
        newXS("B::defstash", XS_B_defstash, file);
        newXS("B::dowarn", XS_B_dowarn, file);
        newXS("B::formfeed", XS_B_formfeed, file);
        newXS("B::warnhook", XS_B_warnhook, file);
        newXS("B::diehook", XS_B_diehook, file);
        newXS("B::walkoptree", XS_B_walkoptree, file);
        newXS("B::walkoptree_debug", XS_B_walkoptree_debug, file);
        newXS("B::address", XS_B_address, file);
        newXS("B::svref_2object", XS_B_svref_2object, file);
        newXS("B::opnumber", XS_B_opnumber, file);
        newXS("B::ppname", XS_B_ppname, file);
        newXS("B::hash", XS_B_hash, file);
        newXS("B::cast_I32", XS_B_cast_I32, file);
        newXS("B::minus_c", XS_B_minus_c, file);
        newXS("B::save_BEGINs", XS_B_save_BEGINs, file);
        newXS("B::cstring", XS_B_cstring, file);
        newXS("B::perlstring", XS_B_perlstring, file);
        newXS("B::cchar", XS_B_cchar, file);
        newXS("B::threadsv_names", XS_B_threadsv_names, file);
        newXS("B::OP::size", XS_B__OP_size, file);
        newXS("B::OP::next", XS_B__OP_next, file);
        newXS("B::OP::sibling", XS_B__OP_sibling, file);
        newXS("B::OP::name", XS_B__OP_name, file);
        newXS("B::OP::ppaddr", XS_B__OP_ppaddr, file);
        newXS("B::OP::desc", XS_B__OP_desc, file);
        newXS("B::OP::targ", XS_B__OP_targ, file);
        newXS("B::OP::type", XS_B__OP_type, file);
#if XSubPPtmpAAAB
        newXS("B::OP::opt", XS_B__OP_opt, file);
        newXS("B::OP::static", XS_B__OP_static, file);
#endif
#if XSubPPtmpAAAC
        newXS("B::OP::seq", XS_B__OP_seq, file);
#endif
        newXS("B::OP::flags", XS_B__OP_flags, file);
        newXS("B::OP::private", XS_B__OP_private, file);
#if XSubPPtmpAAAD
        newXS("B::OP::spare", XS_B__OP_spare, file);
#endif
        newXS("B::OP::oplist", XS_B__OP_oplist, file);
        newXS("B::UNOP::first", XS_B__UNOP_first, file);
        newXS("B::BINOP::last", XS_B__BINOP_last, file);
        newXS("B::LOGOP::other", XS_B__LOGOP_other, file);
        newXS("B::LISTOP::children", XS_B__LISTOP_children, file);
        newXS("B::PMOP::pmreplroot", XS_B__PMOP_pmreplroot, file);
        newXS("B::PMOP::pmreplstart", XS_B__PMOP_pmreplstart, file);
        newXS("B::PMOP::pmnext", XS_B__PMOP_pmnext, file);
#if XSubPPtmpAAAE
        newXS("B::PMOP::pmoffset", XS_B__PMOP_pmoffset, file);
        newXS("B::PMOP::pmstashpv", XS_B__PMOP_pmstashpv, file);
#endif
#if XSubPPtmpAAAF
        newXS("B::PMOP::pmstash", XS_B__PMOP_pmstash, file);
#endif
        newXS("B::PMOP::pmflags", XS_B__PMOP_pmflags, file);
        newXS("B::PMOP::pmpermflags", XS_B__PMOP_pmpermflags, file);
        newXS("B::PMOP::pmdynflags", XS_B__PMOP_pmdynflags, file);
        newXS("B::PMOP::precomp", XS_B__PMOP_precomp, file);
        newXS("B::SVOP::sv", XS_B__SVOP_sv, file);
        newXS("B::SVOP::gv", XS_B__SVOP_gv, file);
        newXS("B::PADOP::padix", XS_B__PADOP_padix, file);
        newXS("B::PADOP::sv", XS_B__PADOP_sv, file);
        newXS("B::PADOP::gv", XS_B__PADOP_gv, file);
        newXS("B::PVOP::pv", XS_B__PVOP_pv, file);
        newXS("B::LOOP::redoop", XS_B__LOOP_redoop, file);
        newXS("B::LOOP::nextop", XS_B__LOOP_nextop, file);
        newXS("B::LOOP::lastop", XS_B__LOOP_lastop, file);
        newXS("B::COP::label", XS_B__COP_label, file);
        newXS("B::COP::stashpv", XS_B__COP_stashpv, file);
        newXS("B::COP::stash", XS_B__COP_stash, file);
        newXS("B::COP::file", XS_B__COP_file, file);
        newXS("B::COP::filegv", XS_B__COP_filegv, file);
        newXS("B::COP::cop_seq", XS_B__COP_cop_seq, file);
        newXS("B::COP::arybase", XS_B__COP_arybase, file);
        newXS("B::COP::line", XS_B__COP_line, file);
        newXS("B::COP::warnings", XS_B__COP_warnings, file);
        newXS("B::COP::io", XS_B__COP_io, file);
        newXS("B::SV::SvTYPE", XS_B__SV_SvTYPE, file);
        newXS("B::SV::object_2svref", XS_B__SV_object_2svref, file);
        newXS("B::SV::REFCNT", XS_B__SV_REFCNT, file);
        newXS("B::SV::FLAGS", XS_B__SV_FLAGS, file);
        newXS("B::SV::POK", XS_B__SV_POK, file);
        newXS("B::SV::ROK", XS_B__SV_ROK, file);
        newXS("B::SV::MAGICAL", XS_B__SV_MAGICAL, file);
        newXS("B::IV::IV", XS_B__IV_IV, file);
        newXS("B::IV::IVX", XS_B__IV_IVX, file);
        newXS("B::IV::UVX", XS_B__IV_UVX, file);
        newXS("B::IV::needs64bits", XS_B__IV_needs64bits, file);
        newXS("B::IV::packiv", XS_B__IV_packiv, file);
        newXS("B::NV::NV", XS_B__NV_NV, file);
        newXS("B::NV::NVX", XS_B__NV_NVX, file);
        newXS("B::RV::RV", XS_B__RV_RV, file);
        newXS("B::PV::PVX", XS_B__PV_PVX, file);
        newXS("B::PV::RV", XS_B__PV_RV, file);
        newXS("B::PV::PV", XS_B__PV_PV, file);
        newXS("B::PV::PVBM", XS_B__PV_PVBM, file);
        newXS("B::PV::LEN", XS_B__PV_LEN, file);
        newXS("B::PV::CUR", XS_B__PV_CUR, file);
        newXS("B::PVMG::MAGIC", XS_B__PVMG_MAGIC, file);
        newXS("B::PVMG::SvSTASH", XS_B__PVMG_SvSTASH, file);
        newXS("B::MAGIC::MOREMAGIC", XS_B__MAGIC_MOREMAGIC, file);
        newXS("B::MAGIC::PRIVATE", XS_B__MAGIC_PRIVATE, file);
        newXS("B::MAGIC::TYPE", XS_B__MAGIC_TYPE, file);
        newXS("B::MAGIC::FLAGS", XS_B__MAGIC_FLAGS, file);
        newXS("B::MAGIC::OBJ", XS_B__MAGIC_OBJ, file);
        newXS("B::MAGIC::REGEX", XS_B__MAGIC_REGEX, file);
        newXS("B::MAGIC::precomp", XS_B__MAGIC_precomp, file);
        newXS("B::MAGIC::LENGTH", XS_B__MAGIC_LENGTH, file);
        newXS("B::MAGIC::PTR", XS_B__MAGIC_PTR, file);
        newXS("B::PVLV::TARGOFF", XS_B__PVLV_TARGOFF, file);
        newXS("B::PVLV::TARGLEN", XS_B__PVLV_TARGLEN, file);
        newXS("B::PVLV::TYPE", XS_B__PVLV_TYPE, file);
        newXS("B::PVLV::TARG", XS_B__PVLV_TARG, file);
        newXS("B::BM::USEFUL", XS_B__BM_USEFUL, file);
        newXS("B::BM::PREVIOUS", XS_B__BM_PREVIOUS, file);
        newXS("B::BM::RARE", XS_B__BM_RARE, file);
        newXS("B::BM::TABLE", XS_B__BM_TABLE, file);
        newXS("B::GV::NAME", XS_B__GV_NAME, file);
        newXS("B::GV::is_empty", XS_B__GV_is_empty, file);
        newXS("B::GV::GP", XS_B__GV_GP, file);
        newXS("B::GV::STASH", XS_B__GV_STASH, file);
        newXS("B::GV::SV", XS_B__GV_SV, file);
        newXS("B::GV::IO", XS_B__GV_IO, file);
        newXS("B::GV::FORM", XS_B__GV_FORM, file);
        newXS("B::GV::AV", XS_B__GV_AV, file);
        newXS("B::GV::HV", XS_B__GV_HV, file);
        newXS("B::GV::EGV", XS_B__GV_EGV, file);
        newXS("B::GV::CV", XS_B__GV_CV, file);
        newXS("B::GV::CVGEN", XS_B__GV_CVGEN, file);
        newXS("B::GV::LINE", XS_B__GV_LINE, file);
        newXS("B::GV::FILE", XS_B__GV_FILE, file);
        newXS("B::GV::FILEGV", XS_B__GV_FILEGV, file);
        newXS("B::GV::GvREFCNT", XS_B__GV_GvREFCNT, file);
        newXS("B::GV::GvFLAGS", XS_B__GV_GvFLAGS, file);
        newXS("B::IO::LINES", XS_B__IO_LINES, file);
        newXS("B::IO::PAGE", XS_B__IO_PAGE, file);
        newXS("B::IO::PAGE_LEN", XS_B__IO_PAGE_LEN, file);
        newXS("B::IO::LINES_LEFT", XS_B__IO_LINES_LEFT, file);
        newXS("B::IO::TOP_NAME", XS_B__IO_TOP_NAME, file);
        newXS("B::IO::TOP_GV", XS_B__IO_TOP_GV, file);
        newXS("B::IO::FMT_NAME", XS_B__IO_FMT_NAME, file);
        newXS("B::IO::FMT_GV", XS_B__IO_FMT_GV, file);
        newXS("B::IO::BOTTOM_NAME", XS_B__IO_BOTTOM_NAME, file);
        newXS("B::IO::BOTTOM_GV", XS_B__IO_BOTTOM_GV, file);
        newXS("B::IO::SUBPROCESS", XS_B__IO_SUBPROCESS, file);
        newXS("B::IO::IsSTD", XS_B__IO_IsSTD, file);
        newXS("B::IO::IoTYPE", XS_B__IO_IoTYPE, file);
        newXS("B::IO::IoFLAGS", XS_B__IO_IoFLAGS, file);
        newXS("B::AV::FILL", XS_B__AV_FILL, file);
        newXS("B::AV::MAX", XS_B__AV_MAX, file);
        newXS("B::AV::OFF", XS_B__AV_OFF, file);
        newXS("B::AV::ARRAY", XS_B__AV_ARRAY, file);
        newXS("B::AV::ARRAYelt", XS_B__AV_ARRAYelt, file);
        newXS("B::AV::AvFLAGS", XS_B__AV_AvFLAGS, file);
        newXS("B::FM::LINES", XS_B__FM_LINES, file);
        newXS("B::CV::CONST", XS_B__CV_CONST, file);
        newXS("B::CV::STASH", XS_B__CV_STASH, file);
        newXS("B::CV::START", XS_B__CV_START, file);
        newXS("B::CV::ROOT", XS_B__CV_ROOT, file);
        newXS("B::CV::GV", XS_B__CV_GV, file);
        newXS("B::CV::FILE", XS_B__CV_FILE, file);
        newXS("B::CV::DEPTH", XS_B__CV_DEPTH, file);
        newXS("B::CV::PADLIST", XS_B__CV_PADLIST, file);
        newXS("B::CV::OUTSIDE", XS_B__CV_OUTSIDE, file);
        newXS("B::CV::OUTSIDE_SEQ", XS_B__CV_OUTSIDE_SEQ, file);
        newXS("B::CV::XSUB", XS_B__CV_XSUB, file);
        newXS("B::CV::XSUBANY", XS_B__CV_XSUBANY, file);
        newXS("B::CV::CvFLAGS", XS_B__CV_CvFLAGS, file);
        newXS("B::CV::const_sv", XS_B__CV_const_sv, file);
        newXS("B::HV::FILL", XS_B__HV_FILL, file);
        newXS("B::HV::MAX", XS_B__HV_MAX, file);
        newXS("B::HV::KEYS", XS_B__HV_KEYS, file);
        newXS("B::HV::RITER", XS_B__HV_RITER, file);
        newXS("B::HV::NAME", XS_B__HV_NAME, file);
        newXS("B::HV::PMROOT", XS_B__HV_PMROOT, file);
        newXS("B::HV::ARRAY", XS_B__HV_ARRAY, file);

    /* Initialisation Section */

#line 497 "B.xs"
{
    HV *stash = gv_stashpvn("B", 1, TRUE);
    AV *export_ok = perl_get_av("B::EXPORT_OK",TRUE);
    MY_CXT_INIT;
    specialsv_list[0] = Nullsv;
    specialsv_list[1] = &PL_sv_undef;
    specialsv_list[2] = &PL_sv_yes;
    specialsv_list[3] = &PL_sv_no;
    specialsv_list[4] = pWARN_ALL;
    specialsv_list[5] = pWARN_NONE;
    specialsv_list[6] = pWARN_STD;
#if PERL_VERSION <= 8
#  define CVf_ASSERTION	0
#endif
#include "defsubs.h"
}

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#line 5202 "B.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}


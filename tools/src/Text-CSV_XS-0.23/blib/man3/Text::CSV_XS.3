.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CSV_XS 3"
.TH CSV_XS 3 "2014-04-08" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
Text::CSV_XS \- comma\-separated values manipulation routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Text::CSV_XS;
.Ve
.PP
.Vb 2
\& $csv = Text::CSV_XS->new();           # create a new object
\& $csv = Text::CSV_XS->new(\e%attr);     # create a new object
.Ve
.PP
.Vb 2
\& $status = $csv->combine(@columns);    # combine columns into a string
\& $line = $csv->string();               # get the combined string
.Ve
.PP
.Vb 2
\& $status = $csv->parse($line);         # parse a CSV string into fields
\& @columns = $csv->fields();            # get the parsed fields
.Ve
.PP
.Vb 2
\& $status = $csv->status();             # get the most recent status
\& $bad_argument = $csv->error_input();  # get the most recent bad argument
.Ve
.PP
.Vb 2
\& $status = $csv->print($io, $columns); # Write an array of fields immediately
\&                                       # to a file $io
.Ve
.PP
.Vb 2
\& $columns = $csv->getline($io);        # Read a line from file $io, parse it
\&                                       # and return an array ref of fields
.Ve
.PP
.Vb 1
\& $csv->types(\e@t_array);               # Set column types
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Text::CSV_XS provides facilities for the composition and decomposition of
comma-separated values.  An instance of the Text::CSV_XS class can combine
fields into a \s-1CSV\s0 string and parse a \s-1CSV\s0 string into fields.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "\fIversion()\fR" 4
.IX Item "version()"
(Class method) Returns the current module version.
.IP "new(\e%attr)" 4
.IX Item "new(%attr)"
(Class method) Returns a new instance of Text::CSV_XS. The objects
attributes are described by the (optional) hash ref \f(CW\*(C`\e%attr\*(C'\fR.
Currently the following attributes are available:
.RS 4
.IP "quote_char" 8
.IX Item "quote_char"
The char used for quoting fields containing blanks, by default the
double quote character (\f(CW\*(C`"\*(C'\fR). A value of undef suppresses
quote chars. (For simple cases only).
.IP "eol" 8
.IX Item "eol"
An end-of-line string to add to rows, usually \f(CW\*(C`undef\*(C'\fR (nothing,
default), \f(CW"\e012"\fR (Line Feed) or \f(CW"\e015\e012"\fR (Carriage Return,
Line Feed)
.IP "escape_char" 8
.IX Item "escape_char"
The char used for escaping certain characters inside quoted fields,
by default the same character. (\f(CW\*(C`"\*(C'\fR)
.IP "sep_char" 8
.IX Item "sep_char"
The char used for separating fields, by default a comme. (\f(CW\*(C`,\*(C'\fR)
.IP "binary" 8
.IX Item "binary"
If this attribute is \s-1TRUE\s0, you may use binary characters in quoted fields,
including line feeds, carriage returns and \s-1NUL\s0 bytes. (The latter must
be escaped as \f(CW\*(C`"0\*(C'\fR.) By default this feature is off.
.IP "types" 8
.IX Item "types"
A set of column types; this attribute is immediately passed to the
\&\fItypes\fR method below. You must not set this attribute otherwise,
except for using the \fItypes\fR method. For details see the description
of the \fItypes\fR method below.
.IP "always_quote" 8
.IX Item "always_quote"
By default the generated fields are quoted only, if they need to, for
example, if they contain the separator. If you set this attribute to
a \s-1TRUE\s0 value, then all fields will be quoted. This is typically easier
to handle in external applications. (Poor creatures who aren't using
Text::CSV_XS. :\-)
.RE
.RS 4
.Sp
To sum it up,
.Sp
.Vb 1
\& $csv = Text::CSV_XS->new();
.Ve
.Sp
is equivalent to
.Sp
.Vb 6
\& $csv = Text::CSV_XS->new({
\&     'quote_char'  => '"',
\&     'escape_char' => '"',
\&     'sep_char'    => ',',
\&     'binary'      => 0
\& });
.Ve
.RE
.IP "combine" 4
.IX Item "combine"
.Vb 1
\& $status = $csv->combine(@columns);
.Ve
.Sp
This object function constructs a \s-1CSV\s0 string from the arguments, returning
success or failure.  Failure can result from lack of arguments or an argument
containing an invalid character.  Upon success, \f(CW\*(C`string()\*(C'\fR can be called to
retrieve the resultant \s-1CSV\s0 string.  Upon failure, the value returned by
\&\f(CW\*(C`string()\*(C'\fR is undefined and \f(CW\*(C`error_input()\*(C'\fR can be called to retrieve an
invalid argument.
.IP "print" 4
.IX Item "print"
.Vb 1
\& $status = $csv->print($io, $columns);
.Ve
.Sp
Similar to combine, but it expects an array ref as input (not an array!)
and the resulting string is not really created, but immediately written
to the \fI$io\fR object, typically an \s-1IO\s0 handle or any other object that
offers a \fIprint\fR method. Note, this implies that the following is wrong:
.Sp
.Vb 2
\& open(FILE, ">whatever");
\& $status = $csv->print(\e*FILE, $columns);
.Ve
.Sp
The glob \f(CW\*(C`\e*FILE\*(C'\fR is not an object, thus it doesn't have a print
method. The solution is to use an IO::File object or to hide the
glob behind an IO::Wrap object. See \fIIO::File\fR\|(3) and \fIIO::Wrap\fR\|(3)
for details.
.Sp
For performance reasons the print method doesn't create a result string.
In particular the \fI$csv\->\fIstring()\fI\fR, \fI$csv\->\fIstatus()\fI\fR,
\&\fI$csv\-\fR\fIfields()\fR> and \fI$csv\->\fIerror_input()\fI\fR methods are meaningless
after executing this method.
.IP "string" 4
.IX Item "string"
.Vb 1
\& $line = $csv->string();
.Ve
.Sp
This object function returns the input to \f(CW\*(C`parse()\*(C'\fR or the resultant \s-1CSV\s0
string of \f(CW\*(C`combine()\*(C'\fR, whichever was called more recently.
.IP "parse" 4
.IX Item "parse"
.Vb 1
\& $status = $csv->parse($line);
.Ve
.Sp
This object function decomposes a \s-1CSV\s0 string into fields, returning
success or failure.  Failure can result from a lack of argument or the
given \s-1CSV\s0 string is improperly formatted.  Upon success, \f(CW\*(C`fields()\*(C'\fR can
be called to retrieve the decomposed fields .  Upon failure, the value
returned by \f(CW\*(C`fields()\*(C'\fR is undefined and \f(CW\*(C`error_input()\*(C'\fR can be called
to retrieve the invalid argument.
.Sp
You may use the \fI\fItypes()\fI\fR method for setting column types. See the
description below.
.IP "getline" 4
.IX Item "getline"
.Vb 1
\& $columns = $csv->getline($io);
.Ve
.Sp
This is the counterpart to print, like parse is the counterpart to
combine: It reads a row from the \s-1IO\s0 object \f(CW$io\fR using \f(CW$io\fR\->\fIgetline()\fR
and parses this row into an array ref. This array ref is returned
by the function or undef for failure.
.Sp
The \fI$csv\->\fIstring()\fI\fR, \fI$csv\->\fIfields()\fI\fR and \fI$csv\->\fIstatus()\fI\fR
methods are meaningless, again.
.IP "types" 4
.IX Item "types"
.Vb 1
\& $csv->types(\e@tref);
.Ve
.Sp
This method is used to force that columns are of a given type. For
example, if you have an integer column, two double columns and a
string column, then you might do a
.Sp
.Vb 4
\& $csv->types([Text::CSV_XS::IV(),
\&              Text::CSV_XS::NV(),
\&              Text::CSV_XS::NV(),
\&              Text::CSV_XS::PV()]);
.Ve
.Sp
Column types are used only for decoding columns, in other words
by the \fI\fIparse()\fI\fR and \fI\fIgetline()\fI\fR methods.
.Sp
You can unset column types by doing a
.Sp
.Vb 1
\& $csv->types(undef);
.Ve
.Sp
or fetch the current type settings with
.Sp
.Vb 1
\& $types = $csv->types();
.Ve
.IP "fields" 4
.IX Item "fields"
.Vb 1
\& @columns = $csv->fields();
.Ve
.Sp
This object function returns the input to \f(CW\*(C`combine()\*(C'\fR or the resultant
decomposed fields of \f(CW\*(C`parse()\*(C'\fR, whichever was called more recently.
.IP "status" 4
.IX Item "status"
.Vb 1
\& $status = $csv->status();
.Ve
.Sp
This object function returns success (or failure) of \f(CW\*(C`combine()\*(C'\fR or
\&\f(CW\*(C`parse()\*(C'\fR, whichever was called more recently.
.IP "error_input" 4
.IX Item "error_input"
.Vb 1
\& $bad_argument = $csv->error_input();
.Ve
.Sp
This object function returns the erroneous argument (if it exists) of
\&\f(CW\*(C`combine()\*(C'\fR or \f(CW\*(C`parse()\*(C'\fR, whichever was called more recently.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 1
\&  require Text::CSV_XS;
.Ve
.PP
.Vb 1
\&  my $csv = Text::CSV_XS->new;
.Ve
.PP
.Vb 13
\&  my $column = '';
\&  my $sample_input_string = '"I said, ""Hi!""",Yes,"",2.34,,"1.09"';
\&  if ($csv->parse($sample_input_string)) {
\&    my @field = $csv->fields;
\&    my $count = 0;
\&    for $column (@field) {
\&      print ++$count, " => ", $column, "\en";
\&    }
\&    print "\en";
\&  } else {
\&    my $err = $csv->error_input;
\&    print "parse() failed on argument: ", $err, "\en";
\&  }
.Ve
.PP
.Vb 12
\&  my @sample_input_fields = ('You said, "Hello!"',
\&                             5.67,
\&                             'Surely',
\&                             '',
\&                             '3.14159');
\&  if ($csv->combine(@sample_input_fields)) {
\&    my $string = $csv->string;
\&    print $string, "\en";
\&  } else {
\&    my $err = $csv->error_input;
\&    print "combine() failed on argument: ", $err, "\en";
\&  }
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
This module is based upon a working definition of \s-1CSV\s0 format which may not be
the most general.
.IP "1" 4
.IX Item "1"
Allowable characters within a \s-1CSV\s0 field include 0x09 (tab) and the inclusive
range of 0x20 (space) through 0x7E (tilde). In binary mode all characters
are accepted, at least in quoted fields:
.IP "2" 4
.IX Item "2"
A field within \s-1CSV\s0 may be surrounded by double\-quotes. (The quote char)
.IP "3" 4
.IX Item "3"
A field within \s-1CSV\s0 must be surrounded by double-quotes to contain a comma.
(The separator char)
.IP "4" 4
.IX Item "4"
A field within \s-1CSV\s0 must be surrounded by double-quotes to contain an embedded
double\-quote, represented by a pair of consecutive double\-quotes. In binary
mode you may additionally use the sequence \f(CW\*(C`"0\*(C'\fR for representation of a
\&\s-1NUL\s0 byte.
.IP "5" 4
.IX Item "5"
A \s-1CSV\s0 string may be terminated by 0x0A (line feed) or by 0x0D,0x0A
(carriage return, line feed).
.SH "AUTHOR"
.IX Header "AUTHOR"
Alan Citterman \fI<alan@mfgrtl.com>\fR wrote the original Perl
module. Please don't send mail concerning Text::CSV_XS to Alan, as
he's not involved in the C part which is now the main part of the
module.
.Sp
Jochen Wiedmann \fI<joe@ispsoft.de>\fR rewrote the encoding and
decoding in C by implementing a simple finite-state machine and added
the variable quote, escape and separator characters, the binary mode
and the print and getline methods.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIIO::File\fR\|(3), \fIIO::Wrap\fR\|(3)

.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Algorithm::Diff 3"
.TH Algorithm::Diff 3 "2014-04-08" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
Algorithm::Diff \- Compute `intelligent' differences between two files / lists
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Algorithm::Diff qw(diff sdiff LCS traverse_sequences
\&                         traverse_balanced);
.Ve
.PP
.Vb 1
\&  @lcs    = LCS( \e@seq1, \e@seq2 );
.Ve
.PP
.Vb 1
\&  @lcs    = LCS( \e@seq1, \e@seq2, $key_generation_function );
.Ve
.PP
.Vb 1
\&  $lcsref = LCS( \e@seq1, \e@seq2 );
.Ve
.PP
.Vb 1
\&  $lcsref = LCS( \e@seq1, \e@seq2, $key_generation_function );
.Ve
.PP
.Vb 1
\&  @diffs = diff( \e@seq1, \e@seq2 );
.Ve
.PP
.Vb 1
\&  @diffs = diff( \e@seq1, \e@seq2, $key_generation_function );
.Ve
.PP
.Vb 1
\&  @sdiffs = sdiff( \e@seq1, \e@seq2 );
.Ve
.PP
.Vb 1
\&  @sdiffs = sdiff( \e@seq1, \e@seq2, $key_generation_function );
.Ve
.PP
.Vb 5
\&  traverse_sequences( \e@seq1, \e@seq2,
\&                     { MATCH => $callback,
\&                       DISCARD_A => $callback,
\&                       DISCARD_B => $callback,
\&                     } );
.Ve
.PP
.Vb 6
\&  traverse_sequences( \e@seq1, \e@seq2,
\&                     { MATCH => $callback,
\&                       DISCARD_A => $callback,
\&                       DISCARD_B => $callback,
\&                     },
\&                     $key_generation_function );
.Ve
.PP
.Vb 6
\&  traverse_balanced( \e@seq1, \e@seq2,
\&                     { MATCH => $callback,
\&                       DISCARD_A => $callback,
\&                       DISCARD_B => $callback,
\&                       CHANGE    => $callback,
\&                     } );
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
(by Mark-Jason Dominus)
.PP
I once read an article written by the authors of \f(CW\*(C`diff\*(C'\fR; they said
that they hard worked very hard on the algorithm until they found the
right one.
.PP
I think what they ended up using (and I hope someone will correct me,
because I am not very confident about this) was the `longest common
subsequence' method.  in the \s-1LCS\s0 problem, you have two sequences of
items:
.PP
.Vb 1
\&        a b c d f g h j q z
.Ve
.PP
.Vb 1
\&        a b c d e f g i j k r x y z
.Ve
.PP
and you want to find the longest sequence of items that is present in
both original sequences in the same order.  That is, you want to find
a new sequence \fIS\fR which can be obtained from the first sequence by
deleting some items, and from the secend sequence by deleting other
items.  You also want \fIS\fR to be as long as possible.  In this case
\&\fIS\fR is
.PP
.Vb 1
\&        a b c d f g j z
.Ve
.PP
From there it's only a small step to get diff-like output:
.PP
.Vb 2
\&        e   h i   k   q r x y 
\&        +   - +   +   - + + +
.Ve
.PP
This module solves the \s-1LCS\s0 problem.  It also includes a canned
function to generate \f(CW\*(C`diff\*(C'\fR\-like output.
.PP
It might seem from the example above that the \s-1LCS\s0 of two sequences is
always pretty obvious, but that's not always the case, especially when
the two sequences have many repeated elements.  For example, consider
.PP
.Vb 2
\&        a x b y c z p d q
\&        a b c a x b y c z
.Ve
.PP
A naive approach might start by matching up the \f(CW\*(C`a\*(C'\fR and \f(CW\*(C`b\*(C'\fR that
appear at the beginning of each sequence, like this:
.PP
.Vb 2
\&        a x b y c         z p d q
\&        a   b   c a b y c z
.Ve
.PP
This finds the common subsequence \f(CW\*(C`a b c z\*(C'\fR.  But actually, the \s-1LCS\s0
is \f(CW\*(C`a x b y c z\*(C'\fR:
.PP
.Vb 2
\&              a x b y c z p d q
\&        a b c a x b y c z
.Ve
.SH "USAGE"
.IX Header "USAGE"
This module provides three exportable functions, which we'll deal with in
ascending order of difficulty: \f(CW\*(C`LCS\*(C'\fR, 
\&\f(CW\*(C`diff\*(C'\fR, \f(CW\*(C`sdiff\*(C'\fR, \f(CW\*(C`traverse_sequences\*(C'\fR, and \f(CW\*(C`traverse_balanced\*(C'\fR.
.ie n .Sh """LCS"""
.el .Sh "\f(CWLCS\fP"
.IX Subsection "LCS"
Given references to two lists of items, \s-1LCS\s0 returns an array containing their
longest common subsequence.  In scalar context, it returns a reference to
such a list.
.PP
.Vb 2
\&  @lcs    = LCS( \e@seq1, \e@seq2 );
\&  $lcsref = LCS( \e@seq1, \e@seq2 );
.Ve
.PP
\&\f(CW\*(C`LCS\*(C'\fR may be passed an optional third parameter; this is a \s-1CODE\s0
reference to a key generation function.  See \*(L"\s-1KEY\s0 \s-1GENERATION\s0 \s-1FUNCTIONS\s0\*(R".
.PP
.Vb 2
\&  @lcs    = LCS( \e@seq1, \e@seq2, $keyGen );
\&  $lcsref = LCS( \e@seq1, \e@seq2, $keyGen );
.Ve
.PP
Additional parameters, if any, will be passed to the key generation
routine.
.ie n .Sh """diff"""
.el .Sh "\f(CWdiff\fP"
.IX Subsection "diff"
.Vb 2
\&  @diffs     = diff( \e@seq1, \e@seq2 );
\&  $diffs_ref = diff( \e@seq1, \e@seq2 );
.Ve
.PP
\&\f(CW\*(C`diff\*(C'\fR computes the smallest set of additions and deletions necessary
to turn the first sequence into the second, and returns a description
of these changes.  The description is a list of \fIhunks\fR; each hunk
represents a contiguous section of items which should be added,
deleted, or replaced.  The return value of \f(CW\*(C`diff\*(C'\fR is a list of
hunks, or, in scalar context, a reference to such a list.
.PP
Here is an example:  The diff of the following two sequences:
.PP
.Vb 2
\&  a b c e h j l m n p
\&  b c d e f j k l m r s t
.Ve
.PP
Result:
.PP
.Vb 2
\& [ 
\&   [ [ '-', 0, 'a' ] ],
.Ve
.PP
.Vb 1
\&   [ [ '+', 2, 'd' ] ],
.Ve
.PP
.Vb 2
\&   [ [ '-', 4, 'h' ] , 
\&     [ '+', 4, 'f' ] ],
.Ve
.PP
.Vb 1
\&   [ [ '+', 6, 'k' ] ],
.Ve
.PP
.Vb 7
\&   [ [ '-', 8, 'n' ], 
\&     [ '-', 9, 'p' ], 
\&     [ '+', 9, 'r' ], 
\&     [ '+', 10, 's' ], 
\&     [ '+', 11, 't' ],
\&   ]
\& ]
.Ve
.PP
There are five hunks here.  The first hunk says that the \f(CW\*(C`a\*(C'\fR at
position 0 of the first sequence should be deleted (\f(CW\*(C`\-\*(C'\fR).  The second
hunk says that the \f(CW\*(C`d\*(C'\fR at position 2 of the second sequence should
be inserted (\f(CW\*(C`+\*(C'\fR).  The third hunk says that the \f(CW\*(C`h\*(C'\fR at position 4
of the first sequence should be removed and replaced with the \f(CW\*(C`f\*(C'\fR
from position 4 of the second sequence.  The other two hunks similarly. 
.PP
\&\f(CW\*(C`diff\*(C'\fR may be passed an optional third parameter; this is a \s-1CODE\s0
reference to a key generation function.  See \*(L"\s-1KEY\s0 \s-1GENERATION\s0 \s-1FUNCTIONS\s0\*(R".
.PP
Additional parameters, if any, will be passed to the key generation
routine.
.ie n .Sh """sdiff"""
.el .Sh "\f(CWsdiff\fP"
.IX Subsection "sdiff"
.Vb 2
\&  @sdiffs     = sdiff( \e@seq1, \e@seq2 );
\&  $sdiffs_ref = sdiff( \e@seq1, \e@seq2 );
.Ve
.PP
\&\f(CW\*(C`sdiff\*(C'\fR computes all necessary components to show two sequences
and their minimized differences side by side, just like the 
Unix-utility \fIsdiff\fR does:
.PP
.Vb 4
\&    same             same
\&    before     |     after
\&    old        <     -
\&    -          >     new
.Ve
.PP
It returns a list of array refs, each pointing to an array of 
display instructions. In scalar context it returns a reference
to such a list.
.PP
Display instructions consist of three elements: A modifier indicator
(\f(CW\*(C`+\*(C'\fR: Element added, \f(CW\*(C`\-\*(C'\fR: Element removed, \f(CW\*(C`u\*(C'\fR: Element unmodified, 
\&\f(CW\*(C`c\*(C'\fR: Element changed) and the value of the old and new elements, to
be displayed side by side.
.PP
An \f(CW\*(C`sdiff\*(C'\fR of the following two sequences:
.PP
.Vb 2
\&  a b c e h j l m n p
\&  b c d e f j k l m r s t
.Ve
.PP
results in
.PP
[ [ '\-', 'a', ''  ],
  [ 'u', 'b', 'b' ],
  [ 'u', 'c', 'c' ],
  [ '+', '',  'd' ],
  [ 'u', 'e', 'e' ],
  [ 'c', 'h', 'f' ],
  [ 'u', 'j', 'j' ],
  [ '+', '',  'k' ],
  [ 'u', 'l', 'l' ],
  [ 'u', 'm', 'm' ],
  [ 'c', 'n', 'r' ],
  [ 'c', 'p', 's' ],
  [ '+', '', 't' ] ]
.PP
\&\f(CW\*(C`sdiff\*(C'\fR may be passed an optional third parameter; this is a \s-1CODE\s0
reference to a key generation function.  See \*(L"\s-1KEY\s0 \s-1GENERATION\s0 \s-1FUNCTIONS\s0\*(R".
.PP
Additional parameters, if any, will be passed to the key generation
routine.
.ie n .Sh """traverse_sequences"""
.el .Sh "\f(CWtraverse_sequences\fP"
.IX Subsection "traverse_sequences"
\&\f(CW\*(C`traverse_sequences\*(C'\fR is the most general facility provided by this
module; \f(CW\*(C`diff\*(C'\fR and \f(CW\*(C`LCS\*(C'\fR are implemented as calls to it.
.PP
Imagine that there are two arrows.  Arrow A points to an element of sequence A,
and arrow B points to an element of the sequence B.  Initially, the arrows
point to the first elements of the respective sequences.  \f(CW\*(C`traverse_sequences\*(C'\fR
will advance the arrows through the sequences one element at a time, calling an
appropriate user-specified callback function before each advance.  It
willadvance the arrows in such a way that if there are equal elements \f(CW$A[$i]\fR
and \f(CW$B[$j]\fR which are equal and which are part of the \s-1LCS\s0, there will be
some moment during the execution of \f(CW\*(C`traverse_sequences\*(C'\fR when arrow A is
pointing to \f(CW$A[$i]\fR and arrow B is pointing to \f(CW$B[$j]\fR.  When this happens,
\&\f(CW\*(C`traverse_sequences\*(C'\fR will call the \f(CW\*(C`MATCH\*(C'\fR callback function and then it will
advance both arrows. 
.PP
Otherwise, one of the arrows is pointing to an element of its sequence that is
not part of the \s-1LCS\s0.  \f(CW\*(C`traverse_sequences\*(C'\fR will advance that arrow and will
call the \f(CW\*(C`DISCARD_A\*(C'\fR or the \f(CW\*(C`DISCARD_B\*(C'\fR callback, depending on which arrow it
advanced.  If both arrows point to elements that are not part of the \s-1LCS\s0, then
\&\f(CW\*(C`traverse_sequences\*(C'\fR will advance one of them and call the appropriate
callback, but it is not specified which it will call.
.PP
The arguments to \f(CW\*(C`traverse_sequences\*(C'\fR are the two sequences to traverse, and a
hash which specifies the callback functions, like this:
.PP
.Vb 5
\&  traverse_sequences( \e@seq1, \e@seq2,
\&                     { MATCH => $callback_1,
\&                       DISCARD_A => $callback_2,
\&                       DISCARD_B => $callback_3,
\&                     } );
.Ve
.PP
Callbacks for \s-1MATCH\s0, \s-1DISCARD_A\s0, and \s-1DISCARD_B\s0 are invoked with at least the
indices of the two arrows as their arguments.  They are not expected to return
any values.  If a callback is omitted from the table, it is not called.
.PP
Callbacks for A_FINISHED and B_FINISHED are invoked with at least the
corresponding index in A or B.
.PP
If arrow A reaches the end of its sequence, before arrow B does,
\&\f(CW\*(C`traverse_sequences\*(C'\fR will call the \f(CW\*(C`A_FINISHED\*(C'\fR callback when it advances
arrow B, if there is such a function; if not it will call \f(CW\*(C`DISCARD_B\*(C'\fR instead.
Similarly if arrow B finishes first.  \f(CW\*(C`traverse_sequences\*(C'\fR returns when both
arrows are at the ends of their respective sequences.  It returns true on
success and false on failure.  At present there is no way to fail.
.PP
\&\f(CW\*(C`traverse_sequences\*(C'\fR may be passed an optional fourth parameter; this is a
\&\s-1CODE\s0 reference to a key generation function.  See \*(L"\s-1KEY\s0 \s-1GENERATION\s0 \s-1FUNCTIONS\s0\*(R".
.PP
Additional parameters, if any, will be passed to the key generation function.
.ie n .Sh """traverse_balanced"""
.el .Sh "\f(CWtraverse_balanced\fP"
.IX Subsection "traverse_balanced"
\&\f(CW\*(C`traverse_balanced\*(C'\fR is an alternative to \f(CW\*(C`traverse_sequences\*(C'\fR. It
uses a different algorithm to iterate through the entries in the
computed \s-1LCS\s0. Instead of sticking to one side and showing element changes
as insertions and deletions only, it will jump back and forth between
the two sequences and report \fIchanges\fR occurring as deletions on one
side followed immediatly by an insertion on the other side.
.PP
In addition to the 
\&\f(CW\*(C`DISCARD_A\*(C'\fR,
\&\f(CW\*(C`DISCARD_B\*(C'\fR, and
\&\f(CW\*(C`MATCH\*(C'\fR
callbacks supported by \f(CW\*(C`traverse_sequences\*(C'\fR, \f(CW\*(C`traverse_balanced\*(C'\fR supports
a \f(CW\*(C`CHANGE\*(C'\fR callback indicating that one element got \f(CW\*(C`replaced\*(C'\fR by another:
.PP
.Vb 6
\&  traverse_sequences( \e@seq1, \e@seq2,
\&                     { MATCH => $callback_1,
\&                       DISCARD_A => $callback_2,
\&                       DISCARD_B => $callback_3,
\&                       CHANGE    => $callback_4,
\&                     } );
.Ve
.PP
If no \f(CW\*(C`CHANGE\*(C'\fR callback is specified, \f(CW\*(C`traverse_balanced\*(C'\fR
will map \f(CW\*(C`CHANGE\*(C'\fR events to \f(CW\*(C`DISCARD_A\*(C'\fR and \f(CW\*(C`DISCARD_B\*(C'\fR actions,
therefore resulting in a similar behaviour as \f(CW\*(C`traverse_sequences\*(C'\fR
with different order of events.
.PP
\&\f(CW\*(C`traverse_balanced\*(C'\fR might be a bit slower than \f(CW\*(C`traverse_sequences\*(C'\fR,
noticable only while processing huge amounts of data.
.PP
The \f(CW\*(C`sdiff\*(C'\fR function of this module 
is implemented as call to \f(CW\*(C`traverse_balanced\*(C'\fR.
.SH "KEY GENERATION FUNCTIONS"
.IX Header "KEY GENERATION FUNCTIONS"
\&\f(CW\*(C`diff\*(C'\fR, \f(CW\*(C`LCS\*(C'\fR, and \f(CW\*(C`traverse_sequences\*(C'\fR accept an optional last parameter.
This is a \s-1CODE\s0 reference to a key generating (hashing) function that should
return a string that uniquely identifies a given element.  It should be the
case that if two elements are to be considered equal, their keys should be the
same (and the other way around).  If no key generation function is provided,
the key will be the element as a string.
.PP
By default, comparisons will use \*(L"eq\*(R" and elements will be turned into keys
using the default stringizing operator '""'.
.PP
Where this is important is when you're comparing something other than strings.
If it is the case that you have multiple different objects that should be
considered to be equal, you should supply a key generation function. Otherwise,
you have to make sure that your arrays contain unique references.
.PP
For instance, consider this example:
.PP
.Vb 1
\&  package Person;
.Ve
.PP
.Vb 5
\&  sub new
\&  {
\&    my $package = shift;
\&    return bless { name => '', ssn => '', @_ }, $package;
\&  }
.Ve
.PP
.Vb 5
\&  sub clone
\&  {
\&    my $old = shift;
\&    my $new = bless { %$old }, ref($old);
\&  }
.Ve
.PP
.Vb 4
\&  sub hash
\&  {
\&    return shift()->{'ssn'};
\&  }
.Ve
.PP
.Vb 5
\&  my $person1 = Person->new( name => 'Joe', ssn => '123-45-6789' );
\&  my $person2 = Person->new( name => 'Mary', ssn => '123-47-0000' );
\&  my $person3 = Person->new( name => 'Pete', ssn => '999-45-2222' );
\&  my $person4 = Person->new( name => 'Peggy', ssn => '123-45-9999' );
\&  my $person5 = Person->new( name => 'Frank', ssn => '000-45-9999' );
.Ve
.PP
If you did this:
.PP
.Vb 3
\&  my $array1 = [ $person1, $person2, $person4 ];
\&  my $array2 = [ $person1, $person3, $person4, $person5 ];
\&  Algorithm::Diff::diff( $array1, $array2 );
.Ve
.PP
everything would work out \s-1OK\s0 (each of the objects would be converted
into a string like \*(L"Person=HASH(0x82425b0)\*(R" for comparison).
.PP
But if you did this:
.PP
.Vb 3
\&  my $array1 = [ $person1, $person2, $person4 ];
\&  my $array2 = [ $person1, $person3, $person4->clone(), $person5 ];
\&  Algorithm::Diff::diff( $array1, $array2 );
.Ve
.PP
$person4 and \f(CW$person4\fR\->\fIclone()\fR (which have the same name and \s-1SSN\s0)
would be seen as different objects. If you wanted them to be considered
equivalent, you would have to pass in a key generation function:
.PP
.Vb 3
\&  my $array1 = [ $person1, $person2, $person4 ];
\&  my $array2 = [ $person1, $person3, $person4->clone(), $person5 ];
\&  Algorithm::Diff::diff( $array1, $array2, \e&Person::hash );
.Ve
.PP
This would use the 'ssn' field in each Person as a comparison key, and
so would consider \f(CW$person4\fR and \f(CW$person4\fR\->\fIclone()\fR as equal.
.PP
You may also pass additional parameters to the key generation function
if you wish.
.SH "AUTHOR"
.IX Header "AUTHOR"
This version by Ned Konz, perl@bike\-nomad.com
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2000\-2002 Ned Konz.  All rights reserved.
This program is free software;
you can redistribute it and/or modify it under the same terms
as Perl itself.
.SH "CREDITS"
.IX Header "CREDITS"
Versions through 0.59 (and much of this documentation) were written by:
.PP
Mark-Jason Dominus, mjd\-perl\-diff@plover.com
.PP
This version borrows the documentation and names of the routines
from Mark\-Jason's, but has all new code in Diff.pm.
.PP
This code was adapted from the Smalltalk code of
Mario Wolczko <mario@wolczko.com>, which is available at
ftp://st.cs.uiuc.edu/pub/Smalltalk/MANCHESTER/manchester/4.0/diff.st
.PP
\&\f(CW\*(C`sdiff\*(C'\fR and \f(CW\*(C`traverse_balanced\*(C'\fR were written by Mike Schilli
<m@perlmeister.com>.
.PP
The algorithm is that described in 
\&\fIA Fast Algorithm for Computing Longest Common Subsequences\fR,
\&\s-1CACM\s0, vol.20, no.5, pp.350\-353, May 1977, with a few
minor improvements to improve the speed.

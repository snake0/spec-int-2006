/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of Zlib.xs. Do not edit this file, edit Zlib.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Zlib.xs"
/* Filename: Zlib.xs
 * Author  : Paul Marquess, <pmqs@cpan.org>
 * Created : 30 January 2005
 * Version : 1.34
 *
 *   Copyright (c) 1995-2005 Paul Marquess. All rights reserved.
 *   This program is free software; you can redistribute it and/or
 *   modify it under the same terms as Perl itself.
 *
 */

/* Part of this code is based on the file gzio.c */

/* gzio.c -- IO on .gz files
 * Copyright (C) 1995 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */



#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <zlib.h> 

#ifndef PERL_VERSION
#include "patchlevel.h"
#define PERL_REVISION	5
#define PERL_VERSION	PATCHLEVEL
#define PERL_SUBVERSION	SUBVERSION
#endif

#if PERL_REVISION == 5 && (PERL_VERSION < 4 || (PERL_VERSION == 4 && PERL_SUBVERSION <= 75 ))

#    define PL_sv_undef		sv_undef
#    define PL_na		na
#    define PL_curcop		curcop
#    define PL_compiling	compiling

#endif

#ifndef newSVuv
#    define newSVuv	newSViv
#endif

typedef struct di_stream {
    z_stream stream;
    uLong    bufsize; 
    uLong    bufinc; 
    SV *     dictionary ;
    uLong    dict_adler ;
    bool     deflateParams_out_valid ;
    Bytef    deflateParams_out_byte;
    int      Level;
    int      Method;
    int      WindowBits;
    int      MemLevel;
    int      Strategy;
} di_stream;

typedef di_stream * deflateStream ;
typedef di_stream * Compress__Zlib__deflateStream ;
typedef di_stream * inflateStream ;
typedef di_stream * Compress__Zlib__inflateStream ;

/* typedef gzFile Compress__Zlib__gzFile ; */
typedef struct gzType {
    gzFile gz ;
    SV *   buffer ;
    uLong   offset ;
    bool   closed ;
}  gzType ;

typedef gzType* Compress__Zlib__gzFile ; 



#define GZERRNO	"Compress::Zlib::gzerrno"

#define ZMALLOC(to, typ) ((to = (typ *)safemalloc(sizeof(typ))), \
                                Zero(to,1,typ))

#define adlerInitial adler32(0L, Z_NULL, 0)
#define crcInitial crc32(0L, Z_NULL, 0)

#if 1
static char *my_z_errmsg[] = {
    "need dictionary",     /* Z_NEED_DICT     2 */
    "stream end",          /* Z_STREAM_END    1 */
    "",                    /* Z_OK            0 */
    "file error",          /* Z_ERRNO        (-1) */
    "stream error",        /* Z_STREAM_ERROR (-2) */
    "data error",          /* Z_DATA_ERROR   (-3) */
    "insufficient memory", /* Z_MEM_ERROR    (-4) */
    "buffer error",        /* Z_BUF_ERROR    (-5) */
    "incompatible version",/* Z_VERSION_ERROR(-6) */
    ""};
#endif


static int trace = 0 ;

static void
#ifdef CAN_PROTOTYPE
SetGzErrorNo(int error_no)
#else
SetGzErrorNo(error_no)
int error_no ;
#endif
{
    char * errstr ;
    SV * gzerror_sv = perl_get_sv(GZERRNO, FALSE) ;
  
    if (error_no == Z_ERRNO) {
        error_no = errno ;
        errstr = Strerror(errno) ;
    }
    else
        /* errstr = gzerror(fil, &error_no) ; */
        errstr = (char*) my_z_errmsg[2 - error_no]; 

    if (SvIV(gzerror_sv) != error_no) {
        sv_setiv(gzerror_sv, error_no) ;
        sv_setpv(gzerror_sv, errstr) ;
        SvIOK_on(gzerror_sv) ;
    }

}

static void
#ifdef CAN_PROTOTYPE
SetGzError(gzFile file)
#else
SetGzError(file)
gzFile file ;
#endif
{
    int error_no ;

    (void)gzerror(file, &error_no) ;
    SetGzErrorNo(error_no) ;
}

static void
#ifdef CAN_PROTOTYPE
DispHex(void * ptr, int length)
#else
DispHex(ptr, length)
    void * ptr;
    int length;
#endif
{
    char * p = (char*)ptr;
    int i;
    for (i = 0; i < length; ++i) {
        printf(" %02x", 0xFF & *(p+i));
    }
}


static void
#ifdef CAN_PROTOTYPE
DispStream(di_stream * s, char * message)
#else
DispStream(s, message)
    di_stream * s;
    char * message;
#endif
{

#if 0
    if (! trace)
        return ;
#endif

    printf("DispStream 0x%p - %s \n", s, message) ;

    if (!s)  {
	printf("    stream pointer is NULL\n");
    }
    else     {
	printf("    stream           0x%p\n", &(s->stream));
	printf("           zalloc    0x%p\n", s->stream.zalloc);
	printf("           zfree     0x%p\n", s->stream.zfree);
	printf("           opaque    0x%p\n", s->stream.opaque);
	if (s->stream.msg)
	    printf("           msg       %s\n", s->stream.msg);
	else
	    printf("           msg       \n");
	printf("           next_in   0x%p", s->stream.next_in);
    	if (s->stream.next_in) {
	    printf(" =>");
            DispHex(s->stream.next_in, 4);
	}
        printf("\n");

	printf("           next_out  0x%p", s->stream.next_out);
    	if (s->stream.next_out){
	    printf(" =>");
            DispHex(s->stream.next_out, 4);
	}
        printf("\n");

	printf("           avail_in  %ld\n", s->stream.avail_in);
	printf("           avail_out %ld\n", s->stream.avail_out);
	printf("           total_in  %ld\n", s->stream.total_in);
	printf("           total_out %ld\n", s->stream.total_out);
	printf("           adler     0x%lx\n", s->stream.adler);
	printf("           reserved  0x%lx\n", s->stream.reserved);
	printf("    bufsize          %ld\n", s->bufsize);
	printf("    dictionary       0x%p\n", s->dictionary);
	printf("    dict_adler       0x%ld\n", s->dict_adler);
	printf("\n");

    }
}


static di_stream *
#ifdef CAN_PROTOTYPE
InitStream(uLong bufsize)
#else
InitStream(bufsize)
    uLong bufsize ;
#endif
{
    di_stream *s ;

    ZMALLOC(s, di_stream) ;

    if (s)  {
        s->bufsize = bufsize ;
        s->bufinc  = bufsize ;
    }

    return s ;
    
}

#define SIZE 4096

static int
#ifdef CAN_PROTOTYPE
gzreadline(Compress__Zlib__gzFile file, SV * output)
#else
gzreadline(file, output)
  Compress__Zlib__gzFile file ;
  SV * output ;
#endif
{

    SV * store = file->buffer ;
    char *nl = "\n"; 
    char *p;
    char *out_ptr = SvPVX(store) ;
    int n;

    while (1) {

	/* anything left from last time */
	if ((n = SvCUR(store))) {

    	    out_ptr = SvPVX(store) + file->offset ;
	    if ((p = ninstr(out_ptr, out_ptr + n - 1, nl, nl))) {
            /* if (rschar != 0777 && */
                /* p = ninstr(out_ptr, out_ptr + n - 1, rs, rs+rslen-1)) { */

         	sv_catpvn(output, out_ptr, p - out_ptr + 1);

		file->offset += (p - out_ptr + 1) ;
	        n = n - (p - out_ptr + 1);
	        SvCUR_set(store, n) ;
	        return SvCUR(output);
            }
	    else /* no EOL, so append the complete buffer */
         	sv_catpvn(output, out_ptr, n);
	    
	}


	SvCUR_set(store, 0) ;
	file->offset = 0 ;
        out_ptr = SvPVX(store) ;

	n = gzread(file->gz, out_ptr, SIZE) ;

	if (n <= 0) 
	    /* Either EOF or an error */
	    /* so return what we have so far else signal eof */
	    return (SvCUR(output)>0) ? SvCUR(output) : n ;

	SvCUR_set(store, n) ;
    }
}

static SV* 
#ifdef CAN_PROTOTYPE
deRef(SV * sv, char * string)
#else
deRef(sv, string)
SV * sv ;
char * string;
#endif
{
    if (SvROK(sv)) {
	sv = SvRV(sv) ;
	switch(SvTYPE(sv)) {
            case SVt_PVAV:
            case SVt_PVHV:
            case SVt_PVCV:
                croak("%s: buffer parameter is not a SCALAR reference", string);
	}
	if (SvROK(sv))
	    croak("%s: buffer parameter is a reference to a reference", string) ;
    }

    if (!SvOK(sv)) { 
        sv = newSVpv("", 0);
    }	
    return sv ;
}

#include "constants.h"

#line 336 "Zlib.c"

/* INCLUDE:  Including 'constants.xs' from 'Zlib.xs' */

XS(XS_Compress__Zlib_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib_constant)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::constant(sv)");
    SP -= items;
    {
#line 4 "constants.xs"
#ifdef dXSTARG
	dXSTARG; /* Faster if we have it.  */
#else
	dTARGET;
#endif
	STRLEN		len;
        int		type;
	IV		iv;
	/* NV		nv;	Uncomment this if you need to return NVs */
	const char	*pv;
#line 359 "Zlib.c"
	SV *	sv = ST(0);
	const char *	s = SvPV(sv, len);
#line 18 "constants.xs"
        /* Change this to constant(aTHX_ s, len, &iv, &nv);
           if you need to return both NVs and IVs */
	type = constant(aTHX_ s, len, &iv, &pv);
      /* Return 1 or 2 items. First is error message, or undef if no error.
           Second, if present, is found value */
        switch (type) {
        case PERL_constant_NOTFOUND:
          sv = sv_2mortal(newSVpvf("%s is not a valid Zlib macro", s));
          PUSHs(sv);
          break;
        case PERL_constant_NOTDEF:
          sv = sv_2mortal(newSVpvf(
	    "Your vendor has not defined Zlib macro %s, used", s));
          PUSHs(sv);
          break;
        case PERL_constant_ISIV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHi(iv);
          break;
	/* Uncomment this if you need to return NOs
        case PERL_constant_ISNO:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_no);
          break; */
	/* Uncomment this if you need to return NVs
        case PERL_constant_ISNV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHn(nv);
          break; */
        case PERL_constant_ISPV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, strlen(pv));
          break;
	/* Uncomment this if you need to return PVNs
        case PERL_constant_ISPVN:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, iv);
          break; */
	/* Uncomment this if you need to return SVs
        case PERL_constant_ISSV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break; */
	/* Uncomment this if you need to return UNDEFs
        case PERL_constant_ISUNDEF:
          break; */
	/* Uncomment this if you need to return UVs
        case PERL_constant_ISUV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHu((UV)iv);
          break; */
	/* Uncomment this if you need to return YESs
        case PERL_constant_ISYES:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_yes);
          break; */
        default:
          sv = sv_2mortal(newSVpvf(
	    "Unexpected return type %d while processing Zlib macro %s, used",
               type, s));
          PUSHs(sv);
        }
#line 433 "Zlib.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'Zlib.xs' from 'constants.xs' */

#define Zip_zlib_version()	(char*)zlib_version
XS(XS_Compress__Zlib_zlib_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib_zlib_version)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::zlib_version()");
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = Zip_zlib_version();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib_DispStream); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib_DispStream)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::DispStream(s, message=NULL)");
    {
	Compress__Zlib__inflateStream	s;
	char *	message;

	if (sv_derived_from(ST(0), "Compress::Zlib::inflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__inflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::inflateStream");

	if (items < 2)
	    message = NULL;
	else {
	    message = (char *)SvPV_nolen(ST(1));
	}

	DispStream(s, message);
    }
    XSRETURN_EMPTY;
}

XS(XS_Compress__Zlib_gzopen_); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib_gzopen_)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::gzopen_(path, mode)");
    {
	char *	path = (char *)SvPV_nolen(ST(0));
	char *	mode = (char *)SvPV_nolen(ST(1));
	Compress__Zlib__gzFile	RETVAL;
#line 362 "Zlib.xs"
	gzFile	gz ;
	gz = gzopen(path, mode) ;
	if (gz) {
	    ZMALLOC(RETVAL, gzType) ;
    	    RETVAL->buffer = newSV(SIZE) ;
    	    SvPOK_only(RETVAL->buffer) ;
    	    SvCUR_set(RETVAL->buffer, 0) ; 
	    RETVAL->offset = 0 ;
	    RETVAL->gz = gz ;
	    RETVAL->closed = FALSE ;
	    SetGzErrorNo(0) ;
	}
	else {
	    RETVAL = NULL ;
	    SetGzErrorNo(errno ? Z_ERRNO : Z_MEM_ERROR) ;
	}
#line 514 "Zlib.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Compress::Zlib::gzFile", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib_gzdopen_); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib_gzdopen_)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::gzdopen_(fh, mode, offset)");
    {
	int	fh = (int)SvIV(ST(0));
	char *	mode = (char *)SvPV_nolen(ST(1));
	long	offset = (long)SvIV(ST(2));
	Compress__Zlib__gzFile	RETVAL;
#line 388 "Zlib.xs"
        gzFile  gz ;
        if (offset != -1)
            lseek(fh, offset, 0) ; 
        gz = gzdopen(fh, mode) ;
        if (gz) {
	    ZMALLOC(RETVAL, gzType) ;
            RETVAL->buffer = newSV(SIZE) ;
            SvPOK_only(RETVAL->buffer) ;
            SvCUR_set(RETVAL->buffer, 0) ;
            RETVAL->offset = 0 ;
            RETVAL->gz = gz ;
	    RETVAL->closed = FALSE ;
	    SetGzErrorNo(0) ;
        }
        else {
            RETVAL = NULL ;
	    SetGzErrorNo(errno ? Z_ERRNO : Z_MEM_ERROR) ;
	}
#line 551 "Zlib.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Compress::Zlib::gzFile", (void*)RETVAL);
    }
    XSRETURN(1);
}

#define Zip_gzread(file, buf, len) gzread(file->gz, bufp, len)
XS(XS_Compress__Zlib__gzFile_gzread); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__gzFile_gzread)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::gzFile::gzread(file, buf, len=4096)");
    {
	Compress__Zlib__gzFile	file;
	unsigned	len;
	SV *	buf = ST(1);
	voidp	bufp;
	uLong	bufsize = 0 ;
	int	RETVAL = 0 ;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::gzFile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    file = INT2PTR(Compress__Zlib__gzFile,tmp);
	}
	else
	    Perl_croak(aTHX_ "file is not of type Compress::Zlib::gzFile");

	if (items < 3)
	    len = 4096;
	else {
	    len = (unsigned long)SvUV(ST(2));
	}
#line 423 "Zlib.xs"
	if (SvREADONLY(buf) && PL_curcop != &PL_compiling)
            croak("gzread: buffer parameter is read-only");
        if (!SvUPGRADE(buf, SVt_PV))
            croak("cannot use buf argument as lvalue");
        SvPOK_only(buf);
        SvCUR_set(buf, 0);
	/* any left over from gzreadline ? */
	if ((bufsize = SvCUR(file->buffer)) > 0) {
	    uLong movesize ;

	    if (bufsize < len) {
		movesize = bufsize ;
	        len -= movesize ;
	    }
	    else {
	        movesize = len ;
	        len = 0 ;
	    }
	    RETVAL = movesize ;

       	    sv_catpvn(buf, SvPVX(file->buffer) + file->offset, movesize);

	    file->offset += movesize ;
	    SvCUR_set(file->buffer, bufsize - movesize) ;
	}

	if (len) {
	    bufp = (Byte*)SvGROW(buf, bufsize+len+1);
	    RETVAL = gzread(file->gz, ((Bytef*)bufp)+bufsize, len) ;
	    SetGzError(file->gz) ; 
            if (RETVAL >= 0) {
		RETVAL += bufsize ;
                SvCUR_set(buf, RETVAL) ;
                *SvEND(buf) = '\0';
            }
	}
#line 623 "Zlib.c"
	ST(1) = buf;
	SvSETMAGIC(ST(1));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__gzFile_gzreadline); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__gzFile_gzreadline)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::gzFile::gzreadline(file, buf)");
    {
	Compress__Zlib__gzFile	file;
	SV *	buf = ST(1);
	int	RETVAL = 0;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::gzFile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    file = INT2PTR(Compress__Zlib__gzFile,tmp);
	}
	else
	    Perl_croak(aTHX_ "file is not of type Compress::Zlib::gzFile");
#line 469 "Zlib.xs"
	if (SvREADONLY(buf) && PL_curcop != &PL_compiling) 
            croak("gzreadline: buffer parameter is read-only"); 
        if (!SvUPGRADE(buf, SVt_PV))
            croak("cannot use buf argument as lvalue");
        SvPOK_only(buf);
	/* sv_setpvn(buf, "", SIZE) ; */
        SvGROW(buf, SIZE) ;
        SvCUR_set(buf, 0);
	RETVAL = gzreadline(file, buf) ;
	SetGzError(file->gz) ; 
#line 660 "Zlib.c"
	ST(1) = buf;
	SvSETMAGIC(ST(1));
	XSprePUSH; PUSHi((IV)RETVAL);
#line 483 "Zlib.xs"
        if (RETVAL >= 0) {
            /* SvCUR(buf) = RETVAL; */
            /* Don't need to explicitly terminate with '\0', because
		sv_catpvn aready has */
        }
#line 670 "Zlib.c"
    }
    XSRETURN(1);
}

#define Zip_gzwrite(file, buf) gzwrite(file->gz, buf, (unsigned)len)
XS(XS_Compress__Zlib__gzFile_gzwrite); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__gzFile_gzwrite)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::gzFile::gzwrite(file, buf)");
    {
	Compress__Zlib__gzFile	file;
	STRLEN	len;
	voidp	buf = (voidp)SvPV(ST(1), len) ;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::gzFile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    file = INT2PTR(Compress__Zlib__gzFile,tmp);
	}
	else
	    Perl_croak(aTHX_ "file is not of type Compress::Zlib::gzFile");

	RETVAL = Zip_gzwrite(file, buf);
	XSprePUSH; PUSHi((IV)RETVAL);
#line 496 "Zlib.xs"
	  SetGzError(file->gz) ;
#line 700 "Zlib.c"
    }
    XSRETURN(1);
}

#define Zip_gzflush(file, flush) gzflush(file->gz, flush) 
XS(XS_Compress__Zlib__gzFile_gzflush); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__gzFile_gzflush)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::gzFile::gzflush(file, flush)");
    {
	Compress__Zlib__gzFile	file;
	int	flush = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::gzFile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    file = INT2PTR(Compress__Zlib__gzFile,tmp);
	}
	else
	    Perl_croak(aTHX_ "file is not of type Compress::Zlib::gzFile");

	RETVAL = Zip_gzflush(file, flush);
	XSprePUSH; PUSHi((IV)RETVAL);
#line 504 "Zlib.xs"
	  SetGzError(file->gz) ;
#line 729 "Zlib.c"
    }
    XSRETURN(1);
}

#define Zip_gzclose(file) gzclose(file->gz)
XS(XS_Compress__Zlib__gzFile_gzclose); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__gzFile_gzclose)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::gzFile::gzclose(file)");
    {
	Compress__Zlib__gzFile	file;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::gzFile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    file = INT2PTR(Compress__Zlib__gzFile,tmp);
	}
	else
	    Perl_croak(aTHX_ "file is not of type Compress::Zlib::gzFile");

	RETVAL = Zip_gzclose(file);
	XSprePUSH; PUSHi((IV)RETVAL);
#line 511 "Zlib.xs"
	  file->closed = TRUE ;
	  SetGzErrorNo(RETVAL) ;
#line 758 "Zlib.c"
    }
    XSRETURN(1);
}

#define Zip_gzeof(file) gzeof(file->gz)
XS(XS_Compress__Zlib__gzFile_gzeof); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__gzFile_gzeof)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::gzFile::gzeof(file)");
    {
	Compress__Zlib__gzFile	file;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::gzFile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    file = INT2PTR(Compress__Zlib__gzFile,tmp);
	}
	else
	    Perl_croak(aTHX_ "file is not of type Compress::Zlib::gzFile");
#line 520 "Zlib.xs"
#ifdef OLD_ZLIB
	croak("gzeof needs zlib 1.0.6 or better") ;
#else
	RETVAL = gzeof(file->gz);
#endif
#line 787 "Zlib.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define Zip_gzsetparams(file,l,s) gzsetparams(file->gz,l,s)
XS(XS_Compress__Zlib__gzFile_gzsetparams); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__gzFile_gzsetparams)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::gzFile::gzsetparams(file, level, strategy)");
    {
	Compress__Zlib__gzFile	file;
	int	level = (int)SvIV(ST(1));
	int	strategy = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::gzFile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    file = INT2PTR(Compress__Zlib__gzFile,tmp);
	}
	else
	    Perl_croak(aTHX_ "file is not of type Compress::Zlib::gzFile");
#line 536 "Zlib.xs"
#ifdef OLD_ZLIB
	croak("gzsetparams needs zlib 1.0.6 or better") ;
#else
	RETVAL = gzsetparams(file->gz, level, strategy);
#endif
#line 819 "Zlib.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__gzFile_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__gzFile_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::gzFile::DESTROY(file)");
    {
	Compress__Zlib__gzFile	file;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    file = INT2PTR(Compress__Zlib__gzFile,tmp);
	}
	else
	    Perl_croak(aTHX_ "file is not a reference");
#line 548 "Zlib.xs"
	    if (! file->closed)
	        Zip_gzclose(file) ;
	    SvREFCNT_dec(file->buffer) ;
	    safefree((char*)file) ;
#line 845 "Zlib.c"
    }
    XSRETURN_EMPTY;
}

#define Zip_gzerror(file) (char*)gzerror(file->gz, &errnum)
XS(XS_Compress__Zlib__gzFile_gzerror); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__gzFile_gzerror)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::gzFile::gzerror(file)");
    {
	Compress__Zlib__gzFile	file;
	int	errnum;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::gzFile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    file = INT2PTR(Compress__Zlib__gzFile,tmp);
	}
	else
	    Perl_croak(aTHX_ "file is not of type Compress::Zlib::gzFile");

	RETVAL = Zip_gzerror(file);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
#line 560 "Zlib.xs"
	    sv_setiv(ST(0), errnum) ;
            SvPOK_on(ST(0)) ;
#line 875 "Zlib.c"
    }
    XSRETURN(1);
}

#define Zip_adler32(buf, adler) adler32(adler, buf, (uInt)len)
XS(XS_Compress__Zlib_adler32); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib_adler32)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::adler32(buf, adler=adlerInitial)");
    {
	uLong	adler;
	STRLEN	len;
	Bytef *	buf;
	SV *	sv = ST(0) ;
	uLong	RETVAL;
	dXSTARG;
#line 577 "Zlib.xs"
    	/* If the buffer is a reference, dereference it */
	sv = deRef(sv, "adler32") ;
	buf = (Byte*)SvPV(sv, len) ;

	if (items < 2)
	  adler = adlerInitial;
	else if (SvOK(ST(1)))
	  adler = SvUV(ST(1)) ;
	else
	  adler = adlerInitial;
#line 905 "Zlib.c"

	RETVAL = Zip_adler32(buf, adler);
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}

#define Zip_crc32(buf, crc) crc32(crc, buf, (uInt)len)
XS(XS_Compress__Zlib_crc32); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib_crc32)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::crc32(buf, crc=crcInitial)");
    {
	uLong	crc;
	STRLEN	len;
	Bytef *	buf;
	SV *	sv = ST(0) ;
	uLong	RETVAL;
	dXSTARG;
#line 597 "Zlib.xs"
    	/* If the buffer is a reference, dereference it */
	sv = deRef(sv, "crc32") ;
	buf = (Byte*)SvPV(sv, len) ;

	if (items < 2)
	  crc = crcInitial;
	else if (SvOK(ST(1)))
	  crc = SvUV(ST(1)) ;
	else
	  crc = crcInitial;
#line 938 "Zlib.c"

	RETVAL = Zip_crc32(buf, crc);
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__deflateInit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__deflateInit)
{
    dXSARGS;
    if (items != 7)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::_deflateInit(level, method, windowBits, memLevel, strategy, bufsize, dictionary)");
    SP -= items;
    {
	int	level = (int)SvIV(ST(0));
	int	method = (int)SvIV(ST(1));
	int	windowBits = (int)SvIV(ST(2));
	int	memLevel = (int)SvIV(ST(3));
	int	strategy = (int)SvIV(ST(4));
	uLong	bufsize = (unsigned long)SvUV(ST(5));
	SV *	dictionary = ST(6);
#line 621 "Zlib.xs"
    int err ;
    deflateStream s ;

    if (trace)
        warn("in _deflateInit(level=%d, method=%d, windowBits=%d, memLevel=%d, strategy=%d, bufsize=%d\n",
	level, method, windowBits, memLevel, strategy, bufsize) ;
    if ((s = InitStream(bufsize)) ) {

        s->Level      = level;
        s->Method     = method;
        s->WindowBits = windowBits;
        s->MemLevel   = memLevel;
        s->Strategy   = strategy;

        err = deflateInit2(&(s->stream), level, 
			   method, windowBits, memLevel, strategy);

	/* Check if a dictionary has been specified */
	if (err == Z_OK && SvCUR(dictionary)) {
	    err = deflateSetDictionary(&(s->stream), (const Bytef*) SvPVX(dictionary), 
					SvCUR(dictionary)) ;
	    s->dict_adler = s->stream.adler ;
	}

        if (err != Z_OK) {
            Safefree(s) ;
            s = NULL ;
	}

    }
    else
        err = Z_MEM_ERROR ;

    XPUSHs(sv_setref_pv(sv_newmortal(), 
	"Compress::Zlib::deflateStream", (void*)s));
    if (GIMME == G_ARRAY) 
        XPUSHs(sv_2mortal(newSViv(err))) ;
#line 999 "Zlib.c"
	PUTBACK;
	return;
    }
}

XS(XS_Compress__Zlib__inflateInit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__inflateInit)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::_inflateInit(windowBits, bufsize, dictionary)");
    SP -= items;
    {
	int	windowBits = (int)SvIV(ST(0));
	uLong	bufsize = (unsigned long)SvUV(ST(1));
	SV *	dictionary = ST(2);
#line 666 "Zlib.xs"
    int err = Z_OK ;
    inflateStream s ;

    if (trace)
        warn("in _inflateInit(windowBits=%d, bufsize=%d, dictionary=%d\n",
                windowBits, bufsize, SvCUR(dictionary)) ;
    if ((s = InitStream(bufsize)) ) {

        s->WindowBits = windowBits;

        err = inflateInit2(&(s->stream), windowBits);

        if (err != Z_OK) {
            Safefree(s) ;
            s = NULL ;
	}
	else if (SvCUR(dictionary)) {
            /* Dictionary specified - take a copy for use in inflate */
	    s->dictionary = newSVsv(dictionary) ;
	}
    }
    else
	err = Z_MEM_ERROR ;

    XPUSHs(sv_setref_pv(sv_newmortal(), 
                   "Compress::Zlib::inflateStream", (void*)s));
    if (GIMME == G_ARRAY) 
        XPUSHs(sv_2mortal(newSViv(err))) ;
#line 1045 "Zlib.c"
	PUTBACK;
	return;
    }
}

XS(XS_Compress__Zlib__deflateStream_DispStream); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__deflateStream_DispStream)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::deflateStream::DispStream(s, message=NULL)");
    {
	Compress__Zlib__deflateStream	s;
	char *	message;

	if (sv_derived_from(ST(0), "Compress::Zlib::deflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__deflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::deflateStream");

	if (items < 2)
	    message = NULL;
	else {
	    message = (char *)SvPV_nolen(ST(1));
	}

	DispStream(s, message);
    }
    XSRETURN_EMPTY;
}

XS(XS_Compress__Zlib__deflateStream_deflate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__deflateStream_deflate)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::deflateStream::deflate(s, buf)");
    SP -= items;
    {
	Compress__Zlib__deflateStream	s;
	SV *	buf = ST(1);
	uLong	outsize;
	SV *	output;
	int	err = 0;

	if (sv_derived_from(ST(0), "Compress::Zlib::deflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__deflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::deflateStream");
#line 713 "Zlib.xs"
    /* If the buffer is a reference, dereference it */
    buf = deRef(buf, "deflate") ;

    /* initialise the input buffer */
    s->stream.next_in = (Bytef*)SvPV(buf, *(STRLEN*)&s->stream.avail_in) ;
    /* s->stream.next_in = (Bytef*)SvPVX(buf); */
    s->stream.avail_in = SvCUR(buf) ;

    /* and the output buffer */
    /* output = sv_2mortal(newSVpv("", s->bufinc)) ; */
    output = sv_2mortal(newSV(s->bufinc)) ;
    SvPOK_only(output) ;
    SvCUR_set(output, 0) ; 
    outsize = s->bufinc ;
    s->stream.next_out = (Bytef*) SvPVX(output) ;
    s->stream.avail_out = outsize;

    /* Check for saved output from deflateParams */
    if (s->deflateParams_out_valid) {
	*(s->stream.next_out) = s->deflateParams_out_byte;
	++ s->stream.next_out;
	-- s->stream.avail_out ;
	s->deflateParams_out_valid = FALSE;
    }

    while (s->stream.avail_in != 0) {

        if (s->stream.avail_out == 0) {
            s->bufinc *= 2 ;
            SvGROW(output, outsize + s->bufinc) ;
            s->stream.next_out = (Bytef*) SvPVX(output) + outsize ;
            outsize += s->bufinc ;
            s->stream.avail_out = s->bufinc ;
        }
        err = deflate(&(s->stream), Z_NO_FLUSH);
        if (err != Z_OK) 
            break;
    }

    if (err == Z_OK) {
        SvPOK_only(output);
        SvCUR_set(output, outsize - s->stream.avail_out) ;
    }
    else
        output = &PL_sv_undef ;
    XPUSHs(output) ;
    if (GIMME == G_ARRAY) 
        XPUSHs(sv_2mortal(newSViv(err))) ;
#line 1148 "Zlib.c"
	PUTBACK;
	return;
    }
}

XS(XS_Compress__Zlib__deflateStream_flush); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__deflateStream_flush)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::deflateStream::flush(s, f=Z_FINISH)");
    SP -= items;
    {
	Compress__Zlib__deflateStream	s;
	int	f;
	uLong	outsize;
	SV *	output;
	int	err = Z_OK ;

	if (sv_derived_from(ST(0), "Compress::Zlib::deflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__deflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::deflateStream");

	if (items < 2)
	    f = Z_FINISH;
	else {
	    f = (int)SvIV(ST(1));
	}
#line 773 "Zlib.xs"
    s->stream.avail_in = 0; /* should be zero already anyway */

    /* output = sv_2mortal(newSVpv("", s->bufinc)) ; */
    output = sv_2mortal(newSV(s->bufinc)) ;
    SvPOK_only(output) ;
    SvCUR_set(output, 0) ; 
    outsize = s->bufinc ;
    s->stream.next_out = (Bytef*) SvPVX(output) ;
    s->stream.avail_out = outsize;

    /* Check for saved output from deflateParams */
    if (s->deflateParams_out_valid) {
	*(s->stream.next_out) = s->deflateParams_out_byte;
	++ s->stream.next_out;
	-- s->stream.avail_out ;
	s->deflateParams_out_valid = FALSE;
    }

    for (;;) {
        if (s->stream.avail_out == 0) {
	    /* consumed all the available output, so extend it */
            s->bufinc *= 2 ;
	    SvGROW(output, outsize + s->bufinc) ;
            s->stream.next_out = (Bytef*)SvPVX(output) + outsize ;
	    outsize += s->bufinc ;
            s->stream.avail_out = s->bufinc ;
        }
        err = deflate(&(s->stream), f);

        /* deflate has finished flushing only when it hasn't used up
         * all the available space in the output buffer: 
         */
        if (s->stream.avail_out != 0 || err != Z_OK )
            break;
    }

    err =  (err == Z_STREAM_END ? Z_OK : err) ;

    if (err == Z_OK) {
        SvPOK_only(output);
        SvCUR_set(output, outsize - s->stream.avail_out) ;
    }
    else
        output = &PL_sv_undef ;
    XPUSHs(output) ;
    if (GIMME == G_ARRAY) 
        XPUSHs(sv_2mortal(newSViv(err))) ;
#line 1228 "Zlib.c"
	PUTBACK;
	return;
    }
}

XS(XS_Compress__Zlib__deflateStream__deflateParams); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__deflateStream__deflateParams)
{
    dXSARGS;
    if (items != 5)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::deflateStream::_deflateParams(s, flags, level, strategy, bufsize)");
    {
	Compress__Zlib__deflateStream	s;
	int	flags = (int)SvIV(ST(1));
	int	level = (int)SvIV(ST(2));
	int	strategy = (int)SvIV(ST(3));
	uLong	bufsize = (unsigned long)SvUV(ST(4));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::deflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__deflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::deflateStream");
#line 829 "Zlib.xs"
	if (flags & 1)
	    s->Level = level ;
	if (flags & 2)
	    s->Strategy = strategy ;
        if (bufsize) {
            s->bufsize = bufsize; 
            s->bufinc  = bufsize; 
	}
        s->stream.avail_in = 0; 
        s->stream.next_out = &(s->deflateParams_out_byte) ;
        s->stream.avail_out = 1;
	RETVAL = deflateParams(&(s->stream), s->Level, s->Strategy);
	s->deflateParams_out_valid = 
		(RETVAL == Z_OK && s->stream.avail_out == 0) ;
#line 1270 "Zlib.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__deflateStream_get_Level); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__deflateStream_get_Level)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::deflateStream::get_Level(s)");
    {
	Compress__Zlib__deflateStream	s;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::deflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__deflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::deflateStream");
#line 851 "Zlib.xs"
	RETVAL = s->Level ;
#line 1295 "Zlib.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__deflateStream_get_Strategy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__deflateStream_get_Strategy)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::deflateStream::get_Strategy(s)");
    {
	Compress__Zlib__deflateStream	s;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::deflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__deflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::deflateStream");
#line 859 "Zlib.xs"
	RETVAL = s->Strategy ;
#line 1320 "Zlib.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__deflateStream_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__deflateStream_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::deflateStream::DESTROY(s)");
    {
	Compress__Zlib__deflateStream	s;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__deflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not a reference");
#line 867 "Zlib.xs"
    deflateEnd(&s->stream) ;
    if (s->dictionary)
	SvREFCNT_dec(s->dictionary) ;
    Safefree(s) ;
#line 1346 "Zlib.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Compress__Zlib__deflateStream_dict_adler); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__deflateStream_dict_adler)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::deflateStream::dict_adler(s)");
    {
	Compress__Zlib__deflateStream	s;
	uLong	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::deflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__deflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::deflateStream");
#line 877 "Zlib.xs"
	RETVAL = s->dict_adler ;
#line 1370 "Zlib.c"
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__deflateStream_total_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__deflateStream_total_in)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::deflateStream::total_in(s)");
    {
	Compress__Zlib__deflateStream	s;
	uLong	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::deflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__deflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::deflateStream");
#line 885 "Zlib.xs"
	RETVAL = s->stream.total_in ;
#line 1395 "Zlib.c"
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__deflateStream_total_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__deflateStream_total_out)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::deflateStream::total_out(s)");
    {
	Compress__Zlib__deflateStream	s;
	uLong	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::deflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__deflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::deflateStream");
#line 893 "Zlib.xs"
	RETVAL = s->stream.total_out ;
#line 1420 "Zlib.c"
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__deflateStream_msg); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__deflateStream_msg)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::deflateStream::msg(s)");
    {
	Compress__Zlib__deflateStream	s;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::deflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__deflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::deflateStream");
#line 901 "Zlib.xs"
        RETVAL = s->stream.msg;
#line 1445 "Zlib.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__inflateStream_DispStream); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__inflateStream_DispStream)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::inflateStream::DispStream(s, message=NULL)");
    {
	Compress__Zlib__inflateStream	s;
	char *	message;

	if (sv_derived_from(ST(0), "Compress::Zlib::inflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__inflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::inflateStream");

	if (items < 2)
	    message = NULL;
	else {
	    message = (char *)SvPV_nolen(ST(1));
	}

	DispStream(s, message);
    }
    XSRETURN_EMPTY;
}

XS(XS_Compress__Zlib__inflateStream_inflate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__inflateStream_inflate)
{
    dXSARGS;
    dXSI32;
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(s, buf)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	Compress__Zlib__inflateStream	s;
	SV *	buf = ST(1);
	uLong	outsize;
	SV *	output;
	int	err = Z_OK ;

	if (sv_derived_from(ST(0), "Compress::Zlib::inflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__inflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::inflateStream");
#line 924 "Zlib.xs"
    /* If the buffer is a reference, dereference it */
    buf = deRef(buf, "inflate") ;

    /* initialise the input buffer */
    s->stream.next_in = (Bytef*)SvPVX(buf) ;
    s->stream.avail_in = SvCUR(buf) ;

    /* and the output buffer */
    output = sv_2mortal(newSV(s->bufinc+1)) ;
    SvPOK_only(output) ;
    SvCUR_set(output, 0) ; 
    outsize = s->bufinc ;
    s->stream.next_out = (Bytef*) SvPVX(output)  ;
    s->stream.avail_out = outsize;

    while (1) {

        if (s->stream.avail_out == 0) {
            s->bufinc *= 2 ;
            SvGROW(output, outsize + s->bufinc+1) ;
            s->stream.next_out = (Bytef*) SvPVX(output) + outsize ;
            outsize += s->bufinc ;
            s->stream.avail_out = s->bufinc ;
        }

        err = inflate(&(s->stream), Z_SYNC_FLUSH);
	if (err == Z_BUF_ERROR) {
	    if (s->stream.avail_out == 0)
	        continue ;
	    if (s->stream.avail_in == 0) {
		err = Z_OK ;
	        break ;
	    }
	}

	if (err == Z_NEED_DICT && s->dictionary) {
	    s->dict_adler = s->stream.adler ;
            err = inflateSetDictionary(&(s->stream), 
	    				(const Bytef*)SvPVX(s->dictionary),
					SvCUR(s->dictionary));
	}

        if (err != Z_OK) 
            break;
    }

    if (err == Z_OK || err == Z_STREAM_END || err == Z_DATA_ERROR) {
	unsigned in ;

        SvPOK_only(output);
        SvCUR_set(output, outsize - s->stream.avail_out) ;
        *SvEND(output) = '\0';

 	/* fix the input buffer */
	if (ix == 0) {
 	    in = s->stream.avail_in ;
 	    SvCUR_set(buf, in) ;
 	    if (in)
     	        Move(s->stream.next_in, SvPVX(buf), in, char) ;	
            *SvEND(buf) = '\0';
            SvSETMAGIC(buf);
	}
    }
    else
        output = &PL_sv_undef ;
    XPUSHs(output) ;
    if (GIMME == G_ARRAY) 
        XPUSHs(sv_2mortal(newSViv(err))) ;
#line 1569 "Zlib.c"
	PUTBACK;
	return;
    }
}

XS(XS_Compress__Zlib__inflateStream_inflateSync); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__inflateStream_inflateSync)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::inflateStream::inflateSync(s, buf)");
    {
	Compress__Zlib__inflateStream	s;
	SV *	buf = ST(1);
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::inflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__inflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::inflateStream");
#line 999 "Zlib.xs"
    /* If the buffer is a reference, dereference it */
    buf = deRef(buf, "inflateSync") ;

    /* initialise the input buffer */
    s->stream.next_in = (Bytef*)SvPVX(buf) ;
    s->stream.avail_in = SvCUR(buf) ;

    /* inflateSync doesn't create any output */
    s->stream.next_out = (Bytef*) NULL;
    s->stream.avail_out = 0;

    RETVAL = inflateSync(&(s->stream));
    {
 	/* fix the input buffer */
	unsigned in = s->stream.avail_in ;

 	SvCUR_set(buf, in) ;
 	if (in)
     	    Move(s->stream.next_in, SvPVX(buf), in, char) ;	
        *SvEND(buf) = '\0';
        SvSETMAGIC(buf);
    }
#line 1616 "Zlib.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__inflateStream_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__inflateStream_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::inflateStream::DESTROY(s)");
    {
	Compress__Zlib__inflateStream	s;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__inflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not a reference");
#line 1028 "Zlib.xs"
    inflateEnd(&s->stream) ;
    if (s->dictionary)
	SvREFCNT_dec(s->dictionary) ;
    Safefree(s) ;
#line 1642 "Zlib.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Compress__Zlib__inflateStream_dict_adler); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__inflateStream_dict_adler)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::inflateStream::dict_adler(s)");
    {
	Compress__Zlib__inflateStream	s;
	uLong	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::inflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__inflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::inflateStream");
#line 1038 "Zlib.xs"
	RETVAL = s->dict_adler ;
#line 1666 "Zlib.c"
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__inflateStream_total_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__inflateStream_total_in)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::inflateStream::total_in(s)");
    {
	Compress__Zlib__inflateStream	s;
	uLong	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::inflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__inflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::inflateStream");
#line 1046 "Zlib.xs"
	RETVAL = s->stream.total_in ;
#line 1691 "Zlib.c"
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__inflateStream_total_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__inflateStream_total_out)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::inflateStream::total_out(s)");
    {
	Compress__Zlib__inflateStream	s;
	uLong	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::inflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__inflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::inflateStream");
#line 1054 "Zlib.xs"
	RETVAL = s->stream.total_out ;
#line 1716 "Zlib.c"
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Compress__Zlib__inflateStream_msg); /* prototype to pass -Wmissing-prototypes */
XS(XS_Compress__Zlib__inflateStream_msg)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Compress::Zlib::inflateStream::msg(s)");
    {
	Compress__Zlib__inflateStream	s;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Compress::Zlib::inflateStream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Compress__Zlib__inflateStream,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Compress::Zlib::inflateStream");
#line 1062 "Zlib.xs"
        RETVAL = s->stream.msg;
#line 1741 "Zlib.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Compress__Zlib); /* prototype to pass -Wmissing-prototypes */
XS(boot_Compress__Zlib)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

        newXS("Compress::Zlib::constant", XS_Compress__Zlib_constant, file);
        newXS("Compress::Zlib::zlib_version", XS_Compress__Zlib_zlib_version, file);
        newXS("Compress::Zlib::DispStream", XS_Compress__Zlib_DispStream, file);
        newXS("Compress::Zlib::gzopen_", XS_Compress__Zlib_gzopen_, file);
        newXS("Compress::Zlib::gzdopen_", XS_Compress__Zlib_gzdopen_, file);
        newXS("Compress::Zlib::gzFile::gzread", XS_Compress__Zlib__gzFile_gzread, file);
        newXS("Compress::Zlib::gzFile::gzreadline", XS_Compress__Zlib__gzFile_gzreadline, file);
        newXS("Compress::Zlib::gzFile::gzwrite", XS_Compress__Zlib__gzFile_gzwrite, file);
        newXS("Compress::Zlib::gzFile::gzflush", XS_Compress__Zlib__gzFile_gzflush, file);
        newXS("Compress::Zlib::gzFile::gzclose", XS_Compress__Zlib__gzFile_gzclose, file);
        newXS("Compress::Zlib::gzFile::gzeof", XS_Compress__Zlib__gzFile_gzeof, file);
        newXS("Compress::Zlib::gzFile::gzsetparams", XS_Compress__Zlib__gzFile_gzsetparams, file);
        newXS("Compress::Zlib::gzFile::DESTROY", XS_Compress__Zlib__gzFile_DESTROY, file);
        newXS("Compress::Zlib::gzFile::gzerror", XS_Compress__Zlib__gzFile_gzerror, file);
        newXS("Compress::Zlib::adler32", XS_Compress__Zlib_adler32, file);
        newXS("Compress::Zlib::crc32", XS_Compress__Zlib_crc32, file);
        newXS("Compress::Zlib::_deflateInit", XS_Compress__Zlib__deflateInit, file);
        newXS("Compress::Zlib::_inflateInit", XS_Compress__Zlib__inflateInit, file);
        newXS("Compress::Zlib::deflateStream::DispStream", XS_Compress__Zlib__deflateStream_DispStream, file);
        newXS("Compress::Zlib::deflateStream::deflate", XS_Compress__Zlib__deflateStream_deflate, file);
        newXS("Compress::Zlib::deflateStream::flush", XS_Compress__Zlib__deflateStream_flush, file);
        newXS("Compress::Zlib::deflateStream::_deflateParams", XS_Compress__Zlib__deflateStream__deflateParams, file);
        newXS("Compress::Zlib::deflateStream::get_Level", XS_Compress__Zlib__deflateStream_get_Level, file);
        newXS("Compress::Zlib::deflateStream::get_Strategy", XS_Compress__Zlib__deflateStream_get_Strategy, file);
        newXS("Compress::Zlib::deflateStream::DESTROY", XS_Compress__Zlib__deflateStream_DESTROY, file);
        newXS("Compress::Zlib::deflateStream::dict_adler", XS_Compress__Zlib__deflateStream_dict_adler, file);
        newXS("Compress::Zlib::deflateStream::total_in", XS_Compress__Zlib__deflateStream_total_in, file);
        newXS("Compress::Zlib::deflateStream::total_out", XS_Compress__Zlib__deflateStream_total_out, file);
        newXS("Compress::Zlib::deflateStream::msg", XS_Compress__Zlib__deflateStream_msg, file);
        newXS("Compress::Zlib::inflateStream::DispStream", XS_Compress__Zlib__inflateStream_DispStream, file);
        cv = newXS("Compress::Zlib::inflateStream::__unc_inflate", XS_Compress__Zlib__inflateStream_inflate, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Compress::Zlib::inflateStream::inflate", XS_Compress__Zlib__inflateStream_inflate, file);
        XSANY.any_i32 = 0 ;
        newXS("Compress::Zlib::inflateStream::inflateSync", XS_Compress__Zlib__inflateStream_inflateSync, file);
        newXS("Compress::Zlib::inflateStream::DESTROY", XS_Compress__Zlib__inflateStream_DESTROY, file);
        newXS("Compress::Zlib::inflateStream::dict_adler", XS_Compress__Zlib__inflateStream_dict_adler, file);
        newXS("Compress::Zlib::inflateStream::total_in", XS_Compress__Zlib__inflateStream_total_in, file);
        newXS("Compress::Zlib::inflateStream::total_out", XS_Compress__Zlib__inflateStream_total_out, file);
        newXS("Compress::Zlib::inflateStream::msg", XS_Compress__Zlib__inflateStream_msg, file);
    }

    /* Initialisation Section */

#line 334 "Zlib.xs"
    /* Check this version of zlib is == 1 */
    if (zlibVersion()[0] != '1')
	croak("Compress::Zlib needs zlib version 1.x\n") ;

    {
        /* Create the $gzerror scalar */
        SV * gzerror_sv = perl_get_sv(GZERRNO, GV_ADDMULTI) ;
        sv_setiv(gzerror_sv, 0) ;
        sv_setpv(gzerror_sv, "") ;
        SvIOK_on(gzerror_sv) ;
    }

#line 1818 "Zlib.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}


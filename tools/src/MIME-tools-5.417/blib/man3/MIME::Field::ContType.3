.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MIME::Field::ContType 3"
.TH MIME::Field::ContType 3 "2014-04-08" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
MIME::Field::ContType \- a "Content\-type" field
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A subclass of Mail::Field.
.PP
\&\fIDon't use this class directly... its name may change in the future!\fR
Instead, ask Mail::Field for new instances based on the field name!
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Mail::Field;
\&    use MIME::Head;
.Ve
.PP
.Vb 3
\&    # Create an instance from some text:
\&    $field = Mail::Field->new('Content-type', 
\&                              'text/HTML; charset="US-ASCII"');
.Ve
.PP
.Vb 3
\&    # Get the MIME type, like 'text/plain' or 'x-foobar'.
\&    # Returns 'text/plain' as default, as per RFC-1521:
\&    my ($type, $subtype) = split('/', $field->type);
.Ve
.PP
.Vb 2
\&    # Get generic information:
\&    print $field->name;
.Ve
.PP
.Vb 6
\&    # Get information related to "message" type:
\&    if ($type eq 'message') {
\&        print $field->id;
\&        print $field->number;
\&        print $field->total;
\&    }
.Ve
.PP
.Vb 5
\&    # Get information related to "multipart" type:
\&    if ($type eq 'multipart') {
\&        print $field->boundary;            # the basic value, fixed up
\&        print $field->multipart_boundary;  # empty if not a multipart message!
\&    }
.Ve
.PP
.Vb 4
\&    # Get information related to "text" type:
\&    if ($type eq 'text') {
\&        print $field->charset;      # returns 'us-ascii' as default
\&    }
.Ve
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
.IP "boundary" 4
.IX Item "boundary"
Return the boundary field.  The boundary is returned exactly 
as given in the \f(CW\*(C`Content\-type:\*(C'\fR field; that is, the leading 
double-hyphen (\f(CW\*(C`\-\-\*(C'\fR) is \fInot\fR prepended.
.Sp
(Well, \fIalmost\fR exactly... from \s-1RFC\-1521:\s0
.Sp
.Vb 2
\&   (If a boundary appears to end with white space, the white space 
\&   must be presumed to have been added by a gateway, and must be deleted.)
.Ve
.Sp
so we oblige and remove any trailing spaces.)
.Sp
Returns the empty string if there is no boundary, or if the boundary is
illegal (e.g., if it is empty after all trailing whitespace has been
removed).
.IP "multipart_boundary" 4
.IX Item "multipart_boundary"
Like \f(CW\*(C`boundary()\*(C'\fR, except that this will also return the empty
string if the message is not a multipart message.  In other words,
there's an automatic sanity check.
.IP "type" 4
.IX Item "type"
Try real hard to determine the content type (e.g., \f(CW"text/plain"\fR,
\&\f(CW"image/gif"\fR, \f(CW"x\-weird\-type"\fR, which is returned 
in all\-lowercase.  
.Sp
A happy thing: the following code will work just as you would want,
even if there's no subtype (as in \f(CW"x\-weird\-type"\fR)... in such a case,
the \f(CW$subtype\fR would simply be the empty string:
.Sp
.Vb 1
\&    ($type, $subtype) = split('/', $head->mime_type);
.Ve
.Sp
If the content-type information is missing, it defaults to \f(CW"text/plain"\fR, 
as per \s-1RFC\-1521:\s0
.Sp
.Vb 4
\&    Default RFC-822 messages are typed by this protocol as plain text in
\&    the US-ASCII character set, which can be explicitly specified as
\&    "Content-type: text/plain; charset=us-ascii".  If no Content-Type is
\&    specified, this default is assumed.
.Ve
.Sp
\&\fBNote:\fR under the \*(L"be liberal in what we accept\*(R" principle, this routine
no longer syntax-checks the content type.  If it ain't empty,
just downcase and return it.
.SH "NOTES"
.IX Header "NOTES"
Since nearly all (if not all) parameters must have non-empty values
to be considered valid, we just return the empty string to signify 
missing fields.  If you need to get the \fIreal\fR underlying value,
use the inherited \f(CW\*(C`param()\*(C'\fR method (which returns undef if the 
parameter is missing).
.SH "AUTHOR"
.IX Header "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
David F. Skoll (dfs@roaringpenguin.com) http://www.roaringpenguin.com

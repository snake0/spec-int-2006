.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PDF::API2::Basic::TTF::Ttopen 3"
.TH PDF::API2::Basic::TTF::Ttopen 3 "2014-04-08" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
PDF::API2::Basic::TTF::Ttopen \- Opentype superclass for standard Opentype lookup based tables
(GSUB and GPOS)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Handles all the script, lang, feature, lookup stuff for a
PDF::API2::Basic::TTF::Gsub/PDF::API2::Basic::TTF::Gpos table leaving the class specifics to the
subclass
.SH "INSTANCE VARIABLES"
.IX Header "INSTANCE VARIABLES"
The instance variables of an opentype table form a complex sub-module hierarchy.
.IP "Version" 4
.IX Item "Version"
This contains the version of the table as a floating point number
.IP "\s-1SCRIPTS\s0" 4
.IX Item "SCRIPTS"
The scripts list is a hash of script tags. Each script tag (of the form
\&\f(CW$t\fR\->{'\s-1SCRIPTS\s0'}{$tag}) has information below it.
.RS 4
.IP "\s-1OFFSET\s0" 8
.IX Item "OFFSET"
This variable is preceeded by a space and gives the offset from the start of the
table (not the table section) to the script table for this script
.IP "\s-1REFTAG\s0" 8
.IX Item "REFTAG"
This variable is preceded by a space and gives a corresponding script tag to this
one such that the offsets in the file are the same. When writing, it is up to the
caller to ensure that the REFTAGs are set correctly, since these will be used to
assume that the scripts are identical. Note that \s-1REFTAG\s0 must refer to a script which
has no \s-1REFTAG\s0 of its own.
.IP "\s-1DEFAULT\s0" 8
.IX Item "DEFAULT"
This corresponds to the default language for this script, if there is one, and
contains the same information as an itemised language
.IP "\s-1LANG_TAGS\s0" 8
.IX Item "LANG_TAGS"
This contains an array of language tag strings (each 4 bytes) corresponding to
the languages listed by this script
.IP "$lang" 8
.IX Item "$lang"
Each language is a hash containing its information:
.RS 8
.IP "\s-1OFFSET\s0" 12
.IX Item "OFFSET"
This variable is preceeded by a a space and gives the offset from the start of
the whole table to the language table for this language
.IP "\s-1REFTAG\s0" 12
.IX Item "REFTAG"
This variable is preceded by a space and has the same function as for the script
\&\s-1REFTAG\s0, only for the languages within a script.
.IP "RE-ORDER" 12
.IX Item "RE-ORDER"
This indicates re-ordering information, and has not been set. The value should
always be 0.
.IP "\s-1DEFAULT\s0" 12
.IX Item "DEFAULT"
This holds the index of the default feature, if there is one, or \-1 otherwise.
.IP "\s-1FEATURES\s0" 12
.IX Item "FEATURES"
This is an array of feature indices which index into the \s-1FEATURES\s0 instance
variable of the table
.RE
.RS 8
.RE
.RE
.RS 4
.RE
.IP "\s-1FEATURES\s0" 4
.IX Item "FEATURES"
The features section of instance variables corresponds to the feature table in
the opentype table.
.RS 4
.IP "\s-1FEAT_TAGS\s0" 8
.IX Item "FEAT_TAGS"
This array gives the ordered list of feature tags for this table. It is used during
reading and writing for converting between feature index and feature tag.
.RE
.RS 4
.Sp
The rest of the \s-1FEATURES\s0 variable is itself a hash based on the feature tag for
each feature. Each feature has the following structure:
.IP "\s-1OFFSET\s0" 8
.IX Item "OFFSET"
This attribute is preceeded by a space and gives the offset relative to the start of the whole
table of this particular feature.
.IP "\s-1PARMS\s0" 8
.IX Item "PARMS"
This is an unused offset to the parameters for each feature
.IP "\s-1LOOKUPS\s0" 8
.IX Item "LOOKUPS"
This is an array containing indices to lookups in the \s-1LOOKUP\s0 instance variable of the table
.IP "\s-1INDEX\s0" 8
.IX Item "INDEX"
This gives the feature index for this feature and is used during reading and writing for
converting between feature tag and feature index.
.RE
.RS 4
.RE
.IP "\s-1LOOKUP\s0" 4
.IX Item "LOOKUP"
This variable is an array of lookups in order and is indexed via the features of a language of a
script. Each lookup contains subtables and other information:
.RS 4
.IP "\s-1OFFSET\s0" 8
.IX Item "OFFSET"
This name is preceeded by a space and contains the offset from the start of the table to this
particular lookup
.IP "\s-1TYPE\s0" 8
.IX Item "TYPE"
This is a subclass specific type for a lookup. It stipulates the type of lookup and hence subtables
within the lookup
.IP "\s-1FLAG\s0" 8
.IX Item "FLAG"
Holds the lookup flag bits
.IP "\s-1SUB\s0" 8
.IX Item "SUB"
This holds an array of subtables which are subclass specific. Each subtable must have
an \s-1OFFSET\s0. The other variables described here are an abstraction used in both the
\&\s-1GSUB\s0 and \s-1GPOS\s0 tables which are the target subclasses of this class.
.RS 8
.IP "\s-1OFFSET\s0" 12
.IX Item "OFFSET"
This is preceeded by a space and gives the offset relative to the start of the table for this
subtable
.IP "\s-1FORMAT\s0" 12
.IX Item "FORMAT"
Gives the sub-table sub format for this \s-1GSUB\s0 subtable. It is assumed that this
value is correct when it comes time to write the subtable.
.IP "\s-1COVERAGE\s0" 12
.IX Item "COVERAGE"
Most lookups consist of a coverage table corresponding to the first
glyph to match. The offset of this coverage table is stored here and the coverage
table looked up against the \s-1GSUB\s0 table proper. There are two lookups
without this initial coverage table which is used to index into the \s-1RULES\s0 array.
These lookups have one element in the \s-1RULES\s0 array which is used for the whole
match.
.IP "\s-1RULES\s0" 12
.IX Item "RULES"
The rules are a complex array. Each element of the array corresponds to an
element in the coverage table (governed by the coverage index). If there is
no coverage table, then there is considered to be only one element in the rules
array. Each element of the array is itself an array corresponding to the
possibly multiple string matches which may follow the initial glyph. Each
element of this array is a hash with fixed keys corresponding to information
needed to match a glyph string or act upon it. Thus the \s-1RULES\s0 element is an
array of arrays of hashes which contain the following keys:
.RS 12
.IP "\s-1MATCH\s0" 16
.IX Item "MATCH"
This contains a sequence of elements held as an array. The elements may be
glyph ids (gid), class ids (cids), or offsets to coverage tables. Each element
corresponds to one glyph in the glyph string. See \s-1MATCH_TYPE\s0 for details of
how the different element types are marked.
.IP "\s-1PRE\s0" 16
.IX Item "PRE"
This array holds the sequence of elements preceeding the first match element
and has the same form as the \s-1MATCH\s0 array.
.IP "\s-1POST\s0" 16
.IX Item "POST"
This array holds the sequence of elements to be tested for following the match
string and is of the same form as the \s-1MATCH\s0 array.
.IP "\s-1ACTION\s0" 16
.IX Item "ACTION"
This array holds information regarding what should be done if a match is found.
The array may either hold glyph ids (which are used to replace or insert or
whatever glyphs in the glyph string) or 2 element arrays consisting of:
.RS 16
.IP "\s-1OFFSET\s0" 20
.IX Item "OFFSET"
Offset from the start of the matched string that the lookup should start at
when processing the substring.
.IP "\s-1LOOKUP_INDEX\s0" 20
.IX Item "LOOKUP_INDEX"
The index to a lookup to be acted upon on the match string.
.RE
.RS 16
.RE
.RE
.RS 12
.RE
.RE
.RS 8
.RE
.RE
.RS 4
.RE
.IP "\s-1CLASS\s0" 4
.IX Item "CLASS"
For those lookups which use class categories rather than glyph ids for matching
this is the offset to the class definition used to categories glyphs in the
match string.
.IP "\s-1PRE_CLASS\s0" 4
.IX Item "PRE_CLASS"
This is the offset to the class definition for the before match glyphs
.IP "\s-1POST_CLASS\s0" 4
.IX Item "POST_CLASS"
This is the offset to the class definition for the after match glyphs.
.IP "\s-1ACTION_TYPE\s0" 4
.IX Item "ACTION_TYPE"
This string holds the type of information held in the \s-1ACTION\s0 variable of a \s-1RULE\s0.
It is subclass specific.
.IP "\s-1MATCH_TYPE\s0" 4
.IX Item "MATCH_TYPE"
This holds the type of information in the \s-1MATCH\s0 array of a \s-1RULE\s0. This is subclass
specific.
.IP "\s-1ADJUST\s0" 4
.IX Item "ADJUST"
This corresponds to a single action for all items in a coverage table. The meaning
is subclass specific.
.IP "\s-1CACHE\s0" 4
.IX Item "CACHE"
This key starts with a space
.Sp
A hash of other tables (such as coverage tables, classes, anchors, device tables)
based on the offset given in the subtable to that other information.
Note that the documentation is particularly
unhelpful here in that such tables are given as offsets relative to the
beginning of the subtable not the whole \s-1GSUB\s0 table. This includes those items which
are stored relative to another base within the subtable.
.SH "METHODS"
.IX Header "METHODS"
.Sh "$t\->read"
.IX Subsection "$t->read"
Reads the table passing control to the subclass to handle the subtable specifics
.ie n .Sh "$t\->read_sub($fh, $lookup\fP, \f(CW$index)"
.el .Sh "$t\->read_sub($fh, \f(CW$lookup\fP, \f(CW$index\fP)"
.IX Subsection "$t->read_sub($fh, $lookup, $index)"
This stub is to allow subclasses to read subtables of lookups in a table specific manner. A
reference to the lookup is passed in along with the subtable index. The file is located at the
start of the subtable to be read
.Sh "$t\->\fIextension()\fP"
.IX Subsection "$t->extension()"
Returns the lookup number for the extension table that allows access to 32\-bit offsets.
.Sh "$t\->out($fh)"
.IX Subsection "$t->out($fh)"
Writes this Opentype table to the output calling \f(CW$t\fR\->out_sub for each sub table
at the appropriate point in the output. The assumption is that on entry the
number of scripts, languages, features, lookups, etc. are all resolved and
the relationships fixed. This includes a script's \s-1LANG_TAGS\s0 list and that all
scripts and languages in their respective dictionaries either have a \s-1REFTAG\s0 or contain
real data.
.Sh "$t\->num_sub($lookup)"
.IX Subsection "$t->num_sub($lookup)"
Asks the subclass to count the number of subtables for a particular lookup and to
return that value. Used in \fIout()\fR.
.ie n .Sh "$t\->out_sub($fh, $lookup\fP, \f(CW$index)"
.el .Sh "$t\->out_sub($fh, \f(CW$lookup\fP, \f(CW$index\fP)"
.IX Subsection "$t->out_sub($fh, $lookup, $index)"
This stub is to allow subclasses to output subtables of lookups in a table specific manner. A
reference to the lookup is passed in along with the subtable index. The file is located at the
start of the subtable to be output
.SH "Internal Functions & Methods"
.IX Header "Internal Functions & Methods"
Most of these methods are used by subclasses for handling such things as coverage
tables.
.Sh "copy($ref)"
.IX Subsection "copy($ref)"
Internal function to copy the top level of a dictionary to create a new dictionary.
Only the top level is copied.
.ie n .Sh "$t\->read_cover($cover_offset, $lookup_loc\fP, \f(CW$lookup\fP, \f(CW$fh\fP, \f(CW$is_cover)"
.el .Sh "$t\->read_cover($cover_offset, \f(CW$lookup_loc\fP, \f(CW$lookup\fP, \f(CW$fh\fP, \f(CW$is_cover\fP)"
.IX Subsection "$t->read_cover($cover_offset, $lookup_loc, $lookup, $fh, $is_cover)"
Reads a coverage table and stores the results in \f(CW$lookup\fR\->{' \s-1CACHE\s0'}, that is, if
it hasn't been read already.
.ie n .Sh "ref_cache($obj, $cache\fP, \f(CW$offset)"
.el .Sh "ref_cache($obj, \f(CW$cache\fP, \f(CW$offset\fP)"
.IX Subsection "ref_cache($obj, $cache, $offset)"
Internal function to keep track of the local positioning of subobjects such as
coverage and class definition tables, and their offsets.
What happens is that the cache is a hash of
sub objects indexed by the reference (using a string mashing of the
reference name which is valid for the duration of the reference) and holds a
list of locations in the output string which should be filled in with the
offset to the sub object when the final string is output in out_final.
.PP
Uses tricks for Tie::Refhash
.ie n .Sh "out_final($fh, $out\fP, \f(CW$cache_list\fP, \f(CW$state)"
.el .Sh "out_final($fh, \f(CW$out\fP, \f(CW$cache_list\fP, \f(CW$state\fP)"
.IX Subsection "out_final($fh, $out, $cache_list, $state)"
Internal function to actually output everything to the file handle given that
now we know the offset to the first sub object to be output and which sub objects
are to be output and what locations need to be updated, we can now
generate everything. \f(CW$cache_list\fR is an array of two element arrays. The first element
is a cache object, the second is an offset to be subtracted from each reference
to that object made in the cache.
.PP
If \f(CW$state\fR is 1, then the output is not sent to the filehandle and the return value
is the string to be output. If \f(CW$state\fR is absent or 0 then output is not limited
by storing in a string first and the return value is "";
.ie n .Sh "$self\->read_context($lookup, $fh\fP, \f(CW$type\fP, \f(CW$fmt\fP, \f(CW$cover\fP, \f(CW$count\fP, \f(CW$loc)"
.el .Sh "$self\->read_context($lookup, \f(CW$fh\fP, \f(CW$type\fP, \f(CW$fmt\fP, \f(CW$cover\fP, \f(CW$count\fP, \f(CW$loc\fP)"
.IX Subsection "$self->read_context($lookup, $fh, $type, $fmt, $cover, $count, $loc)"
Internal method to read context (simple and chaining context) lookup subtables for
the \s-1GSUB\s0 and \s-1GPOS\s0 table types. The assumed values for \f(CW$type\fR correspond to those
for \s-1GSUB\s0, so \s-1GPOS\s0 should adjust the values upon calling.
.ie n .Sh "$self\->out_context($lookup, $fh\fP, \f(CW$type\fP, \f(CW$fmt\fP, \f(CW$ctables\fP, \f(CW$out\fP, \f(CW$num)"
.el .Sh "$self\->out_context($lookup, \f(CW$fh\fP, \f(CW$type\fP, \f(CW$fmt\fP, \f(CW$ctables\fP, \f(CW$out\fP, \f(CW$num\fP)"
.IX Subsection "$self->out_context($lookup, $fh, $type, $fmt, $ctables, $out, $num)"
Provides shared behaviour between \s-1GSUB\s0 and \s-1GPOS\s0 tables during output for context
(chained and simple) rules. In addition, support is provided here for type 4 \s-1GSUB\s0
tables, which are not used in \s-1GPOS\s0. The value for \f(CW$type\fR corresponds to the type
in a \s-1GSUB\s0 table so calling from \s-1GPOS\s0 should adjust the value accordingly.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
No way to share cachable items (coverage tables, classes, anchors, device tables)
across different lookups. The items are always output after the lookup and
repeated if necessary. Within lookup sharing is possible.
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Hosken Martin_Hosken@sil.org. See PDF::API2::Basic::TTF::Font for copyright and
licensing.

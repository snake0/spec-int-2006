.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PDF::API2::Basic::TTF::Kern 3"
.TH PDF::API2::Basic::TTF::Kern 3 "2014-04-08" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
PDF::API2::Basic::TTF::Kern \- Kerning tables
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Kerning tables are held as an ordered collection of subtables each giving
incremental information regarding the kerning of various pairs of glyphs.
.PP
The basic structure of the kerning data structure is:
.PP
.Vb 1
\&    $kern = $f->{'kern'}{'tables'}[$tnum]{'kerns'}{$leftnum}{$rightnum};
.Ve
.PP
Due to the possible complexity of some kerning tables the above information
is insufficient. Reference also needs to be made to the type of the table and
the coverage field.
.SH "INSTANCE VARIABLES"
.IX Header "INSTANCE VARIABLES"
The instance variables for a kerning table are relatively straightforward.
.IP "Version" 4
.IX Item "Version"
Version number of the kerning table
.IP "Num" 4
.IX Item "Num"
Number of subtables in the kerning table
.IP "tables" 4
.IX Item "tables"
Array of subtables in the kerning table
.RS 4
.Sp
.RS 4
Each subtable has a number of instance variables.
.RE
.IP "kern" 4
.IX Item "kern"
A two level hash array containing kerning values. The indexing is left
value and then right value. In the case of type 2 tables, the indexing
is via left class and right class. It may seem using hashes is strange,
but most tables are not type 2 and this method saves empty array values.
.IP "type" 4
.IX Item "type"
Stores the table type. Only type 0 and type 2 tables are specified for
TrueType so far.
.IP "coverage" 4
.IX Item "coverage"
A bit field of coverage information regarding the kerning value. See the
TrueType specification for details.
.IP "Version" 4
.IX Item "Version"
Contains the version number of the table.
.IP "Num" 4
.IX Item "Num"
Number of kerning pairs in this type 0 table.
.IP "left" 4
.IX Item "left"
An array indexed by glyph \- left_first which returns a class number for
the glyph in type 2 tables.
.IP "right" 4
.IX Item "right"
An array indexed by glyph \- right_first which returns a class number for
the glyph in type 2 tables.
.IP "left_first" 4
.IX Item "left_first"
the glyph number of the first element in the left array for type 2 tables.
.IP "right_first" 4
.IX Item "right_first"
the glyph number of the first element in the right array for type 2 tables.
.IP "num_left" 4
.IX Item "num_left"
Number of left classes
.IP "num_right" 4
.IX Item "num_right"
Number of right classes
.RE
.RS 4
.RE
.SH "METHODS"
.IX Header "METHODS"
.Sh "$t\->read"
.IX Subsection "$t->read"
Reads the whole kerning table into structures
.Sh "$t\->out($fh)"
.IX Subsection "$t->out($fh)"
Outputs the kerning tables to the given file
.ie n .Sh "$t\->XML_element($context, $depth\fP, \f(CW$key\fP, \f(CW$value)"
.el .Sh "$t\->XML_element($context, \f(CW$depth\fP, \f(CW$key\fP, \f(CW$value\fP)"
.IX Subsection "$t->XML_element($context, $depth, $key, $value)"
Handles outputting the kern hash into \s-1XML\s0 a little more tidily
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
Only supports kerning table types 0 & 2.
.IP "\(bu" 4
No real support functions to \fIdo\fR anything with the kerning tables yet.
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Hosken Martin_Hosken@sil.org. See PDF::API2::Basic::TTF::Font for copyright and
licensing.

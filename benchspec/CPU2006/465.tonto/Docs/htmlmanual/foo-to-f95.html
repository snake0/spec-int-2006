<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>What foo does to produce Fortran95 code</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Tonto"
HREF="index.html"><LINK
REL="UP"
TITLE="The foo preprocessor"
HREF="foo-chap.html"><LINK
REL="PREVIOUS"
TITLE="Rules for valid foo preprocessor code"
HREF="foo-rules.html"><LINK
REL="NEXT"
TITLE="Writing foo modules for TONTO"
HREF="foo-modules.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="../tonto.css"><META
NAME="robots"
CONTENT="noindex,nofollow"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="10"
BGCOLOR="#DDDDEE"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Tonto</TH
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="foo-rules.html"
ACCESSKEY="P"
> &#60;&#60; Previous</A
></TD
><TD
WIDTH="33%"
ALIGN="center"
BGCOLOR="#DDDDEE"
VALIGN="bottom"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="foo-modules.html"
ACCESSKEY="N"
>Next &#62;&#62; </A
></TD
></TR
></TABLE
><IMG
SRC="../hr.png"
HEIGHT="10"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FOO-TO-F95"
></A
>What <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> does to produce Fortran95 code</H1
><P
ALIGN="justify"
>The actual text transformations that are performed by the <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
>
preprocessor are now described.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTOMATIC-FUNCTIONS"
></A
>Automatic <TT
CLASS="LITERAL"
>function</TT
> and <TT
CLASS="LITERAL"
>subroutine</TT
>
detection</H2
><P
></P
><UL
><LI
><P
ALIGN="justify"
>The keyword <TT
CLASS="LITERAL"
>function</TT
> is automatically
prepended to every <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> routine name contained in a module or program which
uses the <TT
CLASS="LITERAL"
>result</TT
> syntax.  Otherwise the routine is assumed to
be a subroutine, and the <TT
CLASS="LITERAL"
>subroutine</TT
> keyword is
prepended.</P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SELF-ARGUMENTS"
></A
>Automatic insertion of first argument to a routine</H2
><P
></P
><UL
><LI
><P
ALIGN="justify"
>A dummy variable <TT
CLASS="LITERAL"
>self</TT
> is automatically
inserted as the first argument of every <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> routine.</P
></LI
><LI
><P
ALIGN="justify"
>Every <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> routine contained in a module
<TT
CLASS="LITERAL"
>XXXX</TT
> which is not deemed to be a functional or subroutinal
(see <A
HREF="foo-to-f95.html#FUNCTIONALS-SUBROUTINALS"
>the Section called <I
>Functionals and subroutinals</I
></A
>&#62;) has appended a type declaration
of the form <TT
CLASS="LITERAL"
>XXXX :: self</TT
>.</P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN6974"
></A
><P
></P
><P
ALIGN="justify"
>The following transformation is performed by <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> on routine
<TT
CLASS="LITERAL"
>arcsin</TT
> in module <TT
CLASS="LITERAL"
>REAL</TT
>
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6979"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>arcsin result(res)</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>function arcsin(self) result(res); REAL :: self</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></P
><P
></P
></DIV
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="END-COMPLETION"
></A
>Automatic <TT
CLASS="LITERAL"
>end</TT
> keyword completion</H2
><P
></P
><UL
><LI
><P
ALIGN="justify"
>The <TT
CLASS="LITERAL"
>end</TT
> keyword may be substituted for
<TT
CLASS="LITERAL"
>end do</TT
>, <TT
CLASS="LITERAL"
>end if</TT
>, <TT
CLASS="LITERAL"
>end
subroutine</TT
>, <TT
CLASS="LITERAL"
>end function</TT
>, <TT
CLASS="LITERAL"
>end
module</TT
>, <TT
CLASS="LITERAL"
>end select</TT
> <TT
CLASS="LITERAL"
>end type</TT
>,
<TT
CLASS="LITERAL"
>end interface</TT
>.</P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7004"
></A
><P
></P
><P
ALIGN="justify"
>The following transformation is performed by <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> :
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7007"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>do i = 1,.n_shell
   n_bf = n_bf + shell(i).n_bf
end</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>do i = 1,self%n_shell
   n_bf = n_bf + n_bf_(shell(i))
end do</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></P
><P
></P
></DIV
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DOT-NOTATION"
></A
>Dot notation</H2
><P
></P
><UL
><LI
><P
ALIGN="justify"
>In module <TT
CLASS="LITERAL"
>XXXX</TT
>, if <TT
CLASS="LITERAL"
>x</TT
>,
<TT
CLASS="LITERAL"
>y</TT
>, <TT
CLASS="LITERAL"
>...</TT
>, <TT
CLASS="LITERAL"
>z</TT
> stand for
allowed Fortran95 names, and if <TT
CLASS="LITERAL"
>x</TT
> is the name of a record of
the derived type <TT
CLASS="LITERAL"
>xxxx_type</TT
> used in that module, and defined
in file <TT
CLASS="LITERAL"
>types.foo</TT
>, then the following transformation is
performed:
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7030"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>.x(y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>self%x(y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
If <TT
CLASS="LITERAL"
>x</TT
> is <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> the name of a record of the
derived type used in the module, and if <TT
CLASS="LITERAL"
>.x(y, ... , z)</TT
> is
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> part of an expression, then following transformation is
performed:
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7044"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>.x(y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>call x_(self,y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
If <TT
CLASS="LITERAL"
>x</TT
> is <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> the name of a record of the
derived type used in the module, and if <TT
CLASS="LITERAL"
>.x(y, ... , z)</TT
>
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>is</I
></SPAN
> part of an expression, then the following transformation
is performed:
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7058"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>.x(y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>x_(self,y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
<DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7068"
></A
><P
></P
><P
ALIGN="justify"
>Within module <TT
CLASS="LITERAL"
>SHELL</TT
>, the following transformation is
performed on <TT
CLASS="LITERAL"
>.ex</TT
> and <TT
CLASS="LITERAL"
>.n_cc</TT
>, since
<TT
CLASS="LITERAL"
>ex</TT
> and <TT
CLASS="LITERAL"
>n_cc</TT
> are both records of derived
type <TT
CLASS="LITERAL"
>shell_type</TT
>:
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7076"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>.ex(.n_cc)</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>self%ex(self%n_cc)</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
The following transformations are performed on <TT
CLASS="LITERAL"
>.unnormalise</TT
>
and <TT
CLASS="LITERAL"
>.l_chr</TT
> since they are not records of derived
<TT
CLASS="LITERAL"
>shell_type</TT
>:
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7089"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>.unnormalize</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>call unnormalize_(self)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>str = .l_chr</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>str = l_chr_(self)</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></P
><P
></P
></DIV
></P
></LI
><LI
><P
ALIGN="justify"
>If <TT
CLASS="LITERAL"
>x</TT
>, <TT
CLASS="LITERAL"
>y</TT
>,
<TT
CLASS="LITERAL"
>...</TT
>, <TT
CLASS="LITERAL"
>z</TT
> stand for allowed Fortran95 names,
and if <TT
CLASS="LITERAL"
>w</TT
> is the name of a Fortran variable, and if
<TT
CLASS="LITERAL"
>w.x(y, ... , z)</TT
> is <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> part of an
expression, and if <TT
CLASS="LITERAL"
>x</TT
> is a type component of the variable
<TT
CLASS="LITERAL"
>w</TT
> then following transformation is performed:
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7117"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>w.x(y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>w%x(y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
If <TT
CLASS="LITERAL"
>w.x(y, ... , z)</TT
> is <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> part of an
expression, and If <TT
CLASS="LITERAL"
>x</TT
> is <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> a type
component of the variable <TT
CLASS="LITERAL"
>w</TT
> the following transformation is
performed:
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7132"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>w.x(y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>call x_(w,y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
If <TT
CLASS="LITERAL"
>w.x(y, ... , z)</TT
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>is</I
></SPAN
> part of an
expression, then the following and if <TT
CLASS="LITERAL"
>x</TT
> is a type component
of the variable <TT
CLASS="LITERAL"
>w</TT
> then following transformation is performed:
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7146"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>w.x(y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>w%x(y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
If <TT
CLASS="LITERAL"
>w.x(y, ... , z)</TT
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>is</I
></SPAN
> part of an
expression, then the following and if <TT
CLASS="LITERAL"
>x</TT
> is
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> a type component of the variable <TT
CLASS="LITERAL"
>w</TT
>
then following transformation is performed:
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7161"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>w.x(y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>x_(w,y, ... , z)</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>

<DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7171"
></A
><P
></P
><P
ALIGN="justify"
>The following transformations are performed by <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> in module
<TT
CLASS="LITERAL"
>SHELL</TT
>:
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7175"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>e = shell.l*(shell.l+1)/2</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>e = shell%l*(shell%l+1)/2</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>e = shell.ex</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>e = shell%ex</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>e = shell.ex(n)</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>e = shell%ex(n)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>shell.unnormalize</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>call unnormalize_(shell)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>sh.ex(b+1:b+nb).put</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>call put_(sh%ex(b+1:b+nb))</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>e = shell.ex(shell.n_cc)</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>e = shell%ex(shell%n_cc)</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></P
><P
></P
></DIV
>
<DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7220"
></A
><P
></P
><P
ALIGN="justify"
>The dot notation <TT
CLASS="LITERAL"
>.</TT
> can be viewed as a synonym for the
structure separator <TT
CLASS="LITERAL"
>%</TT
>.  They are not the same, however, since
the internal type structure of the variable <TT
CLASS="LITERAL"
>shell</TT
> may change
at some later date so that component <TT
CLASS="LITERAL"
>shell%ex</TT
> is no longer
present.  A routine <TT
CLASS="LITERAL"
>ex_(shell)</TT
> can always be arranged to
exist to simulate the missing structure component. This greatly facilitates the
maintainability of the code supposing that the internal structure of the type
changes. However, it should be kept in mind for compute intensive routines that
the <TT
CLASS="LITERAL"
>%</TT
> notation is more efficient than a routine call.</P
><P
></P
></DIV
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTOMATIC-OVERLOADING"
></A
>Automatic overloading and interface files</H2
><P
></P
><UL
><LI
><P
ALIGN="justify"
>A generic interface file <TT
CLASS="LITERAL"
>xxxx.int</TT
> is
automatically generated for module <TT
CLASS="LITERAL"
>XXXX</TT
>, The generic name
used for every routine <TT
CLASS="LITERAL"
>f</TT
> in the module is
<TT
CLASS="LITERAL"
>f_</TT
>.</P
></LI
><LI
><P
ALIGN="justify"
>If the same routine name <TT
CLASS="LITERAL"
>f</TT
> appears in a
module or program <TT
CLASS="LITERAL"
>(k+1)</TT
> times, then <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> changes these names
into the Fortran95 names <TT
CLASS="LITERAL"
>f</TT
>, <TT
CLASS="LITERAL"
>f_1</TT
>,
<TT
CLASS="LITERAL"
>...</TT
>, <TT
CLASS="LITERAL"
>f_k</TT
>.

<DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7246"
></A
><P
></P
><P
ALIGN="justify"
>The following transformation is performed by <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> on the overloaded routine
names <TT
CLASS="LITERAL"
>read</TT
> in module <TT
CLASS="LITERAL"
>ARCHIVE</TT
>. Both
routines are called by the single generic name <TT
CLASS="LITERAL"
>read_</TT
>.
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7252"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>read(item,kind)
   REALVEC :: item
   ...</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>subroutine read(self,item,kind); ARCHIVE :: self
   REALVEC :: item
   ...</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>read(item,kind)
   CPXVEC :: item
   ...</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>subroutine read(self,item,kind); ARCHIVE :: self
   CPXVEC :: item
   ...</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></P
><P
></P
></DIV
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="EXPLICIT-OVERLOADING"
></A
>Explicit overloading</H2
><P
></P
><UL
><LI
><P
ALIGN="justify"
>The <TT
CLASS="LITERAL"
>module procedure</TT
> keyword is automatically
inserted within any explicit generic interface definition appearing in a module.

<DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7275"
></A
><P
></P
><P
ALIGN="justify"
>The following transformation is performed by <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> :
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7278"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>interface f
   fa, fb, fc, ...
end</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>interface f_
   module procedure fa, fb, fc, ...
end interface</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></P
><P
></P
></DIV
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTION-ATTRIBUTES"
></A
>New syntax for <TT
CLASS="LITERAL"
>recursive</TT
>, <TT
CLASS="LITERAL"
>pure</TT
> and
<TT
CLASS="LITERAL"
>elemental</TT
> routines</H2
><P
></P
><UL
><LI
><P
ALIGN="justify"
>If the string <TT
CLASS="LITERAL"
>[recursive]</TT
> appears at the end
of the line where the routine name appears, the routine is deemed recursive, and
the keyword <TT
CLASS="LITERAL"
>recursive</TT
> is placed before the keyword
<TT
CLASS="LITERAL"
>function</TT
> or <TT
CLASS="LITERAL"
>subroutine</TT
> in the emitted
Fortran95 code.</P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7300"
></A
><P
></P
><P
ALIGN="justify"
>In module <TT
CLASS="LITERAL"
>XXXX</TT
>, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> performs the following
transformation on the recursive routine shown below:
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7304"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>f(y, ... , z) result(w) [recursive]</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>recursive function f(self,y, ... , z) result(w); XXXX :: self</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></P
><P
></P
></DIV
></LI
><LI
><P
ALIGN="justify"
>If the string <TT
CLASS="LITERAL"
>[pure]</TT
> appears at the end of
the line where the routine name appears, the routine is deemed conditionally
pure, and the keyword <TT
CLASS="LITERAL"
>PURE</TT
> is placed before the keyword
<TT
CLASS="LITERAL"
>function</TT
> or <TT
CLASS="LITERAL"
>subroutine</TT
> in the emitted
Fortran95 code. The attribute <TT
CLASS="LITERAL"
>intent(in)</TT
> is also added to the
first argument <TT
CLASS="LITERAL"
>self</TT
>.</P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7322"
></A
><P
></P
><P
ALIGN="justify"
>A conditionally pure routine is one that can be declared
<TT
CLASS="LITERAL"
>pure</TT
> or not when the routine is compiled. In this way, write
statements may easily be placed within the routines, and later removed, for
debugging purposes.</P
><P
></P
></DIV
></LI
><LI
><P
ALIGN="justify"
>If the string <TT
CLASS="LITERAL"
>[PURE]</TT
> appears at the end of
the line where the routine name appears, the routine is deemed unconditionally
pure, and the keyword <TT
CLASS="LITERAL"
>pure</TT
> is placed before the keyword
<TT
CLASS="LITERAL"
>function</TT
> or <TT
CLASS="LITERAL"
>subroutine</TT
> in the emitted
Fortran95 code. The attribute <TT
CLASS="LITERAL"
>intent(in)</TT
> is also added to the
first argument <TT
CLASS="LITERAL"
>self</TT
>.

<DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7333"
></A
><P
></P
><P
ALIGN="justify"
>An unconditionally <TT
CLASS="LITERAL"
>pure</TT
> routine is one that must always
<TT
CLASS="LITERAL"
>pure</TT
> at compile time. This may be required, for example, for
routines which are used in the specification part of a variable
declaration.</P
><P
></P
></DIV
></P
></LI
><LI
><P
ALIGN="justify"
>If the string <TT
CLASS="LITERAL"
>[elemental]</TT
> appears at the end
of the line where the routine name appears, the routine is deemed conditionally
elemental, and the keyword <TT
CLASS="LITERAL"
>ELEMENTAL</TT
> is placed before the
keyword <TT
CLASS="LITERAL"
>function</TT
> or <TT
CLASS="LITERAL"
>subroutine</TT
> in the
emitted Fortran95 code. The attribute <TT
CLASS="LITERAL"
>intent(in)</TT
> is also
added to the first argument <TT
CLASS="LITERAL"
>self</TT
>.</P
></LI
><LI
><P
ALIGN="justify"
>If the string <TT
CLASS="LITERAL"
>[ELEMENTAL]</TT
> appears at the end
of the line where the routine name appears, the routine is deemed
unconditionally elemental, and the keyword <TT
CLASS="LITERAL"
>elemental</TT
> is
placed before the keyword <TT
CLASS="LITERAL"
>function</TT
> or
<TT
CLASS="LITERAL"
>subroutine</TT
> in the emitted Fortran95 code. The attribute
<TT
CLASS="LITERAL"
>intent(in)</TT
> is also added to the first argument
<TT
CLASS="LITERAL"
>self</TT
>.  In module <TT
CLASS="LITERAL"
>XXXX</TT
>, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> performs the
following transformation on the recursive routine shown below:</P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7355"
></A
><P
></P
><P
ALIGN="justify"
>In module <TT
CLASS="LITERAL"
>XXXX</TT
>, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> performs the following
transformation on the elemental routine shown below:
<DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7359"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>f(y, ... , z) result(w) [elemental]</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>elemental function f(self,y, ... , z) result(w); XXXX, IN :: self</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
The macro <TT
CLASS="LITERAL"
>IN</TT
>, which stands for <TT
CLASS="LITERAL"
>intent(in)</TT
>, is also added 
as an attribute in the declaration for <TT
CLASS="LITERAL"
>self</TT
>.</P
><P
></P
></DIV
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONALS-SUBROUTINALS"
></A
>Functionals and subroutinals</H2
><P
></P
><UL
><LI
><P
ALIGN="justify"
>In a module <TT
CLASS="LITERAL"
>XXXX</TT
>, if the string
<TT
CLASS="LITERAL"
>[functional]</TT
> appears at the end of the line where a function
name appears, the function is deemed to be a functional, meaning that its first
argument <TT
CLASS="LITERAL"
>self</TT
> is a routine, and the automatic declaration
<TT
CLASS="LITERAL"
>XXXX :: self</TT
> is suppressed.</P
></LI
><LI
><P
ALIGN="justify"
>In a module <TT
CLASS="LITERAL"
>XXXX</TT
>, if the string
<TT
CLASS="LITERAL"
>[subroutinal]</TT
> appears at the end of the line where a
subroutine name appears, the subroutine is deemed to be a subroutinal, meaning
that its first argument <TT
CLASS="LITERAL"
>self</TT
> is a routine, and the automatic
declaration <TT
CLASS="LITERAL"
>XXXX :: self</TT
> is suppressed.</P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7387"
></A
><P
></P
><P
ALIGN="justify"
>The reason for declaring a functional or subroutinal explicitly is that
the automatic declaration of the first argument, <TT
CLASS="LITERAL"
>self</TT
>, must
be suppressed, in order that it does not conflict with the required explicit
interface for the routine <TT
CLASS="LITERAL"
>self</TT
>. In addition, the intention of
the routine is made clearer.</P
><P
></P
></DIV
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7391"
></A
><P
></P
><P
ALIGN="justify"
>In module REAL, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> performs the following transformation on the
functional shown below:</P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7394"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>integrate(self,a,b,accuracy) result(res) [recursive] [functional]</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>recursive function integrate(self,a,b,accuracy) result(res)</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
ALIGN="justify"
>In addition, an explicit <TT
CLASS="LITERAL"
>interface</TT
> must be defined
for <TT
CLASS="LITERAL"
>self</TT
>, which is transformed as shown:</P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7407"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      interface
         self(x) result(res)
            REAL :: x,res
         end
      end</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   interface
      function self(x) result(res)
         REAL :: x,res
      end function
   end interface</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
></P
></DIV
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ERROR-MANAGEMENT"
></A
>Preconditions, postconditions, and error management facilities</H2
><P
></P
><UL
><LI
><P
ALIGN="justify"
>If the macro <TT
CLASS="LITERAL"
>ENSURE(cond,"message")</TT
>,
<TT
CLASS="LITERAL"
>DIE_IF(cond,"message")</TT
>, or
<TT
CLASS="LITERAL"
>WARN_IF(cond,"message")</TT
> appears in routine
<TT
CLASS="LITERAL"
>f</TT
> of module <TT
CLASS="LITERAL"
>XXXX</TT
>, where
<TT
CLASS="LITERAL"
>cond</TT
> stands for a logical expression and
<TT
CLASS="LITERAL"
>message</TT
> stands for the text of some error message, then <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
>
will insert the name of the module and routine at the beginning of the error
message text, yielding the new error message text
<TT
CLASS="LITERAL"
>"in XXXX:f ... message"</TT
></P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7431"
></A
><P
></P
><P
ALIGN="justify"
>In routine <TT
CLASS="LITERAL"
>read</TT
> of module <TT
CLASS="LITERAL"
>MOL</TT
>, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
>
changes the precondition macro <TT
CLASS="LITERAL"
>ENSURE</TT
> as follows:</P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7437"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>ENSURE(word=="name","first keyword must be name")</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>ENSURE(word=="name","in MOL:read ... first keyword must be name")</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
ALIGN="justify"
>If the <SPAN
CLASS="QUOTE"
>"first keyword is not name"</SPAN
>, i.e.
<TT
CLASS="LITERAL"
>word/="name"</TT
>, then the following error message is generated
by routine <TT
CLASS="LITERAL"
>read</TT
> in the output:
<TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>ERROR: in MOL:read ... first keywrord must be name</PRE
></TD
></TR
></TABLE
></P
><P
></P
></DIV
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7452"
></A
><P
></P
><P
ALIGN="justify"
>The macros <TT
CLASS="LITERAL"
>ENSURE</TT
>, <TT
CLASS="LITERAL"
>DIE_IF</TT
>, or
<TT
CLASS="LITERAL"
>WARN_IF</TT
> are commonly used to ensure that a specific set of
conditions hold before the start, or at the end of, a routine. In this way,
errors can be detected and handled at an early stage without propagation. They
are therefore called precondition or postconditon macros. </P
><P
></P
></DIV
></LI
><LI
><P
ALIGN="justify"
>If the macro <TT
CLASS="LITERAL"
>DIE("message")</TT
> or
<TT
CLASS="LITERAL"
>WARN("message")</TT
> appears in routine <TT
CLASS="LITERAL"
>f</TT
> of
module <TT
CLASS="LITERAL"
>XXXX</TT
>, where <TT
CLASS="LITERAL"
>message</TT
> stands for the
text of some error message, then <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> will insert the name of the module and
routine at the beginning of the error message text, yielding the new error
message text <TT
CLASS="LITERAL"
>"in XXXX:f ... message"</TT
></P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7466"
></A
><P
></P
><P
ALIGN="justify"
>The macro <TT
CLASS="LITERAL"
>DIE</TT
> is used for graceful program termination.
The macro <TT
CLASS="LITERAL"
>WARN</TT
> is used to warn of an unusual, and most likely
erroneous situation.</P
><P
></P
></DIV
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="MEMORY-MANAGEMENT"
></A
>Memory and call-stack management</H2
><P
></P
><UL
><LI
><P
ALIGN="justify"
>If the string <TT
CLASS="LITERAL"
>[leaky]</TT
> appears at the end of
the line where the routine name appears, the routine is deemed to be leaky,
meaning that within the body of the routine more memory has been allocated than
deallocated.</P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7476"
></A
><P
></P
><P
ALIGN="justify"
>In module <TT
CLASS="LITERAL"
>MOL</TT
>, the <TT
CLASS="LITERAL"
>read</TT
> routine has
been deemed leaky:
<TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>read [leaky]</PRE
></TD
></TR
></TABLE
></P
><P
></P
></DIV
></LI
><LI
><P
ALIGN="justify"
>Any routine with the string <TT
CLASS="LITERAL"
>create</TT
>, or
<TT
CLASS="LITERAL"
>destroy</TT
> as part of its name is automatically deemed to be
leaky.</P
></LI
><LI
><P
ALIGN="justify"
>For every routine <TT
CLASS="LITERAL"
>f</TT
> in module
<TT
CLASS="LITERAL"
>XXXX</TT
>, the macro <TT
CLASS="LITERAL"
>STACK("XXXX:f")</TT
> is
inserted before the first line of code which is not a precondition
macro.</P
></LI
><LI
><P
ALIGN="justify"
>For every routine <TT
CLASS="LITERAL"
>f</TT
> which is leaky or pure,
the macro <TT
CLASS="LITERAL"
>UNSTACK</TT
> is inserted before the <TT
CLASS="LITERAL"
>end
function</TT
> or <TT
CLASS="LITERAL"
>end subroutine</TT
> keywords in the last
line of the routine.</P
></LI
><LI
><P
ALIGN="justify"
>For every routine <TT
CLASS="LITERAL"
>f</TT
> which is not leaky or
pure, the macro <TT
CLASS="LITERAL"
>CHECK</TT
> is inserted before the first line of
code which is not a precondition macro.</P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7500"
></A
><P
></P
><P
ALIGN="justify"
>The macro <TT
CLASS="LITERAL"
>STACK(X)</TT
> stands for <TT
CLASS="LITERAL"
>call
stack_(tonto,X)</TT
>. <TT
CLASS="LITERAL"
>tonto</TT
> is a memory and call-stack
manager object used by TONTO. This routine call places the current routine
name <TT
CLASS="LITERAL"
>X</TT
> onto a call stack, which may later be used to print a
call-stack traceback in the event of controlled error. The routine call also
sets to zero a variable which is used to keep track of the memory used in this
routine.  The amount of memory used or released by dynamic allocation is
monitored in the <TT
CLASS="LITERAL"
>tonto</TT
> system variable.</P
><P
></P
></DIV
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7507"
></A
><P
></P
><P
ALIGN="justify"
>The macro <TT
CLASS="LITERAL"
>UNSTACK</TT
> stands for <TT
CLASS="LITERAL"
>call
unstack_(tonto)</TT
>. It removes the current routine name
<TT
CLASS="LITERAL"
>X</TT
> from the call stack.</P
><P
></P
></DIV
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN7512"
></A
><P
></P
><P
ALIGN="justify"
>The macro <TT
CLASS="LITERAL"
>CHECK</TT
> stands for <TT
CLASS="LITERAL"
>call
check_(tonto)</TT
>. It removes the current routine name
<TT
CLASS="LITERAL"
>X</TT
> from the stack and checks if the routine has a memory leak
or not, by examining the memory usage variable for the routine.</P
><P
></P
></DIV
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="C-PREPROCESSORT"
></A
>C-preprocessor macros and type definitions</H2
><P
></P
><UL
><LI
><P
ALIGN="justify"
>The following transformations are made by
<TT
CLASS="LITERAL"
>foo</TT
></P
><P
ALIGN="justify"
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7524"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="90%"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>STR</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>STR(STR_SIZE)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>BSTR</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>STR(BSTR_SIZE)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>TRI</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>TRI(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALVEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALVEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALVECVEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALVECVEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>INTVEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>INTVEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>IVECVEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>IVECVEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CPXVEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CPXVEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMATVEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMATVEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMAT3VEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMAT3VEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMAT4VEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMAT4VEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>STRVEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>STRVEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>BINVEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>BINVEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>FILEVEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>FILEVEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>SHELLVEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>SHELLVEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>BASISVEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>BASISVEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>ATOMVEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>ATOMVEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>IRREPVEC</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>IRREPVEC(:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMAT</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMAT(:,:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMAT3</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMAT3(:,:,:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMAT4</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMAT4(:,:,:,:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMAT5</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>REALMAT5(:,:,:,:,:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>INTMAT</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>INTMAT(:,:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>INTMAT3</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>INTMAT3(:,:,:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>INTMAT4</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>INTMAT4(:,:,:,:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CPXMAT</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CPXMAT(:,:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CPXMAT3</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CPXMAT3(:,:,:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CPXMAT4</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CPXMAT4(:,:,:,:)</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CPXMAT5</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>--&#62;</PRE
></TD
></TR
></TABLE
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TABLE
BORDER="0"
BGCOLOR="#DDDDEE"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CPXMAT5(:,:,:,:,:)</PRE
></TD
></TR
></TABLE
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></P
></LI
><LI
><P
ALIGN="justify"
>The C preprocessor macros defined in the
<TT
CLASS="LITERAL"
>macros</TT
> file shall constitute part of the definition of the
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> language.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><BR><IMG
SRC="../hr.png"
HEIGHT="10"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="10"
BGCOLOR="#DDDDEE"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="foo-rules.html"
ACCESSKEY="P"
> &#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="foo-modules.html"
ACCESSKEY="N"
>Next &#62;&#62; </A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="JUSTIFY"
VALIGN="top"
>Rules for valid <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> preprocessor code</TD
><TD
WIDTH="34%"
ALIGN="center"
BGCOLOR="#DDDDEE"
VALIGN="top"
><A
HREF="foo-chap.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="JUSTIFY"
VALIGN="top"
>Writing <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>foo</I
></SPAN
> modules for TONTO</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
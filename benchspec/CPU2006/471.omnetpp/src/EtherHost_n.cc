//-----------------------------------------
//
// Generated by NEDC version 2.3
// date:	Tue May 18 19:06:56 2004
//
// Input file:	EtherLLC.ned
// Output file:	EtherLLC_n.cc
//-----------------------------------------


#if defined(SPEC_CPU)
#include <cmath>
#else
#include <math.h>
#endif
#include "omnetpp.h"

#define check_error() \
    {(void)0;}
#define check_memory() \
    {if (memoryIsLow()) {throw new cException(eNOMEM); }}
#define check_module_count(num, mod, parentmod) \
    {if ((int)num<=0) {throw new cException("Negative or zero module vector size %s[%d] in compound module %s", \
                          mod,(int)num,parentmod);}}
#define check_gate_count(num, mod, gate, parentmod) \
    {if ((int)num<0) {throw new cException("Negative gate vector size %s.%s[%d] in compound module %s", \
                          mod,gate,(int)num,parentmod);}}
#define check_loop_bounds(lower, upper, parentmod) \
    {if ((int)lower<0) \
        {throw new cException("Bad loop bounds (%d..%d) in compound module %s", \
                 (int)lower,(int)upper,parentmod);}}
#define check_module_index(index,modvar,modname,parentmod) \
    {if (index<0 || index>=modvar[0]->size()) {throw new cException("Bad submodule index %s[%d] in compound module %s", \
          modname,(int)index,parentmod);}}
#define check_channel_params(delay, err, channel) \
    {if ((double)delay<0.0) \
        {throw new cException("Negative delay value %lf in channel %s",(double)delay,channel);} \
     if ((double)err<0.0 || (double)err>1.0) \
        {throw new cException("Incorrect error value %lf in channel %s",(double)err,channel);}}
#define check_modtype(modtype, modname) \
    {if ((modtype)==NULL) {throw new cException("Simple module type definition %s not found", \
                                     modname);}}
#define check_function(funcptr, funcname) \
    {if ((funcptr)==NULL) {throw new cException("Function %s not found", \
                                     funcname);}}
#define check_function_retnull(funcptr, funcname) \
    {if ((funcptr)==NULL) {throw new cException("Function %s not found", \
                                     funcname);return NULL;}}
#define check_gate(gateindex, modname, gatename) \
    {if ((int)gateindex==-1) {throw new cException("Gate %s.%s not found",modname,gatename);}}
#define check_anc_param(ptr,parname,compoundmod) \
    {if ((ptr)==NULL) {throw new cException("Unknown ancestor parameter named %s in compound module %s", \
                                parname,compoundmod);}}
#define check_param(ptr,parname) \
    {if ((ptr)==NULL) {throw new cException("Unknown parameter named %s", \
                                parname);}}
#ifndef __cplusplus
#  error Compile as C++!
#endif
#ifdef __BORLANDC__
#  if !defined(__FLAT__) && !defined(__LARGE__)
#    error Compile as 16-bit LARGE model or 32-bit DPMI!
#  endif
#endif

// Disable warnings about unused variables:
#ifdef _MSC_VER
#  pragma warning(disable:4101)
#endif
#ifdef __BORLANDC__
#  pragma warn -waus
#  pragma warn -wuse
#endif
// for GCC, seemingly there's no way to emulate the -Wunused command-line
// flag from a source file...

// Version check
#define NEDC_VERSION 0x0203
#if (NEDC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedc: 'make clean' should help.
#endif

//--------------------------------------------
// Following code generated from: EtherHost.ned
//--------------------------------------------

ModuleInterface( EtherHost )
	Machine( default )
	Gate( in, GateDir_Input )
	Gate( out, GateDir_Output )
EndInterface

Register_ModuleInterface( EtherHost )

class EtherHost : public cCompoundModule
{
  public:
    EtherHost(const char *name, cModule *parentmod) :
      cCompoundModule(name, parentmod) {}
  protected:
    virtual void doBuildInside();
};

Define_Module( EtherHost );

void EtherHost::doBuildInside()
{
	cModule *mod = this;
	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// Submodules:
	cModuleType *modtype = NULL;
	long sub_nr = 0;
	long sub_i = 0;

	// cli
	modtype = findModuleType( "EtherAppCli" );
	check_modtype( modtype, "EtherAppCli" );
	cModule *cli_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	cli_mod = modtype->create( "cli", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	cli_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = cli_mod->params();
	for(k=0;k<n;k++)
	   if(cli_mod->par(k).isInput())
	      {cli_mod->par(k).read();check_error();}

	cli_mod->setDisplayString(dispSUBMOD, "p=60,60,col" );

	// build function call:
	cli_mod->buildInside();
	machines.clear();

	// srv
	modtype = findModuleType( "EtherAppSrv" );
	check_modtype( modtype, "EtherAppSrv" );
	cModule *srv_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	srv_mod = modtype->create( "srv", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	srv_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = srv_mod->params();
	for(k=0;k<n;k++)
	   if(srv_mod->par(k).isInput())
	      {srv_mod->par(k).read();check_error();}

	srv_mod->setDisplayString(dispSUBMOD, "p=250,60,col" );

	// build function call:
	srv_mod->buildInside();
	machines.clear();

	// llc
	modtype = findModuleType( "EtherLLC" );
	check_modtype( modtype, "EtherLLC" );
	cModule *llc_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	llc_mod = modtype->create( "llc", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	llc_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = llc_mod->params();
	for(k=0;k<n;k++)
	   if(llc_mod->par(k).isInput())
	      {llc_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	n = 2;
	check_gate_count( n, "llc","upperLayerIn","EtherHost");
	llc_mod->setGateSize("upperLayerIn", n );

	n = 2;
	check_gate_count( n, "llc","upperLayerOut","EtherHost");
	llc_mod->setGateSize("upperLayerOut", n );

	llc_mod->setDisplayString(dispSUBMOD, "i=fork;p=155,120" );

	// build function call:
	llc_mod->buildInside();
	machines.clear();

	// mac
	modtype = findModuleType( "EtherMAC" );
	check_modtype( modtype, "EtherMAC" );
	cModule *mac_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	mac_mod = modtype->create( "mac", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	mac_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = mac_mod->params();
	for(k=0;k<n;k++)
	   if(mac_mod->par(k).isInput())
	      {mac_mod->par(k).read();check_error();}

	mac_mod->setDisplayString(dispSUBMOD, "i=queue;p=155,200" );

	// build function call:
	mac_mod->buildInside();
	machines.clear();

	// Connections:
	cLinkType *link_p;
	cPar *delay_p, *error_p, *datarate_p;
	int gateL, gateR;
	long mod_nr_L, mod_nr_R, gate_nr_L, gate_nr_R;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gateL = llc_mod->findGate( "lowerLayerIn" );
	check_gate( gateL, "llc", "lowerLayerIn" );

	gateR = mac_mod->findGate( "upperLayerOut" );
	check_gate( gateR, "mac", "upperLayerOut" );

	connect (mac_mod, gateR,
	         NULL,
	         llc_mod, gateL);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gateL = llc_mod->findGate( "lowerLayerOut" );
	check_gate( gateL, "llc", "lowerLayerOut" );

	gateR = mac_mod->findGate( "upperLayerIn" );
	check_gate( gateR, "mac", "upperLayerIn" );

	connect (llc_mod, gateL,
	         NULL,
	         mac_mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gateL = mac_mod->findGate( "physicalIn" );
	check_gate( gateL, "mac", "physicalIn" );

	gateR = mod->findGate( "in" );
	check_gate( gateR, "", "in" );

	connect (mod, gateR,
	         NULL,
	         mac_mod, gateL);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gateL = mac_mod->findGate( "physicalOut" );
	check_gate( gateL, "mac", "physicalOut" );

	gateR = mod->findGate( "out" );
	check_gate( gateR, "", "out" );

	connect (mac_mod, gateL,
	         NULL,
	         mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gateL = cli_mod->findGate( "out" );
	check_gate( gateL, "cli", "out" );

	gate_nr_R = 0;
	gateR = llc_mod->findGate( "upperLayerIn", gate_nr_R );
	check_gate( gateR, "llc", indexedname(b1,"upperLayerIn",gate_nr_R) );

	connect (cli_mod, gateL,
	         NULL,
	         llc_mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gateL = cli_mod->findGate( "in" );
	check_gate( gateL, "cli", "in" );

	gate_nr_R = 0;
	gateR = llc_mod->findGate( "upperLayerOut", gate_nr_R );
	check_gate( gateR, "llc", indexedname(b1,"upperLayerOut",gate_nr_R) );

	connect (llc_mod, gateR,
	         NULL,
	         cli_mod, gateL);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gateL = srv_mod->findGate( "out" );
	check_gate( gateL, "srv", "out" );

	gate_nr_R = 1;
	gateR = llc_mod->findGate( "upperLayerIn", gate_nr_R );
	check_gate( gateR, "llc", indexedname(b1,"upperLayerIn",gate_nr_R) );

	connect (srv_mod, gateL,
	         NULL,
	         llc_mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gateL = srv_mod->findGate( "in" );
	check_gate( gateL, "srv", "in" );

	gate_nr_R = 1;
	gateR = llc_mod->findGate( "upperLayerOut", gate_nr_R );
	check_gate( gateR, "llc", indexedname(b1,"upperLayerOut",gate_nr_R) );

	connect (llc_mod, gateR,
	         NULL,
	         srv_mod, gateL);

	check_error(); check_memory();
	} // end-if

	mod->checkInternalConnections();
	check_error(); check_memory();
}


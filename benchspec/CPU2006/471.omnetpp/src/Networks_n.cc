//-----------------------------------------
//
// Generated by NEDC version 2.3
// date:	Thu Jun 24 00:10:15 2004
//
// Input file:	MACRelayUnit.ned
// Output file:	MACRelayUnit_n.cc
//-----------------------------------------


#if defined(SPEC_CPU)
#include <cmath>
#else
#include <math.h>
#endif
#include "omnetpp.h"

#define check_error() \
    {(void)0;}
#define check_memory() \
    {if (memoryIsLow()) {throw new cException(eNOMEM); }}
#define check_module_count(num, mod, parentmod) \
    {if ((int)num<=0) {throw new cException("Negative or zero module vector size %s[%d] in compound module %s", \
                          mod,(int)num,parentmod);}}
#define check_gate_count(num, mod, gate, parentmod) \
    {if ((int)num<0) {throw new cException("Negative gate vector size %s.%s[%d] in compound module %s", \
                          mod,gate,(int)num,parentmod);}}
#define check_loop_bounds(lower, upper, parentmod) \
    {if ((int)lower<0) \
        {throw new cException("Bad loop bounds (%d..%d) in compound module %s", \
                 (int)lower,(int)upper,parentmod);}}
#define check_module_index(index,modvar,modname,parentmod) \
    {if (index<0 || index>=modvar[0]->size()) {throw new cException("Bad submodule index %s[%d] in compound module %s", \
          modname,(int)index,parentmod);}}
#define check_channel_params(delay, err, channel) \
    {if ((double)delay<0.0) \
        {throw new cException("Negative delay value %lf in channel %s",(double)delay,channel);} \
     if ((double)err<0.0 || (double)err>1.0) \
        {throw new cException("Incorrect error value %lf in channel %s",(double)err,channel);}}
#define check_modtype(modtype, modname) \
    {if ((modtype)==NULL) {throw new cException("Simple module type definition %s not found", \
                                     modname);}}
#define check_function(funcptr, funcname) \
    {if ((funcptr)==NULL) {throw new cException("Function %s not found", \
                                     funcname);}}
#define check_function_retnull(funcptr, funcname) \
    {if ((funcptr)==NULL) {throw new cException("Function %s not found", \
                                     funcname);return NULL;}}
#define check_gate(gateindex, modname, gatename) \
    {if ((int)gateindex==-1) {throw new cException("Gate %s.%s not found",modname,gatename);}}
#define check_anc_param(ptr,parname,compoundmod) \
    {if ((ptr)==NULL) {throw new cException("Unknown ancestor parameter named %s in compound module %s", \
                                parname,compoundmod);}}
#define check_param(ptr,parname) \
    {if ((ptr)==NULL) {throw new cException("Unknown parameter named %s", \
                                parname);}}
#ifndef __cplusplus
#  error Compile as C++!
#endif
#ifdef __BORLANDC__
#  if !defined(__FLAT__) && !defined(__LARGE__)
#    error Compile as 16-bit LARGE model or 32-bit DPMI!
#  endif
#endif

// Disable warnings about unused variables:
#ifdef _MSC_VER
#  pragma warning(disable:4101)
#endif
#ifdef __BORLANDC__
#  pragma warn -waus
#  pragma warn -wuse
#endif
// for GCC, seemingly there's no way to emulate the -Wunused command-line
// flag from a source file...

// Version check
#define NEDC_VERSION 0x0203
#if (NEDC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedc: 'make clean' should help.
#endif

//--------------------------------------------
// Following code generated from: Networks.ned
//--------------------------------------------

ModuleInterface( MixedLAN )
	Machine( default )
EndInterface

Register_ModuleInterface( MixedLAN )

class MixedLAN : public cCompoundModule
{
  public:
    MixedLAN(const char *name, cModule *parentmod) :
      cCompoundModule(name, parentmod) {}
  protected:
    virtual void doBuildInside();
};

Define_Module( MixedLAN );

void MixedLAN::doBuildInside()
{
	cModule *mod = this;
	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// Submodules:
	cModuleType *modtype = NULL;
	long sub_nr = 0;
	long sub_i = 0;

	// bus
	modtype = findModuleType( "EtherBus" );
	check_modtype( modtype, "EtherBus" );
	cModule *bus_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	bus_mod = modtype->create( "bus", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	bus_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	// 'parameters:' section
	par = &(bus_mod->par("positions"));
	check_param(par, "positions");
	*par = "10 20 24 35 40 48";

	par = &(bus_mod->par("propagationSpeed"));
	check_param(par, "propagationSpeed");
	*par = 200000000;

	n = bus_mod->params();
	for(k=0;k<n;k++)
	   if(bus_mod->par(k).isInput())
	      {bus_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	n = 6;
	check_gate_count( n, "bus","in","MixedLAN");
	bus_mod->setGateSize("in", n );

	n = 6;
	check_gate_count( n, "bus","out","MixedLAN");
	bus_mod->setGateSize("out", n );

	bus_mod->setDisplayString(dispSUBMOD, "p=277,182;b=424,6;o=#408060" );

	// build function call:
	bus_mod->buildInside();
	machines.clear();

	// busHostA
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *busHostA_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	busHostA_mod = modtype->create( "busHostA", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	busHostA_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = busHostA_mod->params();
	for(k=0;k<n;k++)
	   if(busHostA_mod->par(k).isInput())
	      {busHostA_mod->par(k).read();check_error();}

	busHostA_mod->setDisplayString(dispSUBMOD, "p=122,118;i=pc" );

	// build function call:
	busHostA_mod->buildInside();
	machines.clear();

	// busHostB
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *busHostB_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	busHostB_mod = modtype->create( "busHostB", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	busHostB_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = busHostB_mod->params();
	for(k=0;k<n;k++)
	   if(busHostB_mod->par(k).isInput())
	      {busHostB_mod->par(k).read();check_error();}

	busHostB_mod->setDisplayString(dispSUBMOD, "p=210,118;i=pc" );

	// build function call:
	busHostB_mod->buildInside();
	machines.clear();

	// busHostC
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *busHostC_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	busHostC_mod = modtype->create( "busHostC", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	busHostC_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = busHostC_mod->params();
	for(k=0;k<n;k++)
	   if(busHostC_mod->par(k).isInput())
	      {busHostC_mod->par(k).read();check_error();}

	busHostC_mod->setDisplayString(dispSUBMOD, "p=338,238;i=pc" );

	// build function call:
	busHostC_mod->buildInside();
	machines.clear();

	// busHostD
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *busHostD_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	busHostD_mod = modtype->create( "busHostD", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	busHostD_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = busHostD_mod->params();
	for(k=0;k<n;k++)
	   if(busHostD_mod->par(k).isInput())
	      {busHostD_mod->par(k).read();check_error();}

	busHostD_mod->setDisplayString(dispSUBMOD, "p=426,238;i=pc" );

	// build function call:
	busHostD_mod->buildInside();
	machines.clear();

	// switchHostA
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *switchHostA_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	switchHostA_mod = modtype->create( "switchHostA", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	switchHostA_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = switchHostA_mod->params();
	for(k=0;k<n;k++)
	   if(switchHostA_mod->par(k).isInput())
	      {switchHostA_mod->par(k).read();check_error();}

	switchHostA_mod->setDisplayString(dispSUBMOD, "p=82,300;i=server1" );

	// build function call:
	switchHostA_mod->buildInside();
	machines.clear();

	// switchHostB
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *switchHostB_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	switchHostB_mod = modtype->create( "switchHostB", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	switchHostB_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = switchHostB_mod->params();
	for(k=0;k<n;k++)
	   if(switchHostB_mod->par(k).isInput())
	      {switchHostB_mod->par(k).read();check_error();}

	switchHostB_mod->setDisplayString(dispSUBMOD, "p=162,300;i=pc" );

	// build function call:
	switchHostB_mod->buildInside();
	machines.clear();

	// switchHostC
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *switchHostC_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	switchHostC_mod = modtype->create( "switchHostC", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	switchHostC_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = switchHostC_mod->params();
	for(k=0;k<n;k++)
	   if(switchHostC_mod->par(k).isInput())
	      {switchHostC_mod->par(k).read();check_error();}

	switchHostC_mod->setDisplayString(dispSUBMOD, "p=234,300;i=pc" );

	// build function call:
	switchHostC_mod->buildInside();
	machines.clear();

	// switchHostD
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *switchHostD_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	switchHostD_mod = modtype->create( "switchHostD", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	switchHostD_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = switchHostD_mod->params();
	for(k=0;k<n;k++)
	   if(switchHostD_mod->par(k).isInput())
	      {switchHostD_mod->par(k).read();check_error();}

	switchHostD_mod->setDisplayString(dispSUBMOD, "p=306,300;i=pc" );

	// build function call:
	switchHostD_mod->buildInside();
	machines.clear();

	// switch
	modtype = findModuleType( "EtherSwitch" );
	check_modtype( modtype, "EtherSwitch" );
	cModule *switch_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	switch_mod = modtype->create( "switch", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	switch_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = switch_mod->params();
	for(k=0;k<n;k++)
	   if(switch_mod->par(k).isInput())
	      {switch_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	n = 5;
	check_gate_count( n, "switch","in","MixedLAN");
	switch_mod->setGateSize("in", n );

	n = 5;
	check_gate_count( n, "switch","out","MixedLAN");
	switch_mod->setGateSize("out", n );

	switch_mod->setDisplayString(dispSUBMOD, "p=194,236;i=switch2" );

	// build function call:
	switch_mod->buildInside();
	machines.clear();

	// hubHostA
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hubHostA_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hubHostA_mod = modtype->create( "hubHostA", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hubHostA_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hubHostA_mod->params();
	for(k=0;k<n;k++)
	   if(hubHostA_mod->par(k).isInput())
	      {hubHostA_mod->par(k).read();check_error();}

	hubHostA_mod->setDisplayString(dispSUBMOD, "p=297,55;i=pc" );

	// build function call:
	hubHostA_mod->buildInside();
	machines.clear();

	// hubHostB
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hubHostB_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hubHostB_mod = modtype->create( "hubHostB", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hubHostB_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hubHostB_mod->params();
	for(k=0;k<n;k++)
	   if(hubHostB_mod->par(k).isInput())
	      {hubHostB_mod->par(k).read();check_error();}

	hubHostB_mod->setDisplayString(dispSUBMOD, "p=365,55;i=pc" );

	// build function call:
	hubHostB_mod->buildInside();
	machines.clear();

	// hubHostC
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hubHostC_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hubHostC_mod = modtype->create( "hubHostC", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hubHostC_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hubHostC_mod->params();
	for(k=0;k<n;k++)
	   if(hubHostC_mod->par(k).isInput())
	      {hubHostC_mod->par(k).read();check_error();}

	hubHostC_mod->setDisplayString(dispSUBMOD, "p=430,55;i=pc" );

	// build function call:
	hubHostC_mod->buildInside();
	machines.clear();

	// hub
	modtype = findModuleType( "EtherHub" );
	check_modtype( modtype, "EtherHub" );
	cModule *hub_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hub_mod = modtype->create( "hub", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hub_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hub_mod->params();
	for(k=0;k<n;k++)
	   if(hub_mod->par(k).isInput())
	      {hub_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	n = 4;
	check_gate_count( n, "hub","in","MixedLAN");
	hub_mod->setGateSize("in", n );

	n = 4;
	check_gate_count( n, "hub","out","MixedLAN");
	hub_mod->setGateSize("out", n );

	hub_mod->setDisplayString(dispSUBMOD, "p=362,132;i=switch1" );

	// build function call:
	hub_mod->buildInside();
	machines.clear();

	// Connections:
	cLinkType *link_p;
	cPar *delay_p, *error_p, *datarate_p;
	int gateL, gateR;
	long mod_nr_L, mod_nr_R, gate_nr_L, gate_nr_R;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 0;
	gateL = bus_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"in",gate_nr_L) );

	gateR = busHostA_mod->findGate( "out" );
	check_gate( gateR, "busHostA", "out" );

	connect (busHostA_mod, gateR,
	         NULL,
	         bus_mod, gateL);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 0;
	gateL = bus_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"out",gate_nr_L) );

	gateR = busHostA_mod->findGate( "in" );
	check_gate( gateR, "busHostA", "in" );

	connect (bus_mod, gateL,
	         NULL,
	         busHostA_mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 1;
	gateL = bus_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"in",gate_nr_L) );

	gateR = busHostB_mod->findGate( "out" );
	check_gate( gateR, "busHostB", "out" );

	connect (busHostB_mod, gateR,
	         NULL,
	         bus_mod, gateL);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 1;
	gateL = bus_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"out",gate_nr_L) );

	gateR = busHostB_mod->findGate( "in" );
	check_gate( gateR, "busHostB", "in" );

	connect (bus_mod, gateL,
	         NULL,
	         busHostB_mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 2;
	gateL = bus_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"in",gate_nr_L) );

	gate_nr_R = 4;
	gateR = switch_mod->findGate( "out", gate_nr_R );
	check_gate( gateR, "switch", indexedname(b1,"out",gate_nr_R) );

	connect (switch_mod, gateR,
	         NULL,
	         bus_mod, gateL);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 2;
	gateL = bus_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"out",gate_nr_L) );

	gate_nr_R = 4;
	gateR = switch_mod->findGate( "in", gate_nr_R );
	check_gate( gateR, "switch", indexedname(b1,"in",gate_nr_R) );

	connect (bus_mod, gateL,
	         NULL,
	         switch_mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 3;
	gateL = bus_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"in",gate_nr_L) );

	gateR = busHostC_mod->findGate( "out" );
	check_gate( gateR, "busHostC", "out" );

	connect (busHostC_mod, gateR,
	         NULL,
	         bus_mod, gateL);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 3;
	gateL = bus_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"out",gate_nr_L) );

	gateR = busHostC_mod->findGate( "in" );
	check_gate( gateR, "busHostC", "in" );

	connect (bus_mod, gateL,
	         NULL,
	         busHostC_mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 4;
	gateL = bus_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"in",gate_nr_L) );

	gate_nr_R = 3;
	gateR = hub_mod->findGate( "out", gate_nr_R );
	check_gate( gateR, "hub", indexedname(b1,"out",gate_nr_R) );

	connect (hub_mod, gateR,
	         NULL,
	         bus_mod, gateL);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 4;
	gateL = bus_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"out",gate_nr_L) );

	gate_nr_R = 3;
	gateR = hub_mod->findGate( "in", gate_nr_R );
	check_gate( gateR, "hub", indexedname(b1,"in",gate_nr_R) );

	connect (bus_mod, gateL,
	         NULL,
	         hub_mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 5;
	gateL = bus_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"in",gate_nr_L) );

	gateR = busHostD_mod->findGate( "out" );
	check_gate( gateR, "busHostD", "out" );

	connect (busHostD_mod, gateR,
	         NULL,
	         bus_mod, gateL);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 5;
	gateL = bus_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"out",gate_nr_L) );

	gateR = busHostD_mod->findGate( "in" );
	check_gate( gateR, "busHostD", "in" );

	connect (bus_mod, gateL,
	         NULL,
	         busHostD_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 0;
	gateL = switch_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

	gateR = switchHostA_mod->findGate( "in" );
	check_gate( gateR, "switchHostA", "in" );

	connect (switch_mod, gateL,
	         delay_p, NULL, NULL,
	         switchHostA_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 0;
	gateL = switch_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

	gateR = switchHostA_mod->findGate( "out" );
	check_gate( gateR, "switchHostA", "out" );

	connect (switchHostA_mod, gateR,
	         delay_p, NULL, NULL,
	         switch_mod, gateL);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 1;
	gateL = switch_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

	gateR = switchHostB_mod->findGate( "in" );
	check_gate( gateR, "switchHostB", "in" );

	connect (switch_mod, gateL,
	         delay_p, NULL, NULL,
	         switchHostB_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 1;
	gateL = switch_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

	gateR = switchHostB_mod->findGate( "out" );
	check_gate( gateR, "switchHostB", "out" );

	connect (switchHostB_mod, gateR,
	         delay_p, NULL, NULL,
	         switch_mod, gateL);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 2;
	gateL = switch_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

	gateR = switchHostC_mod->findGate( "in" );
	check_gate( gateR, "switchHostC", "in" );

	connect (switch_mod, gateL,
	         delay_p, NULL, NULL,
	         switchHostC_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 2;
	gateL = switch_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

	gateR = switchHostC_mod->findGate( "out" );
	check_gate( gateR, "switchHostC", "out" );

	connect (switchHostC_mod, gateR,
	         delay_p, NULL, NULL,
	         switch_mod, gateL);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 3;
	gateL = switch_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

	gateR = switchHostD_mod->findGate( "in" );
	check_gate( gateR, "switchHostD", "in" );

	connect (switch_mod, gateL,
	         delay_p, NULL, NULL,
	         switchHostD_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 3;
	gateL = switch_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

	gateR = switchHostD_mod->findGate( "out" );
	check_gate( gateR, "switchHostD", "out" );

	connect (switchHostD_mod, gateR,
	         delay_p, NULL, NULL,
	         switch_mod, gateL);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 0;
	gateL = hub_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"out",gate_nr_L) );

	gateR = hubHostA_mod->findGate( "in" );
	check_gate( gateR, "hubHostA", "in" );

	connect (hub_mod, gateL,
	         delay_p, NULL, NULL,
	         hubHostA_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 0;
	gateL = hub_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"in",gate_nr_L) );

	gateR = hubHostA_mod->findGate( "out" );
	check_gate( gateR, "hubHostA", "out" );

	connect (hubHostA_mod, gateR,
	         delay_p, NULL, NULL,
	         hub_mod, gateL);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 3e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 1;
	gateL = hub_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"out",gate_nr_L) );

	gateR = hubHostB_mod->findGate( "in" );
	check_gate( gateR, "hubHostB", "in" );

	connect (hub_mod, gateL,
	         delay_p, NULL, NULL,
	         hubHostB_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 3e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 1;
	gateL = hub_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"in",gate_nr_L) );

	gateR = hubHostB_mod->findGate( "out" );
	check_gate( gateR, "hubHostB", "out" );

	connect (hubHostB_mod, gateR,
	         delay_p, NULL, NULL,
	         hub_mod, gateL);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 2e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 2;
	gateL = hub_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"out",gate_nr_L) );

	gateR = hubHostC_mod->findGate( "in" );
	check_gate( gateR, "hubHostC", "in" );

	connect (hub_mod, gateL,
	         delay_p, NULL, NULL,
	         hubHostC_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 2e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 2;
	gateL = hub_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"in",gate_nr_L) );

	gateR = hubHostC_mod->findGate( "out" );
	check_gate( gateR, "hubHostC", "out" );

	connect (hubHostC_mod, gateR,
	         delay_p, NULL, NULL,
	         hub_mod, gateL);

	check_error(); check_memory();
	} // end-if

	mod->checkInternalConnections();
	check_error(); check_memory();
}

ModuleInterface( TwoHosts )
	Machine( default )
EndInterface

Register_ModuleInterface( TwoHosts )

class TwoHosts : public cCompoundModule
{
  public:
    TwoHosts(const char *name, cModule *parentmod) :
      cCompoundModule(name, parentmod) {}
  protected:
    virtual void doBuildInside();
};

Define_Module( TwoHosts );

void TwoHosts::doBuildInside()
{
	cModule *mod = this;
	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// Submodules:
	cModuleType *modtype = NULL;
	long sub_nr = 0;
	long sub_i = 0;

	// hostA
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostA_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostA_mod = modtype->create( "hostA", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostA_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostA_mod->params();
	for(k=0;k<n;k++)
	   if(hostA_mod->par(k).isInput())
	      {hostA_mod->par(k).read();check_error();}

	hostA_mod->setDisplayString(dispSUBMOD, "p=60,160;i=pc" );

	// build function call:
	hostA_mod->buildInside();
	machines.clear();

	// hostB
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostB_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostB_mod = modtype->create( "hostB", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostB_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostB_mod->params();
	for(k=0;k<n;k++)
	   if(hostB_mod->par(k).isInput())
	      {hostB_mod->par(k).read();check_error();}

	hostB_mod->setDisplayString(dispSUBMOD, "p=200,140;i=pc" );

	// build function call:
	hostB_mod->buildInside();
	machines.clear();

	// Connections:
	cLinkType *link_p;
	cPar *delay_p, *error_p, *datarate_p;
	int gateL, gateR;
	long mod_nr_L, mod_nr_R, gate_nr_L, gate_nr_R;
	delay_p = new cPar(); *delay_p = 5e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gateL = hostA_mod->findGate( "out" );
	check_gate( gateL, "hostA", "out" );

	gateR = hostB_mod->findGate( "in" );
	check_gate( gateR, "hostB", "in" );

	connect (hostA_mod, gateL,
	         delay_p, NULL, NULL,
	         hostB_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 5e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gateL = hostB_mod->findGate( "out" );
	check_gate( gateL, "hostB", "out" );

	gateR = hostA_mod->findGate( "in" );
	check_gate( gateR, "hostA", "in" );

	connect (hostB_mod, gateL,
	         delay_p, NULL, NULL,
	         hostA_mod, gateR);

	check_error(); check_memory();
	} // end-if

	mod->checkInternalConnections();
	check_error(); check_memory();
}

ModuleInterface( SwitchedLAN )
	Machine( default )
EndInterface

Register_ModuleInterface( SwitchedLAN )

class SwitchedLAN : public cCompoundModule
{
  public:
    SwitchedLAN(const char *name, cModule *parentmod) :
      cCompoundModule(name, parentmod) {}
  protected:
    virtual void doBuildInside();
};

Define_Module( SwitchedLAN );

void SwitchedLAN::doBuildInside()
{
	cModule *mod = this;
	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// Submodules:
	cModuleType *modtype = NULL;
	long sub_nr = 0;
	long sub_i = 0;

	// hostA
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostA_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostA_mod = modtype->create( "hostA", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostA_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostA_mod->params();
	for(k=0;k<n;k++)
	   if(hostA_mod->par(k).isInput())
	      {hostA_mod->par(k).read();check_error();}

	hostA_mod->setDisplayString(dispSUBMOD, "p=161,55;i=server1" );

	// build function call:
	hostA_mod->buildInside();
	machines.clear();

	// hostB
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostB_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostB_mod = modtype->create( "hostB", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostB_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostB_mod->params();
	for(k=0;k<n;k++)
	   if(hostB_mod->par(k).isInput())
	      {hostB_mod->par(k).read();check_error();}

	hostB_mod->setDisplayString(dispSUBMOD, "p=253,125;i=pc" );

	// build function call:
	hostB_mod->buildInside();
	machines.clear();

	// hostC
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostC_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostC_mod = modtype->create( "hostC", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostC_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostC_mod->params();
	for(k=0;k<n;k++)
	   if(hostC_mod->par(k).isInput())
	      {hostC_mod->par(k).read();check_error();}

	hostC_mod->setDisplayString(dispSUBMOD, "p=158,199;i=pc" );

	// build function call:
	hostC_mod->buildInside();
	machines.clear();

	// hostD
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostD_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostD_mod = modtype->create( "hostD", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostD_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostD_mod->params();
	for(k=0;k<n;k++)
	   if(hostD_mod->par(k).isInput())
	      {hostD_mod->par(k).read();check_error();}

	hostD_mod->setDisplayString(dispSUBMOD, "p=59,127;i=pc" );

	// build function call:
	hostD_mod->buildInside();
	machines.clear();

	// switch
	modtype = findModuleType( "EtherSwitch" );
	check_modtype( modtype, "EtherSwitch" );
	cModule *switch_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	switch_mod = modtype->create( "switch", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	switch_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = switch_mod->params();
	for(k=0;k<n;k++)
	   if(switch_mod->par(k).isInput())
	      {switch_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	n = 4;
	check_gate_count( n, "switch","in","SwitchedLAN");
	switch_mod->setGateSize("in", n );

	n = 4;
	check_gate_count( n, "switch","out","SwitchedLAN");
	switch_mod->setGateSize("out", n );

	switch_mod->setDisplayString(dispSUBMOD, "p=162,124;i=switch2" );

	// build function call:
	switch_mod->buildInside();
	machines.clear();

	// Connections:
	cLinkType *link_p;
	cPar *delay_p, *error_p, *datarate_p;
	int gateL, gateR;
	long mod_nr_L, mod_nr_R, gate_nr_L, gate_nr_R;
	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 0;
	gateL = switch_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

	gateR = hostA_mod->findGate( "in" );
	check_gate( gateR, "hostA", "in" );

	connect (switch_mod, gateL,
	         delay_p, NULL, NULL,
	         hostA_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 0;
	gateL = switch_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

	gateR = hostA_mod->findGate( "out" );
	check_gate( gateR, "hostA", "out" );

	connect (hostA_mod, gateR,
	         delay_p, NULL, NULL,
	         switch_mod, gateL);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 1;
	gateL = switch_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

	gateR = hostB_mod->findGate( "in" );
	check_gate( gateR, "hostB", "in" );

	connect (switch_mod, gateL,
	         delay_p, NULL, NULL,
	         hostB_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 1;
	gateL = switch_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

	gateR = hostB_mod->findGate( "out" );
	check_gate( gateR, "hostB", "out" );

	connect (hostB_mod, gateR,
	         delay_p, NULL, NULL,
	         switch_mod, gateL);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 2;
	gateL = switch_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

	gateR = hostC_mod->findGate( "in" );
	check_gate( gateR, "hostC", "in" );

	connect (switch_mod, gateL,
	         delay_p, NULL, NULL,
	         hostC_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 2;
	gateL = switch_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

	gateR = hostC_mod->findGate( "out" );
	check_gate( gateR, "hostC", "out" );

	connect (hostC_mod, gateR,
	         delay_p, NULL, NULL,
	         switch_mod, gateL);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 3;
	gateL = switch_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

	gateR = hostD_mod->findGate( "in" );
	check_gate( gateR, "hostD", "in" );

	connect (switch_mod, gateL,
	         delay_p, NULL, NULL,
	         hostD_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 3;
	gateL = switch_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

	gateR = hostD_mod->findGate( "out" );
	check_gate( gateR, "hostD", "out" );

	connect (hostD_mod, gateR,
	         delay_p, NULL, NULL,
	         switch_mod, gateL);

	check_error(); check_memory();
	} // end-if

	mod->checkInternalConnections();
	check_error(); check_memory();
}

ModuleInterface( HubLAN )
	Machine( default )
EndInterface

Register_ModuleInterface( HubLAN )

class HubLAN : public cCompoundModule
{
  public:
    HubLAN(const char *name, cModule *parentmod) :
      cCompoundModule(name, parentmod) {}
  protected:
    virtual void doBuildInside();
};

Define_Module( HubLAN );

void HubLAN::doBuildInside()
{
	cModule *mod = this;
	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// Submodules:
	cModuleType *modtype = NULL;
	long sub_nr = 0;
	long sub_i = 0;

	// hostA
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostA_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostA_mod = modtype->create( "hostA", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostA_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostA_mod->params();
	for(k=0;k<n;k++)
	   if(hostA_mod->par(k).isInput())
	      {hostA_mod->par(k).read();check_error();}

	hostA_mod->setDisplayString(dispSUBMOD, "p=161,55;i=server1" );

	// build function call:
	hostA_mod->buildInside();
	machines.clear();

	// hostB
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostB_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostB_mod = modtype->create( "hostB", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostB_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostB_mod->params();
	for(k=0;k<n;k++)
	   if(hostB_mod->par(k).isInput())
	      {hostB_mod->par(k).read();check_error();}

	hostB_mod->setDisplayString(dispSUBMOD, "p=253,125;i=pc" );

	// build function call:
	hostB_mod->buildInside();
	machines.clear();

	// hostC
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostC_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostC_mod = modtype->create( "hostC", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostC_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostC_mod->params();
	for(k=0;k<n;k++)
	   if(hostC_mod->par(k).isInput())
	      {hostC_mod->par(k).read();check_error();}

	hostC_mod->setDisplayString(dispSUBMOD, "p=158,199;i=pc" );

	// build function call:
	hostC_mod->buildInside();
	machines.clear();

	// hostD
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostD_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostD_mod = modtype->create( "hostD", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostD_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostD_mod->params();
	for(k=0;k<n;k++)
	   if(hostD_mod->par(k).isInput())
	      {hostD_mod->par(k).read();check_error();}

	hostD_mod->setDisplayString(dispSUBMOD, "p=59,127;i=pc" );

	// build function call:
	hostD_mod->buildInside();
	machines.clear();

	// hub
	modtype = findModuleType( "EtherHub" );
	check_modtype( modtype, "EtherHub" );
	cModule *hub_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hub_mod = modtype->create( "hub", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hub_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hub_mod->params();
	for(k=0;k<n;k++)
	   if(hub_mod->par(k).isInput())
	      {hub_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	n = 4;
	check_gate_count( n, "hub","in","HubLAN");
	hub_mod->setGateSize("in", n );

	n = 4;
	check_gate_count( n, "hub","out","HubLAN");
	hub_mod->setGateSize("out", n );

	hub_mod->setDisplayString(dispSUBMOD, "p=162,124;i=switch1" );

	// build function call:
	hub_mod->buildInside();
	machines.clear();

	// Connections:
	cLinkType *link_p;
	cPar *delay_p, *error_p, *datarate_p;
	int gateL, gateR;
	long mod_nr_L, mod_nr_R, gate_nr_L, gate_nr_R;
	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 0;
	gateL = hub_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"out",gate_nr_L) );

	gateR = hostA_mod->findGate( "in" );
	check_gate( gateR, "hostA", "in" );

	connect (hub_mod, gateL,
	         delay_p, NULL, NULL,
	         hostA_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 1e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 0;
	gateL = hub_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"in",gate_nr_L) );

	gateR = hostA_mod->findGate( "out" );
	check_gate( gateR, "hostA", "out" );

	connect (hostA_mod, gateR,
	         delay_p, NULL, NULL,
	         hub_mod, gateL);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 3e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 1;
	gateL = hub_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"out",gate_nr_L) );

	gateR = hostB_mod->findGate( "in" );
	check_gate( gateR, "hostB", "in" );

	connect (hub_mod, gateL,
	         delay_p, NULL, NULL,
	         hostB_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 3e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 1;
	gateL = hub_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"in",gate_nr_L) );

	gateR = hostB_mod->findGate( "out" );
	check_gate( gateR, "hostB", "out" );

	connect (hostB_mod, gateR,
	         delay_p, NULL, NULL,
	         hub_mod, gateL);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 4e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 2;
	gateL = hub_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"out",gate_nr_L) );

	gateR = hostC_mod->findGate( "in" );
	check_gate( gateR, "hostC", "in" );

	connect (hub_mod, gateL,
	         delay_p, NULL, NULL,
	         hostC_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 4e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 2;
	gateL = hub_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"in",gate_nr_L) );

	gateR = hostC_mod->findGate( "out" );
	check_gate( gateR, "hostC", "out" );

	connect (hostC_mod, gateR,
	         delay_p, NULL, NULL,
	         hub_mod, gateL);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 2e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 3;
	gateL = hub_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"out",gate_nr_L) );

	gateR = hostD_mod->findGate( "in" );
	check_gate( gateR, "hostD", "in" );

	connect (hub_mod, gateL,
	         delay_p, NULL, NULL,
	         hostD_mod, gateR);

	check_error(); check_memory();
	} // end-if

	delay_p = new cPar(); *delay_p = 2e-07;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 3;
	gateL = hub_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"in",gate_nr_L) );

	gateR = hostD_mod->findGate( "out" );
	check_gate( gateR, "hostD", "out" );

	connect (hostD_mod, gateR,
	         delay_p, NULL, NULL,
	         hub_mod, gateL);

	check_error(); check_memory();
	} // end-if

	mod->checkInternalConnections();
	check_error(); check_memory();
}

ModuleInterface( BusLAN )
	Machine( default )
EndInterface

Register_ModuleInterface( BusLAN )

class BusLAN : public cCompoundModule
{
  public:
    BusLAN(const char *name, cModule *parentmod) :
      cCompoundModule(name, parentmod) {}
  protected:
    virtual void doBuildInside();
};

Define_Module( BusLAN );

void BusLAN::doBuildInside()
{
	cModule *mod = this;
	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// Submodules:
	cModuleType *modtype = NULL;
	long sub_nr = 0;
	long sub_i = 0;

	// hostA
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostA_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostA_mod = modtype->create( "hostA", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostA_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostA_mod->params();
	for(k=0;k<n;k++)
	   if(hostA_mod->par(k).isInput())
	      {hostA_mod->par(k).read();check_error();}

	hostA_mod->setDisplayString(dispSUBMOD, "p=100,150;i=server1" );

	// build function call:
	hostA_mod->buildInside();
	machines.clear();

	// hostB
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostB_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostB_mod = modtype->create( "hostB", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostB_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostB_mod->params();
	for(k=0;k<n;k++)
	   if(hostB_mod->par(k).isInput())
	      {hostB_mod->par(k).read();check_error();}

	hostB_mod->setDisplayString(dispSUBMOD, "p=200,150;i=pc" );

	// build function call:
	hostB_mod->buildInside();
	machines.clear();

	// hostC
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostC_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostC_mod = modtype->create( "hostC", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostC_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostC_mod->params();
	for(k=0;k<n;k++)
	   if(hostC_mod->par(k).isInput())
	      {hostC_mod->par(k).read();check_error();}

	hostC_mod->setDisplayString(dispSUBMOD, "p=300,150;i=pc" );

	// build function call:
	hostC_mod->buildInside();
	machines.clear();

	// hostD
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *hostD_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hostD_mod = modtype->create( "hostD", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hostD_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hostD_mod->params();
	for(k=0;k<n;k++)
	   if(hostD_mod->par(k).isInput())
	      {hostD_mod->par(k).read();check_error();}

	hostD_mod->setDisplayString(dispSUBMOD, "p=400,150;i=pc" );

	// build function call:
	hostD_mod->buildInside();
	machines.clear();

	// bus
	modtype = findModuleType( "EtherBus" );
	check_modtype( modtype, "EtherBus" );
	cModule *bus_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	bus_mod = modtype->create( "bus", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	bus_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	// 'parameters:' section
	par = &(bus_mod->par("positions"));
	check_param(par, "positions");
	*par = "0 10 20 30";

	par = &(bus_mod->par("propagationSpeed"));
	check_param(par, "propagationSpeed");
	*par = 200000000;

	n = bus_mod->params();
	for(k=0;k<n;k++)
	   if(bus_mod->par(k).isInput())
	      {bus_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	n = 4;
	check_gate_count( n, "bus","in","BusLAN");
	bus_mod->setGateSize("in", n );

	n = 4;
	check_gate_count( n, "bus","out","BusLAN");
	bus_mod->setGateSize("out", n );

	bus_mod->setDisplayString(dispSUBMOD, "p=250,100;b=400,6;o=#408060" );

	// build function call:
	bus_mod->buildInside();
	machines.clear();

	// Connections:
	cLinkType *link_p;
	cPar *delay_p, *error_p, *datarate_p;
	int gateL, gateR;
	long mod_nr_L, mod_nr_R, gate_nr_L, gate_nr_R;

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 0;
	gateL = bus_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"in",gate_nr_L) );

	gateR = hostA_mod->findGate( "out" );
	check_gate( gateR, "hostA", "out" );

	connect (hostA_mod, gateR,
	         NULL,
	         bus_mod, gateL);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 0;
	gateL = bus_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"out",gate_nr_L) );

	gateR = hostA_mod->findGate( "in" );
	check_gate( gateR, "hostA", "in" );

	connect (bus_mod, gateL,
	         NULL,
	         hostA_mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 1;
	gateL = bus_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"in",gate_nr_L) );

	gateR = hostB_mod->findGate( "out" );
	check_gate( gateR, "hostB", "out" );

	connect (hostB_mod, gateR,
	         NULL,
	         bus_mod, gateL);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 1;
	gateL = bus_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"out",gate_nr_L) );

	gateR = hostB_mod->findGate( "in" );
	check_gate( gateR, "hostB", "in" );

	connect (bus_mod, gateL,
	         NULL,
	         hostB_mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 2;
	gateL = bus_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"in",gate_nr_L) );

	gateR = hostC_mod->findGate( "out" );
	check_gate( gateR, "hostC", "out" );

	connect (hostC_mod, gateR,
	         NULL,
	         bus_mod, gateL);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 2;
	gateL = bus_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"out",gate_nr_L) );

	gateR = hostC_mod->findGate( "in" );
	check_gate( gateR, "hostC", "in" );

	connect (bus_mod, gateL,
	         NULL,
	         hostC_mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 3;
	gateL = bus_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"in",gate_nr_L) );

	gateR = hostD_mod->findGate( "out" );
	check_gate( gateR, "hostD", "out" );

	connect (hostD_mod, gateR,
	         NULL,
	         bus_mod, gateL);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = 3;
	gateL = bus_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"out",gate_nr_L) );

	gateR = hostD_mod->findGate( "in" );
	check_gate( gateR, "hostD", "in" );

	connect (bus_mod, gateL,
	         NULL,
	         hostD_mod, gateR);

	check_error(); check_memory();
	} // end-if

	mod->checkInternalConnections();
	check_error(); check_memory();
}

class mixedLAN : public cNetworkType
{
  public:
    mixedLAN(const char *name) : cNetworkType(name) {}
    mixedLAN(const mixedLAN& n)  {setName(n.name());operator=(n);}
    virtual void setupNetwork();
};

Define_Network( mixedLAN );

void mixedLAN::setupNetwork()
{

	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = ev.getPhysicalMachineFor("default");
	machines.add( par );
	check_error(); check_memory();

	// system module creation
	cModuleType *modtype;
	modtype = findModuleType( "MixedLAN" );
	check_modtype( modtype, "MixedLAN" );
	cModule *mixedLAN_mod;

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	if (!islocal)
	    throw new cException("Local machine `%s' is not among machines specified for this network",
	              simulation.netInterface()->localhost());
	mixedLAN_mod = modtype->create( "mixedLAN", NULL, islocal);
	check_error(); check_memory();

	// set machine list:
	mixedLAN_mod->setMachinePar( "default", ev.getPhysicalMachineFor("default") );
	check_error(); check_memory();

	n = mixedLAN_mod->params();
	for(k=0;k<n;k++)
	   if(mixedLAN_mod->par(k).isInput())
	      {mixedLAN_mod->par(k).read();check_error();}

	// build function call:
	mixedLAN_mod->buildInside();
	machines.clear();

	check_error(); check_memory();
}

class twoHosts : public cNetworkType
{
  public:
    twoHosts(const char *name) : cNetworkType(name) {}
    twoHosts(const twoHosts& n)  {setName(n.name());operator=(n);}
    virtual void setupNetwork();
};

Define_Network( twoHosts );

void twoHosts::setupNetwork()
{

	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = ev.getPhysicalMachineFor("default");
	machines.add( par );
	check_error(); check_memory();

	// system module creation
	cModuleType *modtype;
	modtype = findModuleType( "TwoHosts" );
	check_modtype( modtype, "TwoHosts" );
	cModule *twoHosts_mod;

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	if (!islocal)
	    throw new cException("Local machine `%s' is not among machines specified for this network",
	              simulation.netInterface()->localhost());
	twoHosts_mod = modtype->create( "twoHosts", NULL, islocal);
	check_error(); check_memory();

	// set machine list:
	twoHosts_mod->setMachinePar( "default", ev.getPhysicalMachineFor("default") );
	check_error(); check_memory();

	n = twoHosts_mod->params();
	for(k=0;k<n;k++)
	   if(twoHosts_mod->par(k).isInput())
	      {twoHosts_mod->par(k).read();check_error();}

	// build function call:
	twoHosts_mod->buildInside();
	machines.clear();

	check_error(); check_memory();
}

class switchedLAN : public cNetworkType
{
  public:
    switchedLAN(const char *name) : cNetworkType(name) {}
    switchedLAN(const switchedLAN& n)  {setName(n.name());operator=(n);}
    virtual void setupNetwork();
};

Define_Network( switchedLAN );

void switchedLAN::setupNetwork()
{

	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = ev.getPhysicalMachineFor("default");
	machines.add( par );
	check_error(); check_memory();

	// system module creation
	cModuleType *modtype;
	modtype = findModuleType( "SwitchedLAN" );
	check_modtype( modtype, "SwitchedLAN" );
	cModule *switchedLAN_mod;

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	if (!islocal)
	    throw new cException("Local machine `%s' is not among machines specified for this network",
	              simulation.netInterface()->localhost());
	switchedLAN_mod = modtype->create( "switchedLAN", NULL, islocal);
	check_error(); check_memory();

	// set machine list:
	switchedLAN_mod->setMachinePar( "default", ev.getPhysicalMachineFor("default") );
	check_error(); check_memory();

	n = switchedLAN_mod->params();
	for(k=0;k<n;k++)
	   if(switchedLAN_mod->par(k).isInput())
	      {switchedLAN_mod->par(k).read();check_error();}

	// build function call:
	switchedLAN_mod->buildInside();
	machines.clear();

	check_error(); check_memory();
}

class hubLAN : public cNetworkType
{
  public:
    hubLAN(const char *name) : cNetworkType(name) {}
    hubLAN(const hubLAN& n)  {setName(n.name());operator=(n);}
    virtual void setupNetwork();
};

Define_Network( hubLAN );

void hubLAN::setupNetwork()
{

	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = ev.getPhysicalMachineFor("default");
	machines.add( par );
	check_error(); check_memory();

	// system module creation
	cModuleType *modtype;
	modtype = findModuleType( "HubLAN" );
	check_modtype( modtype, "HubLAN" );
	cModule *hubLAN_mod;

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	if (!islocal)
	    throw new cException("Local machine `%s' is not among machines specified for this network",
	              simulation.netInterface()->localhost());
	hubLAN_mod = modtype->create( "hubLAN", NULL, islocal);
	check_error(); check_memory();

	// set machine list:
	hubLAN_mod->setMachinePar( "default", ev.getPhysicalMachineFor("default") );
	check_error(); check_memory();

	n = hubLAN_mod->params();
	for(k=0;k<n;k++)
	   if(hubLAN_mod->par(k).isInput())
	      {hubLAN_mod->par(k).read();check_error();}

	// build function call:
	hubLAN_mod->buildInside();
	machines.clear();

	check_error(); check_memory();
}

class busLAN : public cNetworkType
{
  public:
    busLAN(const char *name) : cNetworkType(name) {}
    busLAN(const busLAN& n)  {setName(n.name());operator=(n);}
    virtual void setupNetwork();
};

Define_Network( busLAN );

void busLAN::setupNetwork()
{

	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = ev.getPhysicalMachineFor("default");
	machines.add( par );
	check_error(); check_memory();

	// system module creation
	cModuleType *modtype;
	modtype = findModuleType( "BusLAN" );
	check_modtype( modtype, "BusLAN" );
	cModule *busLAN_mod;

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	if (!islocal)
	    throw new cException("Local machine `%s' is not among machines specified for this network",
	              simulation.netInterface()->localhost());
	busLAN_mod = modtype->create( "busLAN", NULL, islocal);
	check_error(); check_memory();

	// set machine list:
	busLAN_mod->setMachinePar( "default", ev.getPhysicalMachineFor("default") );
	check_error(); check_memory();

	n = busLAN_mod->params();
	for(k=0;k<n;k++)
	   if(busLAN_mod->par(k).isInput())
	      {busLAN_mod->par(k).read();check_error();}

	// build function call:
	busLAN_mod->buildInside();
	machines.clear();

	check_error(); check_memory();
}


//-----------------------------------------
//
// Generated by NEDC version 2.3
// date:	Mon Jun 28 11:58:57 2004
//
// Input file:	MACRelayUnit.ned
// Output file:	MACRelayUnit_n.cc
//-----------------------------------------


#if defined(SPEC_CPU)
#include <cmath>
#else
#include <math.h>
#endif
#include "omnetpp.h"

#define check_error() \
    {(void)0;}
#define check_memory() \
    {if (memoryIsLow()) {throw new cException(eNOMEM); }}
#define check_module_count(num, mod, parentmod) \
    {if ((int)num<=0) {throw new cException("Negative or zero module vector size %s[%d] in compound module %s", \
                          mod,(int)num,parentmod);}}
#define check_gate_count(num, mod, gate, parentmod) \
    {if ((int)num<0) {throw new cException("Negative gate vector size %s.%s[%d] in compound module %s", \
                          mod,gate,(int)num,parentmod);}}
#define check_loop_bounds(lower, upper, parentmod) \
    {if ((int)lower<0) \
        {throw new cException("Bad loop bounds (%d..%d) in compound module %s", \
                 (int)lower,(int)upper,parentmod);}}
#define check_module_index(index,modvar,modname,parentmod) \
    {if (index<0 || index>=modvar[0]->size()) {throw new cException("Bad submodule index %s[%d] in compound module %s", \
          modname,(int)index,parentmod);}}
#define check_channel_params(delay, err, channel) \
    {if ((double)delay<0.0) \
        {throw new cException("Negative delay value %lf in channel %s",(double)delay,channel);} \
     if ((double)err<0.0 || (double)err>1.0) \
        {throw new cException("Incorrect error value %lf in channel %s",(double)err,channel);}}
#define check_modtype(modtype, modname) \
    {if ((modtype)==NULL) {throw new cException("Simple module type definition %s not found", \
                                     modname);}}
#define check_function(funcptr, funcname) \
    {if ((funcptr)==NULL) {throw new cException("Function %s not found", \
                                     funcname);}}
#define check_function_retnull(funcptr, funcname) \
    {if ((funcptr)==NULL) {throw new cException("Function %s not found", \
                                     funcname);return NULL;}}
#define check_gate(gateindex, modname, gatename) \
    {if ((int)gateindex==-1) {throw new cException("Gate %s.%s not found",modname,gatename);}}
#define check_anc_param(ptr,parname,compoundmod) \
    {if ((ptr)==NULL) {throw new cException("Unknown ancestor parameter named %s in compound module %s", \
                                parname,compoundmod);}}
#define check_param(ptr,parname) \
    {if ((ptr)==NULL) {throw new cException("Unknown parameter named %s", \
                                parname);}}
#ifndef __cplusplus
#  error Compile as C++!
#endif
#ifdef __BORLANDC__
#  if !defined(__FLAT__) && !defined(__LARGE__)
#    error Compile as 16-bit LARGE model or 32-bit DPMI!
#  endif
#endif

// Disable warnings about unused variables:
#ifdef _MSC_VER
#  pragma warning(disable:4101)
#endif
#ifdef __BORLANDC__
#  pragma warn -waus
#  pragma warn -wuse
#endif
// for GCC, seemingly there's no way to emulate the -Wunused command-line
// flag from a source file...

// Version check
#define NEDC_VERSION 0x0203
#if (NEDC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedc: 'make clean' should help.
#endif

//--------------------------------------------
// Following code generated from: LargeNet.ned
//--------------------------------------------

//-------------------------------------
// channel definition: cable
//-------------------------------------

static cPar *cable__delay()
{
	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	cPar *p = new cPar("cable delay");
	*p = 1e-07;
	return p;
}

Define_Link( cable, cable__delay, NULL, NULL);

ModuleInterface( SmallLAN )
	Machine( default )
	Parameter( h, ParType_Numeric ParType_Const )
	Gate( in, GateDir_Input )
	Gate( out, GateDir_Output )
EndInterface

Register_ModuleInterface( SmallLAN )

class SmallLAN : public cCompoundModule
{
  public:
    SmallLAN(const char *name, cModule *parentmod) :
      cCompoundModule(name, parentmod) {}
  protected:
    virtual void doBuildInside();
};

Define_Module( SmallLAN );

void SmallLAN::doBuildInside()
{
	cModule *mod = this;
	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// const parameters:
	// Submodules:
	cModuleType *modtype = NULL;
	long sub_nr = 0;
	long sub_i = 0;

	// hub
	modtype = findModuleType( "EtherHub" );
	check_modtype( modtype, "EtherHub" );
	cModule *hub_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hub_mod = modtype->create( "hub", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hub_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hub_mod->params();
	for(k=0;k<n;k++)
	   if(hub_mod->par(k).isInput())
	      {hub_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "h" );
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "hub","in","SmallLAN");
	hub_mod->setGateSize("in", n );

	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "h" );
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "hub","out","SmallLAN");
	hub_mod->setGateSize("out", n );

	hub_mod->setDisplayString(dispSUBMOD, "i=switch1" );

	// build function call:
	hub_mod->buildInside();
	machines.clear();

	// host
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	sub_nr = mod->par( "h" );
	check_module_count(sub_nr,"host","SmallLAN");
	cModule **host_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		host_mod[sub_i] = modtype->create( "host", mod, islocal);
		check_error(); check_memory();

		host_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		host_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = host_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(host_mod[sub_i]->par(k).isInput())
		      {host_mod[sub_i]->par(k).read();check_error();}

		host_mod[sub_i]->setDisplayString(dispSUBMOD, "i=pc_s" );

		// build function call:
		host_mod[sub_i]->buildInside();
	}
	machines.clear();

	// Connections:
	cLinkType *link_p;
	cPar *delay_p, *error_p, *datarate_p;
	int gateL, gateR;
	long mod_nr_L, mod_nr_R, gate_nr_L, gate_nr_R;
	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "h" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "SmallLAN");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = hub_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "hub", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,host_mod,"host", "SmallLAN");
			gateR = host_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "host", "in" );

			connect (hub_mod, gateL,
			         link_p,
			         host_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = hub_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "hub", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,host_mod,"host", "SmallLAN");
			gateR = host_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "host", "out" );

			connect (host_mod[mod_nr_R], gateR,
			         link_p,
			         hub_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = mod->par( "h" );
	gateL = hub_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"out",gate_nr_L) );

	gateR = mod->findGate( "out" );
	check_gate( gateR, "", "out" );

	connect (hub_mod, gateL,
	         NULL,
	         mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = mod->par( "h" );
	gateL = hub_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "hub", indexedname(b1,"in",gate_nr_L) );

	gateR = mod->findGate( "in" );
	check_gate( gateR, "", "in" );

	connect (mod, gateR,
	         NULL,
	         hub_mod, gateL);

	check_error(); check_memory();
	} // end-if

	mod->checkInternalConnections();
	delete[] host_mod;
	check_error(); check_memory();
}

ModuleInterface( MediumLAN )
	Machine( default )
	Parameter( n, ParType_Numeric ParType_Const )
	Parameter( h, ParType_Numeric ParType_Const )
	Gate( in, GateDir_Input )
	Gate( out, GateDir_Output )
EndInterface

Register_ModuleInterface( MediumLAN )

class MediumLAN : public cCompoundModule
{
  public:
    MediumLAN(const char *name, cModule *parentmod) :
      cCompoundModule(name, parentmod) {}
  protected:
    virtual void doBuildInside();
};

Define_Module( MediumLAN );

void MediumLAN::doBuildInside()
{
	cModule *mod = this;
	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// const parameters:
	// Submodules:
	cModuleType *modtype = NULL;
	long sub_nr = 0;
	long sub_i = 0;

	// switch
	modtype = findModuleType( "EtherSwitch" );
	check_modtype( modtype, "EtherSwitch" );
	cModule *switch_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	switch_mod = modtype->create( "switch", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	switch_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = switch_mod->params();
	for(k=0;k<n;k++)
	   if(switch_mod->par(k).isInput())
	      {switch_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "n" );
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "switch","in","MediumLAN");
	switch_mod->setGateSize("in", n );

	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "n" );
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "switch","out","MediumLAN");
	switch_mod->setGateSize("out", n );

	switch_mod->setDisplayString(dispSUBMOD, "i=switch2" );

	// build function call:
	switch_mod->buildInside();
	machines.clear();

	// host
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	sub_nr = mod->par( "n" );
	check_module_count(sub_nr,"host","MediumLAN");
	cModule **host_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		host_mod[sub_i] = modtype->create( "host", mod, islocal);
		check_error(); check_memory();

		host_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		host_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = host_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(host_mod[sub_i]->par(k).isInput())
		      {host_mod[sub_i]->par(k).read();check_error();}

		host_mod[sub_i]->setDisplayString(dispSUBMOD, "i=pc_s" );

		// build function call:
		host_mod[sub_i]->buildInside();
	}
	machines.clear();

	// hub
	modtype = findModuleType( "EtherHub" );
	check_modtype( modtype, "EtherHub" );
	cModule *hub_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hub_mod = modtype->create( "hub", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hub_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hub_mod->params();
	for(k=0;k<n;k++)
	   if(hub_mod->par(k).isInput())
	      {hub_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "h" );
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "hub","in","MediumLAN");
	hub_mod->setGateSize("in", n );

	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "h" );
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "hub","out","MediumLAN");
	hub_mod->setGateSize("out", n );

	hub_mod->setDisplayString(dispSUBMOD, "i=switch1" );

	// build function call:
	hub_mod->buildInside();
	machines.clear();

	// hhost
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	sub_nr = mod->par( "h" );
	check_module_count(sub_nr,"hhost","MediumLAN");
	cModule **hhost_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		hhost_mod[sub_i] = modtype->create( "hhost", mod, islocal);
		check_error(); check_memory();

		hhost_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		hhost_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = hhost_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(hhost_mod[sub_i]->par(k).isInput())
		      {hhost_mod[sub_i]->par(k).read();check_error();}

		hhost_mod[sub_i]->setDisplayString(dispSUBMOD, "i=pc_s" );

		// build function call:
		hhost_mod[sub_i]->buildInside();
	}
	machines.clear();

	// Connections:
	cLinkType *link_p;
	cPar *delay_p, *error_p, *datarate_p;
	int gateL, gateR;
	long mod_nr_L, mod_nr_R, gate_nr_L, gate_nr_R;
	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "n" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "MediumLAN");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = switch_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,host_mod,"host", "MediumLAN");
			gateR = host_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "host", "in" );

			connect (switch_mod, gateL,
			         link_p,
			         host_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = switch_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,host_mod,"host", "MediumLAN");
			gateR = host_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "host", "out" );

			connect (host_mod[mod_nr_R], gateR,
			         link_p,
			         switch_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = mod->par( "n" );
	gateL = switch_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

	gateR = mod->findGate( "out" );
	check_gate( gateR, "", "out" );

	connect (switch_mod, gateL,
	         NULL,
	         mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = mod->par( "n" );
	gateL = switch_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

	gateR = mod->findGate( "in" );
	check_gate( gateR, "", "in" );

	connect (mod, gateR,
	         NULL,
	         switch_mod, gateL);

	check_error(); check_memory();
	} // end-if

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "h" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "MediumLAN");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = hub_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "hub", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,hhost_mod,"hhost", "MediumLAN");
			gateR = hhost_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "hhost", "in" );

			connect (hub_mod, gateL,
			         link_p,
			         hhost_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = hub_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "hub", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,hhost_mod,"hhost", "MediumLAN");
			gateR = hhost_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "hhost", "out" );

			connect (hhost_mod[mod_nr_R], gateR,
			         link_p,
			         hub_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "n" );
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switch_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

	gate_nr_R = mod->par( "h" );
	gateR = hub_mod->findGate( "in", gate_nr_R );
	check_gate( gateR, "hub", indexedname(b1,"in",gate_nr_R) );

	connect (switch_mod, gateL,
	         link_p,
	         hub_mod, gateR);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "n" );
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switch_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

	gate_nr_R = mod->par( "h" );
	gateR = hub_mod->findGate( "out", gate_nr_R );
	check_gate( gateR, "hub", indexedname(b1,"out",gate_nr_R) );

	connect (hub_mod, gateR,
	         link_p,
	         switch_mod, gateL);

	check_error(); check_memory();
	} // end-if

	mod->checkInternalConnections();
	delete[] host_mod;
	delete[] hhost_mod;
	check_error(); check_memory();
}

ModuleInterface( LargeLAN )
	Machine( default )
	Parameter( n, ParType_Numeric ParType_Const )
	Parameter( h, ParType_Numeric ParType_Const )
	Parameter( b, ParType_Numeric ParType_Const )
	Gate( in, GateDir_Input )
	Gate( out, GateDir_Output )
EndInterface

Register_ModuleInterface( LargeLAN )

class LargeLAN : public cCompoundModule
{
  public:
    LargeLAN(const char *name, cModule *parentmod) :
      cCompoundModule(name, parentmod) {}
  protected:
    virtual void doBuildInside();
};

Define_Module( LargeLAN );

void LargeLAN::doBuildInside()
{
	cModule *mod = this;
	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// const parameters:
	// Submodules:
	cModuleType *modtype = NULL;
	long sub_nr = 0;
	long sub_i = 0;

	// switch
	modtype = findModuleType( "EtherSwitch" );
	check_modtype( modtype, "EtherSwitch" );
	cModule *switch_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	switch_mod = modtype->create( "switch", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	switch_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = switch_mod->params();
	for(k=0;k<n;k++)
	   if(switch_mod->par(k).isInput())
	      {switch_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "n" );
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "switch","in","LargeLAN");
	switch_mod->setGateSize("in", n );

	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "n" );
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "switch","out","LargeLAN");
	switch_mod->setGateSize("out", n );

	switch_mod->setDisplayString(dispSUBMOD, "i=switch2" );

	// build function call:
	switch_mod->buildInside();
	machines.clear();

	// host
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	sub_nr = mod->par( "n" );
	check_module_count(sub_nr,"host","LargeLAN");
	cModule **host_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		host_mod[sub_i] = modtype->create( "host", mod, islocal);
		check_error(); check_memory();

		host_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		host_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = host_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(host_mod[sub_i]->par(k).isInput())
		      {host_mod[sub_i]->par(k).read();check_error();}

		host_mod[sub_i]->setDisplayString(dispSUBMOD, "i=pc_s" );

		// build function call:
		host_mod[sub_i]->buildInside();
	}
	machines.clear();

	// hub
	modtype = findModuleType( "EtherHub" );
	check_modtype( modtype, "EtherHub" );
	cModule *hub_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	hub_mod = modtype->create( "hub", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	hub_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = hub_mod->params();
	for(k=0;k<n;k++)
	   if(hub_mod->par(k).isInput())
	      {hub_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "h" );
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "hub","in","LargeLAN");
	hub_mod->setGateSize("in", n );

	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "h" );
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "hub","out","LargeLAN");
	hub_mod->setGateSize("out", n );

	hub_mod->setDisplayString(dispSUBMOD, "i=switch1" );

	// build function call:
	hub_mod->buildInside();
	machines.clear();

	// hhost
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	sub_nr = mod->par( "h" );
	check_module_count(sub_nr,"hhost","LargeLAN");
	cModule **hhost_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		hhost_mod[sub_i] = modtype->create( "hhost", mod, islocal);
		check_error(); check_memory();

		hhost_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		hhost_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = hhost_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(hhost_mod[sub_i]->par(k).isInput())
		      {hhost_mod[sub_i]->par(k).read();check_error();}

		hhost_mod[sub_i]->setDisplayString(dispSUBMOD, "i=pc_s" );

		// build function call:
		hhost_mod[sub_i]->buildInside();
	}
	machines.clear();

	// bus
	modtype = findModuleType( "EtherBus" );
	check_modtype( modtype, "EtherBus" );
	cModule *bus_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	bus_mod = modtype->create( "bus", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	bus_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	// 'parameters:' section
	par = &(bus_mod->par("positions"));
	check_param(par, "positions");
	*par = "5 10 15";

	par = &(bus_mod->par("propagationSpeed"));
	check_param(par, "propagationSpeed");
	*par = 200000000;

	n = bus_mod->params();
	for(k=0;k<n;k++)
	   if(bus_mod->par(k).isInput())
	      {bus_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "b" );
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "bus","in","LargeLAN");
	bus_mod->setGateSize("in", n );

	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "b" );
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "bus","out","LargeLAN");
	bus_mod->setGateSize("out", n );

	bus_mod->setDisplayString(dispSUBMOD, "b=424,6;o=#408060" );

	// build function call:
	bus_mod->buildInside();
	machines.clear();

	// bhost
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	sub_nr = mod->par( "b" );
	check_module_count(sub_nr,"bhost","LargeLAN");
	cModule **bhost_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		bhost_mod[sub_i] = modtype->create( "bhost", mod, islocal);
		check_error(); check_memory();

		bhost_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		bhost_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = bhost_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(bhost_mod[sub_i]->par(k).isInput())
		      {bhost_mod[sub_i]->par(k).read();check_error();}

		bhost_mod[sub_i]->setDisplayString(dispSUBMOD, "p=,,r;i=pc_s" );

		// build function call:
		bhost_mod[sub_i]->buildInside();
	}
	machines.clear();

	// Connections:
	cLinkType *link_p;
	cPar *delay_p, *error_p, *datarate_p;
	int gateL, gateR;
	long mod_nr_L, mod_nr_R, gate_nr_L, gate_nr_R;
	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "n" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeLAN");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = switch_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,host_mod,"host", "LargeLAN");
			gateR = host_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "host", "in" );

			connect (switch_mod, gateL,
			         link_p,
			         host_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = switch_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,host_mod,"host", "LargeLAN");
			gateR = host_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "host", "out" );

			connect (host_mod[mod_nr_R], gateR,
			         link_p,
			         switch_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = mod->par( "n" );
	gateL = switch_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

	gateR = mod->findGate( "out" );
	check_gate( gateR, "", "out" );

	connect (switch_mod, gateL,
	         NULL,
	         mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = mod->par( "n" );
	gateL = switch_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

	gateR = mod->findGate( "in" );
	check_gate( gateR, "", "in" );

	connect (mod, gateR,
	         NULL,
	         switch_mod, gateL);

	check_error(); check_memory();
	} // end-if

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "h" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeLAN");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = hub_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "hub", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,hhost_mod,"hhost", "LargeLAN");
			gateR = hhost_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "hhost", "in" );

			connect (hub_mod, gateL,
			         link_p,
			         hhost_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = hub_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "hub", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,hhost_mod,"hhost", "LargeLAN");
			gateR = hhost_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "hhost", "out" );

			connect (hhost_mod[mod_nr_R], gateR,
			         link_p,
			         hub_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "n" );
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switch_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"out",gate_nr_L) );

	gate_nr_R = mod->par( "h" );
	gateR = hub_mod->findGate( "in", gate_nr_R );
	check_gate( gateR, "hub", indexedname(b1,"in",gate_nr_R) );

	connect (switch_mod, gateL,
	         link_p,
	         hub_mod, gateR);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "n" );
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switch_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switch", indexedname(b1,"in",gate_nr_L) );

	gate_nr_R = mod->par( "h" );
	gateR = hub_mod->findGate( "out", gate_nr_R );
	check_gate( gateR, "hub", indexedname(b1,"out",gate_nr_R) );

	connect (hub_mod, gateR,
	         link_p,
	         switch_mod, gateL);

	check_error(); check_memory();
	} // end-if

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "b" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeLAN");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = bus_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "bus", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,bhost_mod,"bhost", "LargeLAN");
			gateR = bhost_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "bhost", "in" );

			connect (bus_mod, gateL,
			         NULL,
			         bhost_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if


			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = bus_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "bus", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,bhost_mod,"bhost", "LargeLAN");
			gateR = bhost_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "bhost", "out" );

			connect (bhost_mod[mod_nr_R], gateR,
			         NULL,
			         bus_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = mod->par( "b" );
	gateL = bus_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"out",gate_nr_L) );

	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "h" );
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_R = value;
	gateR = hub_mod->findGate( "in", gate_nr_R );
	check_gate( gateR, "hub", indexedname(b1,"in",gate_nr_R) );

	connect (bus_mod, gateL,
	         NULL,
	         hub_mod, gateR);

	check_error(); check_memory();
	} // end-if


	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	gate_nr_L = mod->par( "b" );
	gateL = bus_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "bus", indexedname(b1,"in",gate_nr_L) );

	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "h" );
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_R = value;
	gateR = hub_mod->findGate( "out", gate_nr_R );
	check_gate( gateR, "hub", indexedname(b1,"out",gate_nr_R) );

	connect (hub_mod, gateR,
	         NULL,
	         bus_mod, gateL);

	check_error(); check_memory();
	} // end-if

	mod->checkInternalConnections();
	delete[] host_mod;
	delete[] hhost_mod;
	delete[] bhost_mod;
	check_error(); check_memory();
}

ModuleInterface( LargeNet )
	Machine( default )
	Parameter( n, ParType_Numeric ParType_Const )
	Parameter( bbs, ParType_Numeric )
	Parameter( bbm, ParType_Numeric )
	Parameter( bbl, ParType_Numeric ParType_Const )
	Parameter( as, ParType_Numeric )
	Parameter( am, ParType_Numeric )
	Parameter( al, ParType_Numeric ParType_Const )
	Parameter( bs, ParType_Numeric )
	Parameter( bm, ParType_Numeric )
	Parameter( bl, ParType_Numeric ParType_Const )
	Parameter( cs, ParType_Numeric )
	Parameter( cm, ParType_Numeric )
	Parameter( cl, ParType_Numeric ParType_Const )
	Parameter( ds, ParType_Numeric )
	Parameter( dm, ParType_Numeric )
	Parameter( dl, ParType_Numeric ParType_Const )
EndInterface

Register_ModuleInterface( LargeNet )

class LargeNet : public cCompoundModule
{
  public:
    LargeNet(const char *name, cModule *parentmod) :
      cCompoundModule(name, parentmod) {}
  protected:
    virtual void doBuildInside();
};

Define_Module( LargeNet );

void LargeNet::doBuildInside()
{
	cModule *mod = this;
	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// const parameters:
	// Submodules:
	cModuleType *modtype = NULL;
	long sub_nr = 0;
	long sub_i = 0;

	// switchBB
	modtype = findModuleType( "EtherSwitch" );
	check_modtype( modtype, "EtherSwitch" );
	sub_nr = mod->par( "n" );
	check_module_count(sub_nr,"switchBB","LargeNet");
	cModule **switchBB_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		switchBB_mod[sub_i] = modtype->create( "switchBB", mod, islocal);
		check_error(); check_memory();

		switchBB_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		switchBB_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = switchBB_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(switchBB_mod[sub_i]->par(k).isInput())
		      {switchBB_mod[sub_i]->par(k).read();check_error();}

		// 'gatesizes:' section
		expr_tab = new cPar::ExprElem[7]; k=0;
		expr_tab[k++] = mod->par( "bbs" );
		expr_tab[k++] = mod->par( "bbm" );
		expr_tab[k++] = '+';
		expr_tab[k++] = mod->par( "bbl" );
		expr_tab[k++] = '+';
		expr_tab[k++] = 3;
		expr_tab[k++] = '+';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		n = value;
		check_gate_count( n, "switchBB","in","LargeNet");
		switchBB_mod[sub_i]->setGateSize("in", n );

		expr_tab = new cPar::ExprElem[7]; k=0;
		expr_tab[k++] = mod->par( "bbs" );
		expr_tab[k++] = mod->par( "bbm" );
		expr_tab[k++] = '+';
		expr_tab[k++] = mod->par( "bbl" );
		expr_tab[k++] = '+';
		expr_tab[k++] = 3;
		expr_tab[k++] = '+';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		n = value;
		check_gate_count( n, "switchBB","out","LargeNet");
		switchBB_mod[sub_i]->setGateSize("out", n );

		switchBB_mod[sub_i]->setDisplayString(dispSUBMOD, "i=switch2" );

		// build function call:
		switchBB_mod[sub_i]->buildInside();
	}
	machines.clear();

	// slanBB
	modtype = findModuleType( "SmallLAN" );
	check_modtype( modtype, "SmallLAN" );
	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "n" );
	expr_tab[k++] = mod->par( "bbs" );
	expr_tab[k++] = '*';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	sub_nr = value;
	check_module_count(sub_nr,"slanBB","LargeNet");
	cModule **slanBB_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		slanBB_mod[sub_i] = modtype->create( "slanBB", mod, islocal);
		check_error(); check_memory();

		slanBB_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		slanBB_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = slanBB_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(slanBB_mod[sub_i]->par(k).isInput())
		      {slanBB_mod[sub_i]->par(k).read();check_error();}

		slanBB_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud_s" );

		// build function call:
		slanBB_mod[sub_i]->buildInside();
	}
	machines.clear();

	// mlanBB
	modtype = findModuleType( "MediumLAN" );
	check_modtype( modtype, "MediumLAN" );
	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "n" );
	expr_tab[k++] = mod->par( "bbm" );
	expr_tab[k++] = '*';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	sub_nr = value;
	check_module_count(sub_nr,"mlanBB","LargeNet");
	cModule **mlanBB_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		mlanBB_mod[sub_i] = modtype->create( "mlanBB", mod, islocal);
		check_error(); check_memory();

		mlanBB_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		mlanBB_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = mlanBB_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(mlanBB_mod[sub_i]->par(k).isInput())
		      {mlanBB_mod[sub_i]->par(k).read();check_error();}

		mlanBB_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud_s" );

		// build function call:
		mlanBB_mod[sub_i]->buildInside();
	}
	machines.clear();

	// llanBB
	modtype = findModuleType( "LargeLAN" );
	check_modtype( modtype, "LargeLAN" );
	expr_tab = new cPar::ExprElem[3]; k=0;
	expr_tab[k++] = mod->par( "n" );
	expr_tab[k++] = mod->par( "bbl" );
	expr_tab[k++] = '*';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	sub_nr = value;
	check_module_count(sub_nr,"llanBB","LargeNet");
	cModule **llanBB_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		llanBB_mod[sub_i] = modtype->create( "llanBB", mod, islocal);
		check_error(); check_memory();

		llanBB_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		llanBB_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = llanBB_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(llanBB_mod[sub_i]->par(k).isInput())
		      {llanBB_mod[sub_i]->par(k).read();check_error();}

		llanBB_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud" );

		// build function call:
		llanBB_mod[sub_i]->buildInside();
	}
	machines.clear();

	// switchA
	modtype = findModuleType( "EtherSwitch" );
	check_modtype( modtype, "EtherSwitch" );
	cModule *switchA_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	switchA_mod = modtype->create( "switchA", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	switchA_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = switchA_mod->params();
	for(k=0;k<n;k++)
	   if(switchA_mod->par(k).isInput())
	      {switchA_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "as" );
	expr_tab[k++] = mod->par( "am" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "al" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "switchA","in","LargeNet");
	switchA_mod->setGateSize("in", n );

	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "as" );
	expr_tab[k++] = mod->par( "am" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "al" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "switchA","out","LargeNet");
	switchA_mod->setGateSize("out", n );

	switchA_mod->setDisplayString(dispSUBMOD, "i=switch2" );

	// build function call:
	switchA_mod->buildInside();
	machines.clear();

	// serverA
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *serverA_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	serverA_mod = modtype->create( "serverA", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	serverA_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = serverA_mod->params();
	for(k=0;k<n;k++)
	   if(serverA_mod->par(k).isInput())
	      {serverA_mod->par(k).read();check_error();}

	serverA_mod->setDisplayString(dispSUBMOD, "i=server1" );

	// build function call:
	serverA_mod->buildInside();
	machines.clear();

	// slanA
	modtype = findModuleType( "SmallLAN" );
	check_modtype( modtype, "SmallLAN" );
	sub_nr = mod->par( "as" );
	check_module_count(sub_nr,"slanA","LargeNet");
	cModule **slanA_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		slanA_mod[sub_i] = modtype->create( "slanA", mod, islocal);
		check_error(); check_memory();

		slanA_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		slanA_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = slanA_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(slanA_mod[sub_i]->par(k).isInput())
		      {slanA_mod[sub_i]->par(k).read();check_error();}

		slanA_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud_s" );

		// build function call:
		slanA_mod[sub_i]->buildInside();
	}
	machines.clear();

	// mlanA
	modtype = findModuleType( "MediumLAN" );
	check_modtype( modtype, "MediumLAN" );
	sub_nr = mod->par( "am" );
	check_module_count(sub_nr,"mlanA","LargeNet");
	cModule **mlanA_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		mlanA_mod[sub_i] = modtype->create( "mlanA", mod, islocal);
		check_error(); check_memory();

		mlanA_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		mlanA_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = mlanA_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(mlanA_mod[sub_i]->par(k).isInput())
		      {mlanA_mod[sub_i]->par(k).read();check_error();}

		mlanA_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud_s" );

		// build function call:
		mlanA_mod[sub_i]->buildInside();
	}
	machines.clear();

	// llanA
	modtype = findModuleType( "LargeLAN" );
	check_modtype( modtype, "LargeLAN" );
	sub_nr = mod->par( "al" );
	check_module_count(sub_nr,"llanA","LargeNet");
	cModule **llanA_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		llanA_mod[sub_i] = modtype->create( "llanA", mod, islocal);
		check_error(); check_memory();

		llanA_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		llanA_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = llanA_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(llanA_mod[sub_i]->par(k).isInput())
		      {llanA_mod[sub_i]->par(k).read();check_error();}

		llanA_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud" );

		// build function call:
		llanA_mod[sub_i]->buildInside();
	}
	machines.clear();

	// switchB
	modtype = findModuleType( "EtherSwitch" );
	check_modtype( modtype, "EtherSwitch" );
	cModule *switchB_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	switchB_mod = modtype->create( "switchB", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	switchB_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = switchB_mod->params();
	for(k=0;k<n;k++)
	   if(switchB_mod->par(k).isInput())
	      {switchB_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "bs" );
	expr_tab[k++] = mod->par( "bm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "bl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 4;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "switchB","in","LargeNet");
	switchB_mod->setGateSize("in", n );

	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "bs" );
	expr_tab[k++] = mod->par( "bm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "bl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 4;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "switchB","out","LargeNet");
	switchB_mod->setGateSize("out", n );

	switchB_mod->setDisplayString(dispSUBMOD, "i=switch2" );

	// build function call:
	switchB_mod->buildInside();
	machines.clear();

	// serverB
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *serverB_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	serverB_mod = modtype->create( "serverB", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	serverB_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = serverB_mod->params();
	for(k=0;k<n;k++)
	   if(serverB_mod->par(k).isInput())
	      {serverB_mod->par(k).read();check_error();}

	serverB_mod->setDisplayString(dispSUBMOD, "i=server1" );

	// build function call:
	serverB_mod->buildInside();
	machines.clear();

	// slanB
	modtype = findModuleType( "SmallLAN" );
	check_modtype( modtype, "SmallLAN" );
	sub_nr = mod->par( "bs" );
	check_module_count(sub_nr,"slanB","LargeNet");
	cModule **slanB_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		slanB_mod[sub_i] = modtype->create( "slanB", mod, islocal);
		check_error(); check_memory();

		slanB_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		slanB_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = slanB_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(slanB_mod[sub_i]->par(k).isInput())
		      {slanB_mod[sub_i]->par(k).read();check_error();}

		slanB_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud_s" );

		// build function call:
		slanB_mod[sub_i]->buildInside();
	}
	machines.clear();

	// mlanB
	modtype = findModuleType( "MediumLAN" );
	check_modtype( modtype, "MediumLAN" );
	sub_nr = mod->par( "bm" );
	check_module_count(sub_nr,"mlanB","LargeNet");
	cModule **mlanB_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		mlanB_mod[sub_i] = modtype->create( "mlanB", mod, islocal);
		check_error(); check_memory();

		mlanB_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		mlanB_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = mlanB_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(mlanB_mod[sub_i]->par(k).isInput())
		      {mlanB_mod[sub_i]->par(k).read();check_error();}

		mlanB_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud_s" );

		// build function call:
		mlanB_mod[sub_i]->buildInside();
	}
	machines.clear();

	// llanB
	modtype = findModuleType( "LargeLAN" );
	check_modtype( modtype, "LargeLAN" );
	sub_nr = mod->par( "bl" );
	check_module_count(sub_nr,"llanB","LargeNet");
	cModule **llanB_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		llanB_mod[sub_i] = modtype->create( "llanB", mod, islocal);
		check_error(); check_memory();

		llanB_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		llanB_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = llanB_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(llanB_mod[sub_i]->par(k).isInput())
		      {llanB_mod[sub_i]->par(k).read();check_error();}

		llanB_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud" );

		// build function call:
		llanB_mod[sub_i]->buildInside();
	}
	machines.clear();

	// switchC
	modtype = findModuleType( "EtherSwitch" );
	check_modtype( modtype, "EtherSwitch" );
	cModule *switchC_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	switchC_mod = modtype->create( "switchC", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	switchC_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = switchC_mod->params();
	for(k=0;k<n;k++)
	   if(switchC_mod->par(k).isInput())
	      {switchC_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "cs" );
	expr_tab[k++] = mod->par( "cm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "cl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 3;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "switchC","in","LargeNet");
	switchC_mod->setGateSize("in", n );

	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "cs" );
	expr_tab[k++] = mod->par( "cm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "cl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 3;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "switchC","out","LargeNet");
	switchC_mod->setGateSize("out", n );

	switchC_mod->setDisplayString(dispSUBMOD, "i=switch2" );

	// build function call:
	switchC_mod->buildInside();
	machines.clear();

	// serverC
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *serverC_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	serverC_mod = modtype->create( "serverC", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	serverC_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = serverC_mod->params();
	for(k=0;k<n;k++)
	   if(serverC_mod->par(k).isInput())
	      {serverC_mod->par(k).read();check_error();}

	serverC_mod->setDisplayString(dispSUBMOD, "i=server1" );

	// build function call:
	serverC_mod->buildInside();
	machines.clear();

	// slanC
	modtype = findModuleType( "SmallLAN" );
	check_modtype( modtype, "SmallLAN" );
	sub_nr = mod->par( "cs" );
	check_module_count(sub_nr,"slanC","LargeNet");
	cModule **slanC_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		slanC_mod[sub_i] = modtype->create( "slanC", mod, islocal);
		check_error(); check_memory();

		slanC_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		slanC_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = slanC_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(slanC_mod[sub_i]->par(k).isInput())
		      {slanC_mod[sub_i]->par(k).read();check_error();}

		slanC_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud_s" );

		// build function call:
		slanC_mod[sub_i]->buildInside();
	}
	machines.clear();

	// mlanC
	modtype = findModuleType( "MediumLAN" );
	check_modtype( modtype, "MediumLAN" );
	sub_nr = mod->par( "cm" );
	check_module_count(sub_nr,"mlanC","LargeNet");
	cModule **mlanC_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		mlanC_mod[sub_i] = modtype->create( "mlanC", mod, islocal);
		check_error(); check_memory();

		mlanC_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		mlanC_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = mlanC_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(mlanC_mod[sub_i]->par(k).isInput())
		      {mlanC_mod[sub_i]->par(k).read();check_error();}

		mlanC_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud_s" );

		// build function call:
		mlanC_mod[sub_i]->buildInside();
	}
	machines.clear();

	// llanC
	modtype = findModuleType( "LargeLAN" );
	check_modtype( modtype, "LargeLAN" );
	sub_nr = mod->par( "cl" );
	check_module_count(sub_nr,"llanC","LargeNet");
	cModule **llanC_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		llanC_mod[sub_i] = modtype->create( "llanC", mod, islocal);
		check_error(); check_memory();

		llanC_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		llanC_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = llanC_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(llanC_mod[sub_i]->par(k).isInput())
		      {llanC_mod[sub_i]->par(k).read();check_error();}

		llanC_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud" );

		// build function call:
		llanC_mod[sub_i]->buildInside();
	}
	machines.clear();

	// switchD
	modtype = findModuleType( "EtherSwitch" );
	check_modtype( modtype, "EtherSwitch" );
	cModule *switchD_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	switchD_mod = modtype->create( "switchD", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	switchD_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = switchD_mod->params();
	for(k=0;k<n;k++)
	   if(switchD_mod->par(k).isInput())
	      {switchD_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "ds" );
	expr_tab[k++] = mod->par( "dm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "dl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "switchD","in","LargeNet");
	switchD_mod->setGateSize("in", n );

	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "ds" );
	expr_tab[k++] = mod->par( "dm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "dl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	n = value;
	check_gate_count( n, "switchD","out","LargeNet");
	switchD_mod->setGateSize("out", n );

	switchD_mod->setDisplayString(dispSUBMOD, "i=switch2" );

	// build function call:
	switchD_mod->buildInside();
	machines.clear();

	// serverD
	modtype = findModuleType( "EtherHost" );
	check_modtype( modtype, "EtherHost" );
	cModule *serverD_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	serverD_mod = modtype->create( "serverD", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	serverD_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = serverD_mod->params();
	for(k=0;k<n;k++)
	   if(serverD_mod->par(k).isInput())
	      {serverD_mod->par(k).read();check_error();}

	serverD_mod->setDisplayString(dispSUBMOD, "i=server1" );

	// build function call:
	serverD_mod->buildInside();
	machines.clear();

	// slanD
	modtype = findModuleType( "SmallLAN" );
	check_modtype( modtype, "SmallLAN" );
	sub_nr = mod->par( "ds" );
	check_module_count(sub_nr,"slanD","LargeNet");
	cModule **slanD_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		slanD_mod[sub_i] = modtype->create( "slanD", mod, islocal);
		check_error(); check_memory();

		slanD_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		slanD_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = slanD_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(slanD_mod[sub_i]->par(k).isInput())
		      {slanD_mod[sub_i]->par(k).read();check_error();}

		slanD_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud_s" );

		// build function call:
		slanD_mod[sub_i]->buildInside();
	}
	machines.clear();

	// mlanD
	modtype = findModuleType( "MediumLAN" );
	check_modtype( modtype, "MediumLAN" );
	sub_nr = mod->par( "dm" );
	check_module_count(sub_nr,"mlanD","LargeNet");
	cModule **mlanD_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		mlanD_mod[sub_i] = modtype->create( "mlanD", mod, islocal);
		check_error(); check_memory();

		mlanD_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		mlanD_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = mlanD_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(mlanD_mod[sub_i]->par(k).isInput())
		      {mlanD_mod[sub_i]->par(k).read();check_error();}

		mlanD_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud_s" );

		// build function call:
		mlanD_mod[sub_i]->buildInside();
	}
	machines.clear();

	// llanD
	modtype = findModuleType( "LargeLAN" );
	check_modtype( modtype, "LargeLAN" );
	sub_nr = mod->par( "dl" );
	check_module_count(sub_nr,"llanD","LargeNet");
	cModule **llanD_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		llanD_mod[sub_i] = modtype->create( "llanD", mod, islocal);
		check_error(); check_memory();

		llanD_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		llanD_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		n = llanD_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(llanD_mod[sub_i]->par(k).isInput())
		      {llanD_mod[sub_i]->par(k).read();check_error();}

		llanD_mod[sub_i]->setDisplayString(dispSUBMOD, "i=cloud" );

		// build function call:
		llanD_mod[sub_i]->buildInside();
	}
	machines.clear();

	// Connections:
	cLinkType *link_p;
	cPar *delay_p, *error_p, *datarate_p;
	int gateL, gateR;
	long mod_nr_L, mod_nr_R, gate_nr_L, gate_nr_R;
	{
		// for k loop:
		long k_index;

		long k_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "n" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long k_end = value;
		check_loop_bounds(k_begin, k_end, "LargeNet");
		for (k_index=k_begin; k_index<=k_end; k_index++)
		{
			// for i loop:
			long i_index;

			long i_begin = 0;
			expr_tab = new cPar::ExprElem[3]; k=0;
			expr_tab[k++] = mod->par( "bbs" );
			expr_tab[k++] = 1;
			expr_tab[k++] = '-';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			long i_end = value;
			check_loop_bounds(i_begin, i_end, "LargeNet");
			for (i_index=i_begin; i_index<=i_end; i_index++)
			{
				link_p = findLink( "cable" );

				do_this_block = true; // no "if" condition
				if (do_this_block) // "if" in NED
				{
				mod_nr_L = k_index;
				check_module_index(mod_nr_L,switchBB_mod,"switchBB", "LargeNet");
				gate_nr_L = i_index;
				gateL = switchBB_mod[mod_nr_L]->findGate( "out", gate_nr_L );
				check_gate( gateL, "switchBB", indexedname(b1,"out",gate_nr_L) );

				expr_tab = new cPar::ExprElem[5]; k=0;
				expr_tab[k++] = k_index;
				expr_tab[k++] = mod->par( "bbs" );
				expr_tab[k++] = '*';
				expr_tab[k++] = i_index;
				expr_tab[k++] = '+';
				value.cancelRedirection();
				value.setDoubleValue(expr_tab,k);
				mod_nr_R = value;
				check_module_index(mod_nr_R,slanBB_mod,"slanBB", "LargeNet");
				gateR = slanBB_mod[mod_nr_R]->findGate( "in" );
				check_gate( gateR, "slanBB", "in" );

				connect (switchBB_mod[mod_nr_L], gateL,
				         link_p,
				         slanBB_mod[mod_nr_R], gateR);

				check_error(); check_memory();
				} // end-if

				link_p = findLink( "cable" );

				do_this_block = true; // no "if" condition
				if (do_this_block) // "if" in NED
				{
				mod_nr_L = k_index;
				check_module_index(mod_nr_L,switchBB_mod,"switchBB", "LargeNet");
				gate_nr_L = i_index;
				gateL = switchBB_mod[mod_nr_L]->findGate( "in", gate_nr_L );
				check_gate( gateL, "switchBB", indexedname(b1,"in",gate_nr_L) );

				expr_tab = new cPar::ExprElem[5]; k=0;
				expr_tab[k++] = k_index;
				expr_tab[k++] = mod->par( "bbs" );
				expr_tab[k++] = '*';
				expr_tab[k++] = i_index;
				expr_tab[k++] = '+';
				value.cancelRedirection();
				value.setDoubleValue(expr_tab,k);
				mod_nr_R = value;
				check_module_index(mod_nr_R,slanBB_mod,"slanBB", "LargeNet");
				gateR = slanBB_mod[mod_nr_R]->findGate( "out" );
				check_gate( gateR, "slanBB", "out" );

				connect (slanBB_mod[mod_nr_R], gateR,
				         link_p,
				         switchBB_mod[mod_nr_L], gateL);

				check_error(); check_memory();
				} // end-if

			} // end for i

		} // end for k

	}

	{
		// for k loop:
		long k_index;

		long k_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "n" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long k_end = value;
		check_loop_bounds(k_begin, k_end, "LargeNet");
		for (k_index=k_begin; k_index<=k_end; k_index++)
		{
			// for i loop:
			long i_index;

			long i_begin = 0;
			expr_tab = new cPar::ExprElem[3]; k=0;
			expr_tab[k++] = mod->par( "bbm" );
			expr_tab[k++] = 1;
			expr_tab[k++] = '-';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			long i_end = value;
			check_loop_bounds(i_begin, i_end, "LargeNet");
			for (i_index=i_begin; i_index<=i_end; i_index++)
			{
				link_p = findLink( "cable" );

				do_this_block = true; // no "if" condition
				if (do_this_block) // "if" in NED
				{
				mod_nr_L = k_index;
				check_module_index(mod_nr_L,switchBB_mod,"switchBB", "LargeNet");
				expr_tab = new cPar::ExprElem[3]; k=0;
				expr_tab[k++] = mod->par( "bbs" );
				expr_tab[k++] = i_index;
				expr_tab[k++] = '+';
				value.cancelRedirection();
				value.setDoubleValue(expr_tab,k);
				gate_nr_L = value;
				gateL = switchBB_mod[mod_nr_L]->findGate( "out", gate_nr_L );
				check_gate( gateL, "switchBB", indexedname(b1,"out",gate_nr_L) );

				expr_tab = new cPar::ExprElem[5]; k=0;
				expr_tab[k++] = k_index;
				expr_tab[k++] = mod->par( "bbm" );
				expr_tab[k++] = '*';
				expr_tab[k++] = i_index;
				expr_tab[k++] = '+';
				value.cancelRedirection();
				value.setDoubleValue(expr_tab,k);
				mod_nr_R = value;
				check_module_index(mod_nr_R,mlanBB_mod,"mlanBB", "LargeNet");
				gateR = mlanBB_mod[mod_nr_R]->findGate( "in" );
				check_gate( gateR, "mlanBB", "in" );

				connect (switchBB_mod[mod_nr_L], gateL,
				         link_p,
				         mlanBB_mod[mod_nr_R], gateR);

				check_error(); check_memory();
				} // end-if

				link_p = findLink( "cable" );

				do_this_block = true; // no "if" condition
				if (do_this_block) // "if" in NED
				{
				mod_nr_L = k_index;
				check_module_index(mod_nr_L,switchBB_mod,"switchBB", "LargeNet");
				expr_tab = new cPar::ExprElem[3]; k=0;
				expr_tab[k++] = mod->par( "bbs" );
				expr_tab[k++] = i_index;
				expr_tab[k++] = '+';
				value.cancelRedirection();
				value.setDoubleValue(expr_tab,k);
				gate_nr_L = value;
				gateL = switchBB_mod[mod_nr_L]->findGate( "in", gate_nr_L );
				check_gate( gateL, "switchBB", indexedname(b1,"in",gate_nr_L) );

				expr_tab = new cPar::ExprElem[5]; k=0;
				expr_tab[k++] = k_index;
				expr_tab[k++] = mod->par( "bbm" );
				expr_tab[k++] = '*';
				expr_tab[k++] = i_index;
				expr_tab[k++] = '+';
				value.cancelRedirection();
				value.setDoubleValue(expr_tab,k);
				mod_nr_R = value;
				check_module_index(mod_nr_R,mlanBB_mod,"mlanBB", "LargeNet");
				gateR = mlanBB_mod[mod_nr_R]->findGate( "out" );
				check_gate( gateR, "mlanBB", "out" );

				connect (mlanBB_mod[mod_nr_R], gateR,
				         link_p,
				         switchBB_mod[mod_nr_L], gateL);

				check_error(); check_memory();
				} // end-if

			} // end for i

		} // end for k

	}

	{
		// for k loop:
		long k_index;

		long k_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "n" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long k_end = value;
		check_loop_bounds(k_begin, k_end, "LargeNet");
		for (k_index=k_begin; k_index<=k_end; k_index++)
		{
			// for i loop:
			long i_index;

			long i_begin = 0;
			expr_tab = new cPar::ExprElem[3]; k=0;
			expr_tab[k++] = mod->par( "bbl" );
			expr_tab[k++] = 1;
			expr_tab[k++] = '-';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			long i_end = value;
			check_loop_bounds(i_begin, i_end, "LargeNet");
			for (i_index=i_begin; i_index<=i_end; i_index++)
			{
				link_p = findLink( "cable" );

				do_this_block = true; // no "if" condition
				if (do_this_block) // "if" in NED
				{
				mod_nr_L = k_index;
				check_module_index(mod_nr_L,switchBB_mod,"switchBB", "LargeNet");
				expr_tab = new cPar::ExprElem[5]; k=0;
				expr_tab[k++] = mod->par( "bbs" );
				expr_tab[k++] = mod->par( "bbm" );
				expr_tab[k++] = '+';
				expr_tab[k++] = i_index;
				expr_tab[k++] = '+';
				value.cancelRedirection();
				value.setDoubleValue(expr_tab,k);
				gate_nr_L = value;
				gateL = switchBB_mod[mod_nr_L]->findGate( "out", gate_nr_L );
				check_gate( gateL, "switchBB", indexedname(b1,"out",gate_nr_L) );

				expr_tab = new cPar::ExprElem[5]; k=0;
				expr_tab[k++] = k_index;
				expr_tab[k++] = mod->par( "bbl" );
				expr_tab[k++] = '*';
				expr_tab[k++] = i_index;
				expr_tab[k++] = '+';
				value.cancelRedirection();
				value.setDoubleValue(expr_tab,k);
				mod_nr_R = value;
				check_module_index(mod_nr_R,llanBB_mod,"llanBB", "LargeNet");
				gateR = llanBB_mod[mod_nr_R]->findGate( "in" );
				check_gate( gateR, "llanBB", "in" );

				connect (switchBB_mod[mod_nr_L], gateL,
				         link_p,
				         llanBB_mod[mod_nr_R], gateR);

				check_error(); check_memory();
				} // end-if

				link_p = findLink( "cable" );

				do_this_block = true; // no "if" condition
				if (do_this_block) // "if" in NED
				{
				mod_nr_L = k_index;
				check_module_index(mod_nr_L,switchBB_mod,"switchBB", "LargeNet");
				expr_tab = new cPar::ExprElem[5]; k=0;
				expr_tab[k++] = mod->par( "bbs" );
				expr_tab[k++] = mod->par( "bbm" );
				expr_tab[k++] = '+';
				expr_tab[k++] = i_index;
				expr_tab[k++] = '+';
				value.cancelRedirection();
				value.setDoubleValue(expr_tab,k);
				gate_nr_L = value;
				gateL = switchBB_mod[mod_nr_L]->findGate( "in", gate_nr_L );
				check_gate( gateL, "switchBB", indexedname(b1,"in",gate_nr_L) );

				expr_tab = new cPar::ExprElem[5]; k=0;
				expr_tab[k++] = k_index;
				expr_tab[k++] = mod->par( "bbl" );
				expr_tab[k++] = '*';
				expr_tab[k++] = i_index;
				expr_tab[k++] = '+';
				value.cancelRedirection();
				value.setDoubleValue(expr_tab,k);
				mod_nr_R = value;
				check_module_index(mod_nr_R,llanBB_mod,"llanBB", "LargeNet");
				gateR = llanBB_mod[mod_nr_R]->findGate( "out" );
				check_gate( gateR, "llanBB", "out" );

				connect (llanBB_mod[mod_nr_R], gateR,
				         link_p,
				         switchBB_mod[mod_nr_L], gateL);

				check_error(); check_memory();
				} // end-if

			} // end for i

		} // end for k

	}

	{
		// for k loop:
		long k_index;

		long k_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "n" );
		expr_tab[k++] = 2;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long k_end = value;
		check_loop_bounds(k_begin, k_end, "LargeNet");
		for (k_index=k_begin; k_index<=k_end; k_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			mod_nr_L = k_index;
			check_module_index(mod_nr_L,switchBB_mod,"switchBB", "LargeNet");
			expr_tab = new cPar::ExprElem[5]; k=0;
			expr_tab[k++] = mod->par( "bbs" );
			expr_tab[k++] = mod->par( "bbm" );
			expr_tab[k++] = '+';
			expr_tab[k++] = mod->par( "bbl" );
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchBB_mod[mod_nr_L]->findGate( "out", gate_nr_L );
			check_gate( gateL, "switchBB", indexedname(b1,"out",gate_nr_L) );

			expr_tab = new cPar::ExprElem[3]; k=0;
			expr_tab[k++] = k_index;
			expr_tab[k++] = 1;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			mod_nr_R = value;
			check_module_index(mod_nr_R,switchBB_mod,"switchBB", "LargeNet");
			expr_tab = new cPar::ExprElem[7]; k=0;
			expr_tab[k++] = mod->par( "bbs" );
			expr_tab[k++] = mod->par( "bbm" );
			expr_tab[k++] = '+';
			expr_tab[k++] = mod->par( "bbl" );
			expr_tab[k++] = '+';
			expr_tab[k++] = 1;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_R = value;
			gateR = switchBB_mod[mod_nr_R]->findGate( "in", gate_nr_R );
			check_gate( gateR, "switchBB", indexedname(b1,"in",gate_nr_R) );

			connect (switchBB_mod[mod_nr_L], gateL,
			         link_p,
			         switchBB_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			mod_nr_L = k_index;
			check_module_index(mod_nr_L,switchBB_mod,"switchBB", "LargeNet");
			expr_tab = new cPar::ExprElem[5]; k=0;
			expr_tab[k++] = mod->par( "bbs" );
			expr_tab[k++] = mod->par( "bbm" );
			expr_tab[k++] = '+';
			expr_tab[k++] = mod->par( "bbl" );
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchBB_mod[mod_nr_L]->findGate( "in", gate_nr_L );
			check_gate( gateL, "switchBB", indexedname(b1,"in",gate_nr_L) );

			expr_tab = new cPar::ExprElem[3]; k=0;
			expr_tab[k++] = k_index;
			expr_tab[k++] = 1;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			mod_nr_R = value;
			check_module_index(mod_nr_R,switchBB_mod,"switchBB", "LargeNet");
			expr_tab = new cPar::ExprElem[7]; k=0;
			expr_tab[k++] = mod->par( "bbs" );
			expr_tab[k++] = mod->par( "bbm" );
			expr_tab[k++] = '+';
			expr_tab[k++] = mod->par( "bbl" );
			expr_tab[k++] = '+';
			expr_tab[k++] = 1;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_R = value;
			gateR = switchBB_mod[mod_nr_R]->findGate( "out", gate_nr_R );
			check_gate( gateR, "switchBB", indexedname(b1,"out",gate_nr_R) );

			connect (switchBB_mod[mod_nr_R], gateR,
			         link_p,
			         switchBB_mod[mod_nr_L], gateL);

			check_error(); check_memory();
			} // end-if

		} // end for k

	}

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "as" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeNet");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = switchA_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switchA", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,slanA_mod,"slanA", "LargeNet");
			gateR = slanA_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "slanA", "in" );

			connect (switchA_mod, gateL,
			         link_p,
			         slanA_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = switchA_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switchA", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,slanA_mod,"slanA", "LargeNet");
			gateR = slanA_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "slanA", "out" );

			connect (slanA_mod[mod_nr_R], gateR,
			         link_p,
			         switchA_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "am" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeNet");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[3]; k=0;
			expr_tab[k++] = mod->par( "as" );
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchA_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switchA", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,mlanA_mod,"mlanA", "LargeNet");
			gateR = mlanA_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "mlanA", "in" );

			connect (switchA_mod, gateL,
			         link_p,
			         mlanA_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[3]; k=0;
			expr_tab[k++] = mod->par( "as" );
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchA_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switchA", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,mlanA_mod,"mlanA", "LargeNet");
			gateR = mlanA_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "mlanA", "out" );

			connect (mlanA_mod[mod_nr_R], gateR,
			         link_p,
			         switchA_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "al" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeNet");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[5]; k=0;
			expr_tab[k++] = mod->par( "as" );
			expr_tab[k++] = mod->par( "am" );
			expr_tab[k++] = '+';
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchA_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switchA", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,llanA_mod,"llanA", "LargeNet");
			gateR = llanA_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "llanA", "in" );

			connect (switchA_mod, gateL,
			         link_p,
			         llanA_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[5]; k=0;
			expr_tab[k++] = mod->par( "as" );
			expr_tab[k++] = mod->par( "am" );
			expr_tab[k++] = '+';
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchA_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switchA", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,llanA_mod,"llanA", "LargeNet");
			gateR = llanA_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "llanA", "out" );

			connect (llanA_mod[mod_nr_R], gateR,
			         link_p,
			         switchA_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[5]; k=0;
	expr_tab[k++] = mod->par( "as" );
	expr_tab[k++] = mod->par( "am" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "al" );
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchA_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switchA", indexedname(b1,"out",gate_nr_L) );

	gateR = serverA_mod->findGate( "in" );
	check_gate( gateR, "serverA", "in" );

	connect (switchA_mod, gateL,
	         link_p,
	         serverA_mod, gateR);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[5]; k=0;
	expr_tab[k++] = mod->par( "as" );
	expr_tab[k++] = mod->par( "am" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "al" );
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchA_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switchA", indexedname(b1,"in",gate_nr_L) );

	gateR = serverA_mod->findGate( "out" );
	check_gate( gateR, "serverA", "out" );

	connect (serverA_mod, gateR,
	         link_p,
	         switchA_mod, gateL);

	check_error(); check_memory();
	} // end-if

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "bs" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeNet");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = switchB_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switchB", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,slanB_mod,"slanB", "LargeNet");
			gateR = slanB_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "slanB", "in" );

			connect (switchB_mod, gateL,
			         link_p,
			         slanB_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = switchB_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switchB", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,slanB_mod,"slanB", "LargeNet");
			gateR = slanB_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "slanB", "out" );

			connect (slanB_mod[mod_nr_R], gateR,
			         link_p,
			         switchB_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "bm" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeNet");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[3]; k=0;
			expr_tab[k++] = mod->par( "bs" );
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchB_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switchB", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,mlanB_mod,"mlanB", "LargeNet");
			gateR = mlanB_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "mlanB", "in" );

			connect (switchB_mod, gateL,
			         link_p,
			         mlanB_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[3]; k=0;
			expr_tab[k++] = mod->par( "bs" );
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchB_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switchB", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,mlanB_mod,"mlanB", "LargeNet");
			gateR = mlanB_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "mlanB", "out" );

			connect (mlanB_mod[mod_nr_R], gateR,
			         link_p,
			         switchB_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "bl" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeNet");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[5]; k=0;
			expr_tab[k++] = mod->par( "bs" );
			expr_tab[k++] = mod->par( "bm" );
			expr_tab[k++] = '+';
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchB_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switchB", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,llanB_mod,"llanB", "LargeNet");
			gateR = llanB_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "llanB", "in" );

			connect (switchB_mod, gateL,
			         link_p,
			         llanB_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[5]; k=0;
			expr_tab[k++] = mod->par( "bs" );
			expr_tab[k++] = mod->par( "bm" );
			expr_tab[k++] = '+';
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchB_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switchB", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,llanB_mod,"llanB", "LargeNet");
			gateR = llanB_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "llanB", "out" );

			connect (llanB_mod[mod_nr_R], gateR,
			         link_p,
			         switchB_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[5]; k=0;
	expr_tab[k++] = mod->par( "bs" );
	expr_tab[k++] = mod->par( "bm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "bl" );
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchB_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switchB", indexedname(b1,"out",gate_nr_L) );

	gateR = serverB_mod->findGate( "in" );
	check_gate( gateR, "serverB", "in" );

	connect (switchB_mod, gateL,
	         link_p,
	         serverB_mod, gateR);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[5]; k=0;
	expr_tab[k++] = mod->par( "bs" );
	expr_tab[k++] = mod->par( "bm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "bl" );
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchB_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switchB", indexedname(b1,"in",gate_nr_L) );

	gateR = serverB_mod->findGate( "out" );
	check_gate( gateR, "serverB", "out" );

	connect (serverB_mod, gateR,
	         link_p,
	         switchB_mod, gateL);

	check_error(); check_memory();
	} // end-if

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "cs" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeNet");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = switchC_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switchC", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,slanC_mod,"slanC", "LargeNet");
			gateR = slanC_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "slanC", "in" );

			connect (switchC_mod, gateL,
			         link_p,
			         slanC_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = switchC_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switchC", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,slanC_mod,"slanC", "LargeNet");
			gateR = slanC_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "slanC", "out" );

			connect (slanC_mod[mod_nr_R], gateR,
			         link_p,
			         switchC_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "cm" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeNet");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[3]; k=0;
			expr_tab[k++] = mod->par( "cs" );
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchC_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switchC", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,mlanC_mod,"mlanC", "LargeNet");
			gateR = mlanC_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "mlanC", "in" );

			connect (switchC_mod, gateL,
			         link_p,
			         mlanC_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[3]; k=0;
			expr_tab[k++] = mod->par( "cs" );
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchC_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switchC", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,mlanC_mod,"mlanC", "LargeNet");
			gateR = mlanC_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "mlanC", "out" );

			connect (mlanC_mod[mod_nr_R], gateR,
			         link_p,
			         switchC_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "cl" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeNet");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[5]; k=0;
			expr_tab[k++] = mod->par( "cs" );
			expr_tab[k++] = mod->par( "cm" );
			expr_tab[k++] = '+';
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchC_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switchC", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,llanC_mod,"llanC", "LargeNet");
			gateR = llanC_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "llanC", "in" );

			connect (switchC_mod, gateL,
			         link_p,
			         llanC_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[5]; k=0;
			expr_tab[k++] = mod->par( "cs" );
			expr_tab[k++] = mod->par( "cm" );
			expr_tab[k++] = '+';
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchC_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switchC", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,llanC_mod,"llanC", "LargeNet");
			gateR = llanC_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "llanC", "out" );

			connect (llanC_mod[mod_nr_R], gateR,
			         link_p,
			         switchC_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[5]; k=0;
	expr_tab[k++] = mod->par( "cs" );
	expr_tab[k++] = mod->par( "cm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "cl" );
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchC_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switchC", indexedname(b1,"out",gate_nr_L) );

	gateR = serverC_mod->findGate( "in" );
	check_gate( gateR, "serverC", "in" );

	connect (switchC_mod, gateL,
	         link_p,
	         serverC_mod, gateR);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[5]; k=0;
	expr_tab[k++] = mod->par( "cs" );
	expr_tab[k++] = mod->par( "cm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "cl" );
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchC_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switchC", indexedname(b1,"in",gate_nr_L) );

	gateR = serverC_mod->findGate( "out" );
	check_gate( gateR, "serverC", "out" );

	connect (serverC_mod, gateR,
	         link_p,
	         switchC_mod, gateL);

	check_error(); check_memory();
	} // end-if

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "ds" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeNet");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = switchD_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switchD", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,slanD_mod,"slanD", "LargeNet");
			gateR = slanD_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "slanD", "in" );

			connect (switchD_mod, gateL,
			         link_p,
			         slanD_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			gate_nr_L = i_index;
			gateL = switchD_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switchD", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,slanD_mod,"slanD", "LargeNet");
			gateR = slanD_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "slanD", "out" );

			connect (slanD_mod[mod_nr_R], gateR,
			         link_p,
			         switchD_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "dm" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeNet");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[3]; k=0;
			expr_tab[k++] = mod->par( "ds" );
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchD_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switchD", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,mlanD_mod,"mlanD", "LargeNet");
			gateR = mlanD_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "mlanD", "in" );

			connect (switchD_mod, gateL,
			         link_p,
			         mlanD_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[3]; k=0;
			expr_tab[k++] = mod->par( "ds" );
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchD_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switchD", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,mlanD_mod,"mlanD", "LargeNet");
			gateR = mlanD_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "mlanD", "out" );

			connect (mlanD_mod[mod_nr_R], gateR,
			         link_p,
			         switchD_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->par( "dl" );
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "LargeNet");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{
			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[5]; k=0;
			expr_tab[k++] = mod->par( "ds" );
			expr_tab[k++] = mod->par( "dm" );
			expr_tab[k++] = '+';
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchD_mod->findGate( "out", gate_nr_L );
			check_gate( gateL, "switchD", indexedname(b1,"out",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,llanD_mod,"llanD", "LargeNet");
			gateR = llanD_mod[mod_nr_R]->findGate( "in" );
			check_gate( gateR, "llanD", "in" );

			connect (switchD_mod, gateL,
			         link_p,
			         llanD_mod[mod_nr_R], gateR);

			check_error(); check_memory();
			} // end-if

			link_p = findLink( "cable" );

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			expr_tab = new cPar::ExprElem[5]; k=0;
			expr_tab[k++] = mod->par( "ds" );
			expr_tab[k++] = mod->par( "dm" );
			expr_tab[k++] = '+';
			expr_tab[k++] = i_index;
			expr_tab[k++] = '+';
			value.cancelRedirection();
			value.setDoubleValue(expr_tab,k);
			gate_nr_L = value;
			gateL = switchD_mod->findGate( "in", gate_nr_L );
			check_gate( gateL, "switchD", indexedname(b1,"in",gate_nr_L) );

			mod_nr_R = i_index;
			check_module_index(mod_nr_R,llanD_mod,"llanD", "LargeNet");
			gateR = llanD_mod[mod_nr_R]->findGate( "out" );
			check_gate( gateR, "llanD", "out" );

			connect (llanD_mod[mod_nr_R], gateR,
			         link_p,
			         switchD_mod, gateL);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[5]; k=0;
	expr_tab[k++] = mod->par( "ds" );
	expr_tab[k++] = mod->par( "dm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "dl" );
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchD_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switchD", indexedname(b1,"out",gate_nr_L) );

	gateR = serverD_mod->findGate( "in" );
	check_gate( gateR, "serverD", "in" );

	connect (switchD_mod, gateL,
	         link_p,
	         serverD_mod, gateR);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[5]; k=0;
	expr_tab[k++] = mod->par( "ds" );
	expr_tab[k++] = mod->par( "dm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "dl" );
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchD_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switchD", indexedname(b1,"in",gate_nr_L) );

	gateR = serverD_mod->findGate( "out" );
	check_gate( gateR, "serverD", "out" );

	connect (serverD_mod, gateR,
	         link_p,
	         switchD_mod, gateL);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "as" );
	expr_tab[k++] = mod->par( "am" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "al" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchA_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switchA", indexedname(b1,"out",gate_nr_L) );

	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "bs" );
	expr_tab[k++] = mod->par( "bm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "bl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_R = value;
	gateR = switchB_mod->findGate( "in", gate_nr_R );
	check_gate( gateR, "switchB", indexedname(b1,"in",gate_nr_R) );

	connect (switchA_mod, gateL,
	         link_p,
	         switchB_mod, gateR);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "as" );
	expr_tab[k++] = mod->par( "am" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "al" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchA_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switchA", indexedname(b1,"in",gate_nr_L) );

	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "bs" );
	expr_tab[k++] = mod->par( "bm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "bl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_R = value;
	gateR = switchB_mod->findGate( "out", gate_nr_R );
	check_gate( gateR, "switchB", indexedname(b1,"out",gate_nr_R) );

	connect (switchB_mod, gateR,
	         link_p,
	         switchA_mod, gateL);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "bs" );
	expr_tab[k++] = mod->par( "bm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "bl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchB_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switchB", indexedname(b1,"out",gate_nr_L) );

	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "cs" );
	expr_tab[k++] = mod->par( "cm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "cl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_R = value;
	gateR = switchC_mod->findGate( "in", gate_nr_R );
	check_gate( gateR, "switchC", indexedname(b1,"in",gate_nr_R) );

	connect (switchB_mod, gateL,
	         link_p,
	         switchC_mod, gateR);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "bs" );
	expr_tab[k++] = mod->par( "bm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "bl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchB_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switchB", indexedname(b1,"in",gate_nr_L) );

	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "cs" );
	expr_tab[k++] = mod->par( "cm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "cl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_R = value;
	gateR = switchC_mod->findGate( "out", gate_nr_R );
	check_gate( gateR, "switchC", indexedname(b1,"out",gate_nr_R) );

	connect (switchC_mod, gateR,
	         link_p,
	         switchB_mod, gateL);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "cs" );
	expr_tab[k++] = mod->par( "cm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "cl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchC_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switchC", indexedname(b1,"out",gate_nr_L) );

	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "ds" );
	expr_tab[k++] = mod->par( "dm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "dl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_R = value;
	gateR = switchD_mod->findGate( "in", gate_nr_R );
	check_gate( gateR, "switchD", indexedname(b1,"in",gate_nr_R) );

	connect (switchC_mod, gateL,
	         link_p,
	         switchD_mod, gateR);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "cs" );
	expr_tab[k++] = mod->par( "cm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "cl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchC_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switchC", indexedname(b1,"in",gate_nr_L) );

	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "ds" );
	expr_tab[k++] = mod->par( "dm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "dl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 1;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_R = value;
	gateR = switchD_mod->findGate( "out", gate_nr_R );
	check_gate( gateR, "switchD", indexedname(b1,"out",gate_nr_R) );

	connect (switchD_mod, gateR,
	         link_p,
	         switchC_mod, gateL);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "bs" );
	expr_tab[k++] = mod->par( "bm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "bl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 3;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchB_mod->findGate( "out", gate_nr_L );
	check_gate( gateL, "switchB", indexedname(b1,"out",gate_nr_L) );

	mod_nr_R = 4;
	check_module_index(mod_nr_R,switchBB_mod,"switchBB", "LargeNet");
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "bbs" );
	expr_tab[k++] = mod->par( "bbm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "bbl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_R = value;
	gateR = switchBB_mod[mod_nr_R]->findGate( "in", gate_nr_R );
	check_gate( gateR, "switchBB", indexedname(b1,"in",gate_nr_R) );

	connect (switchB_mod, gateL,
	         link_p,
	         switchBB_mod[mod_nr_R], gateR);

	check_error(); check_memory();
	} // end-if

	link_p = findLink( "cable" );

	do_this_block = true; // no "if" condition
	if (do_this_block) // "if" in NED
	{
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "bs" );
	expr_tab[k++] = mod->par( "bm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "bl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 3;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_L = value;
	gateL = switchB_mod->findGate( "in", gate_nr_L );
	check_gate( gateL, "switchB", indexedname(b1,"in",gate_nr_L) );

	mod_nr_R = 4;
	check_module_index(mod_nr_R,switchBB_mod,"switchBB", "LargeNet");
	expr_tab = new cPar::ExprElem[7]; k=0;
	expr_tab[k++] = mod->par( "bbs" );
	expr_tab[k++] = mod->par( "bbm" );
	expr_tab[k++] = '+';
	expr_tab[k++] = mod->par( "bbl" );
	expr_tab[k++] = '+';
	expr_tab[k++] = 2;
	expr_tab[k++] = '+';
	value.cancelRedirection();
	value.setDoubleValue(expr_tab,k);
	gate_nr_R = value;
	gateR = switchBB_mod[mod_nr_R]->findGate( "out", gate_nr_R );
	check_gate( gateR, "switchBB", indexedname(b1,"out",gate_nr_R) );

	connect (switchBB_mod[mod_nr_R], gateR,
	         link_p,
	         switchB_mod, gateL);

	check_error(); check_memory();
	} // end-if

	delete[] switchBB_mod;
	delete[] slanBB_mod;
	delete[] mlanBB_mod;
	delete[] llanBB_mod;
	delete[] slanA_mod;
	delete[] mlanA_mod;
	delete[] llanA_mod;
	delete[] slanB_mod;
	delete[] mlanB_mod;
	delete[] llanB_mod;
	delete[] slanC_mod;
	delete[] mlanC_mod;
	delete[] llanC_mod;
	delete[] slanD_mod;
	delete[] mlanD_mod;
	delete[] llanD_mod;
	check_error(); check_memory();
}

class smallLAN : public cNetworkType
{
  public:
    smallLAN(const char *name) : cNetworkType(name) {}
    smallLAN(const smallLAN& n)  {setName(n.name());operator=(n);}
    virtual void setupNetwork();
};

Define_Network( smallLAN );

void smallLAN::setupNetwork()
{

	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = ev.getPhysicalMachineFor("default");
	machines.add( par );
	check_error(); check_memory();

	// system module creation
	cModuleType *modtype;
	modtype = findModuleType( "SmallLAN" );
	check_modtype( modtype, "SmallLAN" );
	cModule *smallLAN_mod;

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	if (!islocal)
	    throw new cException("Local machine `%s' is not among machines specified for this network",
	              simulation.netInterface()->localhost());
	smallLAN_mod = modtype->create( "smallLAN", NULL, islocal);
	check_error(); check_memory();

	// set machine list:
	smallLAN_mod->setMachinePar( "default", ev.getPhysicalMachineFor("default") );
	check_error(); check_memory();

	n = smallLAN_mod->params();
	for(k=0;k<n;k++)
	   if(smallLAN_mod->par(k).isInput())
	      {smallLAN_mod->par(k).read();check_error();}

	// build function call:
	smallLAN_mod->buildInside();
	machines.clear();

	check_error(); check_memory();
}

class largeLAN : public cNetworkType
{
  public:
    largeLAN(const char *name) : cNetworkType(name) {}
    largeLAN(const largeLAN& n)  {setName(n.name());operator=(n);}
    virtual void setupNetwork();
};

Define_Network( largeLAN );

void largeLAN::setupNetwork()
{

	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = ev.getPhysicalMachineFor("default");
	machines.add( par );
	check_error(); check_memory();

	// system module creation
	cModuleType *modtype;
	modtype = findModuleType( "LargeLAN" );
	check_modtype( modtype, "LargeLAN" );
	cModule *largeLAN_mod;

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	if (!islocal)
	    throw new cException("Local machine `%s' is not among machines specified for this network",
	              simulation.netInterface()->localhost());
	largeLAN_mod = modtype->create( "largeLAN", NULL, islocal);
	check_error(); check_memory();

	// set machine list:
	largeLAN_mod->setMachinePar( "default", ev.getPhysicalMachineFor("default") );
	check_error(); check_memory();

	n = largeLAN_mod->params();
	for(k=0;k<n;k++)
	   if(largeLAN_mod->par(k).isInput())
	      {largeLAN_mod->par(k).read();check_error();}

	// build function call:
	largeLAN_mod->buildInside();
	machines.clear();

	check_error(); check_memory();
}

class largeNet : public cNetworkType
{
  public:
    largeNet(const char *name) : cNetworkType(name) {}
    largeNet(const largeNet& n)  {setName(n.name());operator=(n);}
    virtual void setupNetwork();
};

Define_Network( largeNet );

void largeNet::setupNetwork()
{

	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = ev.getPhysicalMachineFor("default");
	machines.add( par );
	check_error(); check_memory();

	// system module creation
	cModuleType *modtype;
	modtype = findModuleType( "LargeNet" );
	check_modtype( modtype, "LargeNet" );
	cModule *largeNet_mod;

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	if (!islocal)
	    throw new cException("Local machine `%s' is not among machines specified for this network",
	              simulation.netInterface()->localhost());
	largeNet_mod = modtype->create( "largeNet", NULL, islocal);
	check_error(); check_memory();

	// set machine list:
	largeNet_mod->setMachinePar( "default", ev.getPhysicalMachineFor("default") );
	check_error(); check_memory();

	n = largeNet_mod->params();
	for(k=0;k<n;k++)
	   if(largeNet_mod->par(k).isInput())
	      {largeNet_mod->par(k).read();check_error();}

	// build function call:
	largeNet_mod->buildInside();
	machines.clear();

	check_error(); check_memory();
}


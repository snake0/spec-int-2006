//-----------------------------------------
//
// Generated by NEDC version 2.3
// date:	Tue May 18 19:06:59 2004
//
// Input file:	EtherMAC.ned
// Output file:	EtherMAC_n.cc
//-----------------------------------------


#if defined(SPEC_CPU)
#include <cmath>
#else
#include <math.h>
#endif
#include "omnetpp.h"

#define check_error() \
    {(void)0;}
#define check_memory() \
    {if (memoryIsLow()) {throw new cException(eNOMEM); }}
#define check_module_count(num, mod, parentmod) \
    {if ((int)num<=0) {throw new cException("Negative or zero module vector size %s[%d] in compound module %s", \
                          mod,(int)num,parentmod);}}
#define check_gate_count(num, mod, gate, parentmod) \
    {if ((int)num<0) {throw new cException("Negative gate vector size %s.%s[%d] in compound module %s", \
                          mod,gate,(int)num,parentmod);}}
#define check_loop_bounds(lower, upper, parentmod) \
    {if ((int)lower<0) \
        {throw new cException("Bad loop bounds (%d..%d) in compound module %s", \
                 (int)lower,(int)upper,parentmod);}}
#define check_module_index(index,modvar,modname,parentmod) \
    {if (index<0 || index>=modvar[0]->size()) {throw new cException("Bad submodule index %s[%d] in compound module %s", \
          modname,(int)index,parentmod);}}
#define check_channel_params(delay, err, channel) \
    {if ((double)delay<0.0) \
        {throw new cException("Negative delay value %lf in channel %s",(double)delay,channel);} \
     if ((double)err<0.0 || (double)err>1.0) \
        {throw new cException("Incorrect error value %lf in channel %s",(double)err,channel);}}
#define check_modtype(modtype, modname) \
    {if ((modtype)==NULL) {throw new cException("Simple module type definition %s not found", \
                                     modname);}}
#define check_function(funcptr, funcname) \
    {if ((funcptr)==NULL) {throw new cException("Function %s not found", \
                                     funcname);}}
#define check_function_retnull(funcptr, funcname) \
    {if ((funcptr)==NULL) {throw new cException("Function %s not found", \
                                     funcname);return NULL;}}
#define check_gate(gateindex, modname, gatename) \
    {if ((int)gateindex==-1) {throw new cException("Gate %s.%s not found",modname,gatename);}}
#define check_anc_param(ptr,parname,compoundmod) \
    {if ((ptr)==NULL) {throw new cException("Unknown ancestor parameter named %s in compound module %s", \
                                parname,compoundmod);}}
#define check_param(ptr,parname) \
    {if ((ptr)==NULL) {throw new cException("Unknown parameter named %s", \
                                parname);}}
#ifndef __cplusplus
#  error Compile as C++!
#endif
#ifdef __BORLANDC__
#  if !defined(__FLAT__) && !defined(__LARGE__)
#    error Compile as 16-bit LARGE model or 32-bit DPMI!
#  endif
#endif

// Disable warnings about unused variables:
#ifdef _MSC_VER
#  pragma warning(disable:4101)
#endif
#ifdef __BORLANDC__
#  pragma warn -waus
#  pragma warn -wuse
#endif
// for GCC, seemingly there's no way to emulate the -Wunused command-line
// flag from a source file...

// Version check
#define NEDC_VERSION 0x0203
#if (NEDC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedc: 'make clean' should help.
#endif

//--------------------------------------------
// Following code generated from: EtherSwitch.ned
//--------------------------------------------

ModuleInterface( EtherSwitch )
	Machine( default )
	Parameter( relayUnitType, ParType_String )
	Gate( in[], GateDir_Input )
	Gate( out[], GateDir_Output )
EndInterface

Register_ModuleInterface( EtherSwitch )

class EtherSwitch : public cCompoundModule
{
  public:
    EtherSwitch(const char *name, cModule *parentmod) :
      cCompoundModule(name, parentmod) {}
  protected:
    virtual void doBuildInside();
};

Define_Module( EtherSwitch );

void EtherSwitch::doBuildInside()
{
	cModule *mod = this;
	// temporary variables:
	cPar value, *par;
	cPar::ExprElem *expr_tab; int k;
	cFunctionType *functype;
	const char *type_name;
	char b1[64], b2[64];
	cArray machines;
	bool islocal, do_this_block;
	int n;

	// const parameters:
	// Submodules:
	cModuleType *modtype = NULL;
	long sub_nr = 0;
	long sub_i = 0;

	// relayUnit
	par = &mod->par("relayUnitType");
	check_param(par,"relayUnitType");
	type_name = (const char *)par;
	type_name = mod->par("relayUnitType");
	modtype = findModuleType( type_name );
	check_modtype( modtype, type_name );
	cModule *relayUnit_mod;

	// an empty actual machine list for the next module
	par = new cPar();
	*par = mod->machinePar("default");
	machines.add( par );
	check_error(); check_memory();

	// module creation:
	islocal = simulation.netInterface()==NULL ||
	          simulation.netInterface()->isLocalMachineIn( machines );
	relayUnit_mod = modtype->create( "relayUnit", mod, islocal);
	check_error(); check_memory();

	// set machine list:
	relayUnit_mod->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
	check_error(); check_memory();

	n = relayUnit_mod->params();
	for(k=0;k<n;k++)
	   if(relayUnit_mod->par(k).isInput())
	      {relayUnit_mod->par(k).read();check_error();}

	// 'gatesizes:' section
	n = mod->gate( "in" )->size();
;
	check_gate_count( n, "relayUnit","lowerLayerIn","EtherSwitch");
	relayUnit_mod->setGateSize("lowerLayerIn", n );

	n = mod->gate( "in" )->size();
;
	check_gate_count( n, "relayUnit","lowerLayerOut","EtherSwitch");
	relayUnit_mod->setGateSize("lowerLayerOut", n );

	relayUnit_mod->setDisplayString(dispSUBMOD, "i=greenbox;p=200,50" );

	// build function call:
	relayUnit_mod->buildInside();
	machines.clear();

	// mac
	modtype = findModuleType( "EtherMAC" );
	check_modtype( modtype, "EtherMAC" );
	sub_nr = mod->gate( "in" )->size();
;
	check_module_count(sub_nr,"mac","EtherSwitch");
	cModule **mac_mod = new cModule *[sub_nr];

	for (sub_i=0; sub_i<sub_nr; sub_i++)
	{
		// an empty actual machine list for the next module
		par = new cPar();
		*par = mod->machinePar("default");
		machines.add( par );
		check_error(); check_memory();

		// module creation:
		islocal = simulation.netInterface()==NULL ||
		          simulation.netInterface()->isLocalMachineIn( machines );
		mac_mod[sub_i] = modtype->create( "mac", mod, islocal);
		check_error(); check_memory();

		mac_mod[sub_i]->setIndex(sub_i, sub_nr);

		// set machine list:
		mac_mod[sub_i]->setMachinePar( "default", ((cPar *)machines[0])->stringValue() );
		check_error(); check_memory();

		// 'parameters:' section
		par = &(mac_mod[sub_i]->par("promiscuous"));
		check_param(par, "promiscuous");
		*par = true;

		n = mac_mod[sub_i]->params();
		for(k=0;k<n;k++)
		   if(mac_mod[sub_i]->par(k).isInput())
		      {mac_mod[sub_i]->par(k).read();check_error();}

		mac_mod[sub_i]->setDisplayString(dispSUBMOD, "i=queue;p=70,150,row" );

		// build function call:
		mac_mod[sub_i]->buildInside();
	}
	machines.clear();

	// Connections:
	cLinkType *link_p;
	cPar *delay_p, *error_p, *datarate_p;
	int gateL, gateR;
	long mod_nr_L, mod_nr_R, gate_nr_L, gate_nr_R;
	{
		// for i loop:
		long i_index;

		long i_begin = 0;
		expr_tab = new cPar::ExprElem[3]; k=0;
		expr_tab[k++] = mod->gate( "in" )->size();
;
		expr_tab[k++] = 1;
		expr_tab[k++] = '-';
		value.cancelRedirection();
		value.setDoubleValue(expr_tab,k);
		long i_end = value;
		check_loop_bounds(i_begin, i_end, "EtherSwitch");
		for (i_index=i_begin; i_index<=i_end; i_index++)
		{

			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			mod_nr_L = i_index;
			check_module_index(mod_nr_L,mac_mod,"mac", "EtherSwitch");
			gateL = mac_mod[mod_nr_L]->findGate( "upperLayerIn" );
			check_gate( gateL, "mac", "upperLayerIn" );

			gate_nr_R = i_index;
			gateR = relayUnit_mod->findGate( "lowerLayerOut", gate_nr_R );
			check_gate( gateR, "relayUnit", indexedname(b1,"lowerLayerOut",gate_nr_R) );

			connect (relayUnit_mod, gateR,
			         NULL,
			         mac_mod[mod_nr_L], gateL);

			check_error(); check_memory();
			} // end-if


			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			mod_nr_L = i_index;
			check_module_index(mod_nr_L,mac_mod,"mac", "EtherSwitch");
			gateL = mac_mod[mod_nr_L]->findGate( "upperLayerOut" );
			check_gate( gateL, "mac", "upperLayerOut" );

			gate_nr_R = i_index;
			gateR = relayUnit_mod->findGate( "lowerLayerIn", gate_nr_R );
			check_gate( gateR, "relayUnit", indexedname(b1,"lowerLayerIn",gate_nr_R) );

			connect (mac_mod[mod_nr_L], gateL,
			         NULL,
			         relayUnit_mod, gateR);

			check_error(); check_memory();
			} // end-if


			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			mod_nr_L = i_index;
			check_module_index(mod_nr_L,mac_mod,"mac", "EtherSwitch");
			gateL = mac_mod[mod_nr_L]->findGate( "physicalIn" );
			check_gate( gateL, "mac", "physicalIn" );

			gate_nr_R = i_index;
			gateR = mod->findGate( "in", gate_nr_R );
			check_gate( gateR, "", indexedname(b1,"in",gate_nr_R) );

			connect (mod, gateR,
			         NULL,
			         mac_mod[mod_nr_L], gateL);

			check_error(); check_memory();
			} // end-if


			do_this_block = true; // no "if" condition
			if (do_this_block) // "if" in NED
			{
			mod_nr_L = i_index;
			check_module_index(mod_nr_L,mac_mod,"mac", "EtherSwitch");
			gateL = mac_mod[mod_nr_L]->findGate( "physicalOut" );
			check_gate( gateL, "mac", "physicalOut" );

			gate_nr_R = i_index;
			gateR = mod->findGate( "out", gate_nr_R );
			check_gate( gateR, "", indexedname(b1,"out",gate_nr_R) );

			connect (mac_mod[mod_nr_L], gateL,
			         NULL,
			         mod, gateR);

			check_error(); check_memory();
			} // end-if

		} // end for i

	}

	mod->checkInternalConnections();
	delete[] mac_mod;
	check_error(); check_memory();
}


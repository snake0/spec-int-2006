C  9 DEC 03 - OQ  - TWOEI: PASS NFLMAT TO DFCKNS ROUTINE
C  4 NOV 03 - TJP - XYZINT: CLEAN UP EXECUTION FLOW
C  3 SEP 03 - SPW - TWOEI: ADDED DIRCIS ARGUMENT AND CALL TO DRFCIS
C  3 JUL 03 - JMM - SUPPRESS PRINTING FOR MONTE CARLO JOBS
C 28 JAN 03 - MWS - SHELLS: ARGUMENT TO SUPPRESS ANGULAR MOMENTUM FLIP
C 12 DEC 02 - MWS - MIN ZETA FOR HONDO INCREASED EVEN FOR PLAIN HF JOBS,
C                   REMOVE HALVING OF CUTOFF IN DEBUT FOR FDIFF JOBS
C 20 JUN 02 - MWS - TWOEI: ANIONS SEND DIFFUSE INTS TO HONDO PACKAGE
C 26 MAR 02 - YA  - TWOEI: IMMEDIATE SCREENING SKIP IF NOT PK FILE
C 16 NOV 01 - JMS - POPLE PACKAGE INITIALIZATIONS CHANGED
C  8 OCT 01 - MWS - RESTORE TIMING CALL
C  6 SEP 01 - CHC - INTIN : ADD QFMM OPTION
C  1 AUG 01 - MWS - MIN ZETA TO FORCE HONDO SMALLER IF VIRTS UNOCCUPIED
C 25 JUN 01 - MWS - ALTER COMMON BLOCK WFNOPT
C 13 JUN 01 - DGF - INTIN: USE OF GRID DFT FORCES NOPK SETTING
C 19 NOV 00 - RMM,HL - INTIN: PAD OUT EDCMP COMMON FOR POLAPP KEYWORD
C 26 OCT 00 - MWS - INTRODUCE MXAO PARAMETER
C 11 JUN 00 - MWS - TWOEI: SEND SMALL EXPONENT SP INTEGRALS TO HONDO
C  1 MAY 00 - MWS - NO SYMMETRY OPTION IN TRFOPT COMMON
C 21 DEC 99 - MWS - MOVE LABSIZ INIT FROM DEBUT TO INTIN
C 13 MAR 99 - KRG - INTIN: USE OF DFT FORCES NOPK SETTING
C  9 JAN 99 - MWS - QOUT: ADD TO SAVE TO WORK AROUND XLF V5 PROBLEM
C 12 NOV 98 - GDF - CHANGE BIT PACKING TO ISHIFT
C 27 SEP 98 - OS,MWS - JANDK: SET DSKWRK BEFORE DEBUT CALL
C  6 MAY 98 - MWS - DEBUT: HALVE CUTOFF IF FOCK DIFFERENCING,
C                   INTIN: BY DEFAULT EVEN SCF NEVER CREATES SUPERMATRIX
C 27 FEB 98 - MWS - INTIN: AVOID SUPERMATRIX FOR ANY TYPE CI
C 28 SEP 97 - MWS - CONVERT PARALLEL CALLS FROM TCGMSG TO DDI
C 18 DEC 96 - TLW - TWOEI: PASS NFLMAT THROUGH TO DIRECT FOCK BUILDER
C 29 SEP 96 - GDF - DEBUT,PKFILE,ZPKOUT,SHELLS: INDEX BASED ON LMAX
C 13 JUN 96 - VAG - ADD VARIABLE FOR CI TYPE TO SCFOPT COMMON
C  5 MAR 96 - MWS - CHANGE SHELL SYMMETRY PACKING COMMONS
C 29 JAN 96 - MWS - JANDK: WRITE ZERO K INTS DURING CHECK RUNS
C  9 JAN 96 - WC  - INTIN,QOUT: GENERATE ONE INTEGRAL FILE FOR MOROKUMA
C 14 SEP 95 - SPW - INTIN: SET NOPK TO 1 FOR ABELIAN POLAR. DECOMP.
C 11 AUG 95 - XL  - INTIN,TWOEI: SCREENED INTEGRAL CHANGES
C 21 APR 95 - MWS - USE CORRECT NAME FOR EXCHANGE INTEGRAL SCREENING
C 28 MAR 95 - MWS - PKFILE,QOUT: SAVE ADDED FOR AIX COMPILER
C  5 MAR 95 - MWS - TWOEI: CHANGE SCHARZ SCREENING FOR DIRFCK
C  1 FEB 95 - WC  - FINAL,INTIN,QOUT: DUPLICATE J INT FILE FOR MOROKUMA
C 12 NOV 94 - MWS - REMOVE FTNCHEK WARNINGS
C 25 OCT 94 - MWS - INTIN: RAISE NINTMX DEFAULT FROM 1725 TO 15000
C 10 AUG 94 - MWS - INCREASE NUMBER OF DAF RECORDS
C  5 AUG 94 - MWS - USE DOUBLE LABEL PACKING
C 15 JUL 94 - BMB - DEBUT: CHANGE DAREAD TO CALL GAMGEN
C  1 JUN 94 - MWS - INTIN: MCSCF/CI RUNS DON'T OPEN ORDINT FILE
C 30 MAR 94 - MWS - DEBUT,TWOEI: DIRECT TRANSFORMATION CHANGES
C  6 JAN 94 - MWS - EXCHNG: STORE EXCHANGE INTEGRALS ON DAF
C 13 DEC 93 - NM  - TWOEI: ADD CALLS FOR DIRECT INTEGRAL TRANSFORMATION
C  5 JUN 92 - TLW - INTIN,JANDK: DISK BASED METHOD PARALLELIZED
C                   EXCHNG: PARALLELIZED
C 18 MAY 92 - MWS - DEBUT: BOMB JOB IF PARALLEL BUT NOT DIRECT SCF
C 12 MAR 92 - MWS - REDIMENSION TO 500 ATOMS
C 21 FEB 92 - TLW - TWOEI: PARALLELIZE
C 10 FEB 92 - JHJ - JANDK: IF MPC WFN RETURN.
C 11 JAN 92 - TLW - DEBUT: MAKE READS PARALLEL
C 10 JAN 92 - TLW - CHANGE REWIND TO CALL SEQREW
C 10 JAN 92 - MWS,TLW - CHANGE OPENIS AND OPENPK TO SEQOPN
C  7 JAN 92 - TLW - MAKE WRITES PARALLEL; ADD COMMON PAR
C 11 OCT 91 - MWS - DIRECT SCF CHANGES TO DEBUT,FINAL,JANDK,TWOEI,
C                   ADDED ROUTINES BASCHK,INTIN,SCHWDN,ZPKOUT,ZQOUT,
C                   SEVERAL POPLE INTEGRAL ROUTINES MOVED TO INT2B.
C 12 AUG 91 - TLW - PUT IN F AND G FUNCTIONS
C 29 APR 91 - MWS - PKFILE USES FULL 16 BIT PACKING ON 32 BIT MACHINES
C  2 NOV 90 - MWS - RENAME /INDEX/ TO /INTDEX/
C  7 AUG 90 - TLW - ADD CF AND CG TO COMMON NSHEL
C  3 JUN 90 - JAM - CHANGE VAX BYTE PACKING TO FULL 8 BITS
C 29 NOV 89 - MWS - ADD NECP TO /INTOPT/
C 24 OCT 89 - MWS - CHANGE BUFFER ALLOCATION TO DELETE /BUF/,
C                   SOUP UP PKFILE SOMEWHAT
C 18 JAN 89 - MWS - RENAME /IJPAIR/ TO /IJGNRL/
C 17 NOV 88 - MWS - IMPLEMENT MICHEL'S SCHWARZ INEQUALITY SCREENING
C 10 AUG 88 - MWS - MXSH,MXGSH,MXGTOT FROM 120,10,440 TO 1000,30,5000
C 22 MAY 88 - MWS - PASS GOUT TO TQ0111 VIA CALL,
C                   INCREASE ACCURACY OF SP INTEGRALS IN FILMAX
C 17 MAY 88 - MWS - SPD BASES NOW USE POPLE CODE FOR SP INTEGRALS,
C                   QOUT AND QOUT70 COMBINED INTO QOUT,
C                   PKFILE AND PKFI70 COMBINED INTO PKFILE,
C                   HONINT, JKIN70, PKIN70 COMBINED INTO TWOEI,
C                   S0000 AND QOUT CALLED FROM TWOEI,
C                   PARAMETERS USED TO DIMENSION COMMONS,
C                   GENERAL PRETTIFICATION
C  8 MAY 88 - MWS - DEBUT CHECKS 32 BIT MACHINES FOR OVER 255 AO-S
C 14 FEB 88 - MWS - INCREASE /ROOT/ TO 9 ROOTS
C 15 NOV 87 - STE - USE EXETYP; DON'T PRINT BLOCK TIMES
C  7 AUG 87 - MWS - INCLUDE ETA VERSION
C 19 JUL 87 - MWS - RENAME NOCORE VARIABLE TO NOMEM
C 13 OCT 86 - JAB - REMOVE EXTRANEOUS ARGUMENTS FROM ADVFIL CALLS
C 11 JUL 86 - MWS - PACKING FOR CELERITY AND CRAY VERSIONS
C  7 JUL 86 - MWS - SANITIZE FLOATING POINT CONSTANTS
C  8 NOV 85 - STE - JANDK: RETURN BUFFERS BEFORE ORDRJK
C 22 OCT 85 - STE - FINAL:/NSHEL/ MISSING; LGENR70: CHANGE INT2B CALLS
C                   USE GENERIC ABS,ATAN,EXP,MIN,MAX,SQRT
C 11 JUL 85 - MWS - CHANGE IBM INDEX PACKING
C 20 JAN 84 - STE - MOVE 2-E TIME FROM HONINT,JKIN70,PKIN70 TO JANDK
C  4 JAN 84 - STE - DELETE /CONST/,/SHLNOS/,/LT/,/MISCG/,/H/,/PGEOM/
C                   /COS/,/B/,/AUXVAR/,/TABLE/,/IOFILE/,/PICON/
C                   IN GENR70; /NSHEL/,/SHLNOS/ IN FINAL; ALL /IJLAB/
C 19 DEC 83 - STE - MOVE $INTGRL TO START, CHANGE /BUF/
C  2 DEC 83 - STE - INITIALIZE IST,JST...INTLOC IN DEBUT
C 17 NOV 83 - STE - FPS PACKING IN PKFI70,PKFILE,QOUT,QOUT70
C  4 NOV 83 - STE - REMOVE CALLS TO INITPK,INITPN,EXITPK,EXITPN
C 17 AUG 83 - MWS - LESS OUTPUT FROM JKIN70
C 24 MAY 83 - MWS - LESS OUTPUT FROM PKIN70
C 21 OCT 82 - MWS - ADD DMY ARGUMENTS TO NAMEIO CALL
C  8 OCT 82 - MWS - CONVERT TO IBM
C
C*MODULE INT2A   *DECK BASCHK
      SUBROUTINE BASCHK(LMAX)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXSH=1000, MXGTOT=5000)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
C     RETURN THE HIGHEST ANGULAR MOMENTUM PRESENT IN THE BASIS.
C     NOTE THAT KTYPE=1,2,3,4,5 MEANS S, P(L), D, F, G FUNCTION.
C
      KANG = 0
      DO 100 N=1,NSHELL
          IF(KTYPE(N).GT.KANG) KANG = KTYPE(N)
  100 CONTINUE
      LMAX = KANG-1
      RETURN
      END
C*MODULE INT2A   *DECK EXCHNG
      SUBROUTINE EXCHNG(XINTS,GHONDO,DDIJ,NSH2,MAXG,INTG76)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION XINTS(NSH2),GHONDO(MAXG),DDIJ(*)
      DIMENSION IBPOP(4,4)
C
      LOGICAL POPLE,OUT,SOME,IANDJ,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXSH=1000, MXGTOT=5000)
C
      COMMON /FLIPS / IB(4,3)
      COMMON /GOUT  / GPOPLE(768),NORG
      COMMON /INTDEX/ IJGT(225),IJX(225),IJY(225),IJZ(225),IK(225),
     *                KLGT(225),KLX(225),KLY(225),KLZ(225)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SHLG70/ ISH,JSH,KSH,LSH,IJKLXX(4)
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     *                NIJ,IJ,KL,IJKL
      COMMON /SHLT  / TOL,CUTOFF,ICOUNT,OUT
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      DATA IBPOP/0,0,0,0,64,16,4,1,128,32,8,2,192,48,12,3/
C
C     ----- INTIALIZE PARALLEL -----
C
      IPCOUNT = ME - 1
      IF (GOPARR) CALL VCLR(XINTS,1,NSH2)
C
C     ----- COMPUTE ALL EXCHANGE INTEGRALS [II,JJ/II,JJ] -----
C     THE LARGEST EXCHANGE INTEGRAL FROM EACH INTEGRAL BLOCK
C     IS PICKED OUT AND SAVED, SO THAT THE SCHWARZ INEQUALITY
C     CAN BE USED LATER TO AVOID ENTIRE INTEGRAL BLOCKS.
C
      SOME = NPRINT.NE.-5 .AND. MASWRK
      TIM = ZERO
      CALL TSECND(TIM)
      TIM0 = TIM
C
      TOLSV = TOL
      TOL = 75.0D+00
C
      IEXCH = 1
      NORG  = 0
      QQ4   = ONE
      NINT  = 0
C
C     ----- LOOP OVER ALL SHELL BLOCKS -----
C
      IJIJ = 0
      DO 600 ISH = 1,NSHELL
      DO 500 JSH = 1,ISH
      IJIJ = IJIJ+1
C
C     ----- GO PARALLEL! -----
C
      IF (GOPARR) THEN
         IPCOUNT = IPCOUNT + 1
         IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 400
      END IF
C
C     USE POPLE CODE FOR ANY PURE SP INTEGRAL BLOCKS,
C     USE HONDO RYS POLYNOMIAL CODE FOR OTHER BLOCKS
C
      POPLE=.TRUE.
      IF(INTG76.EQ.0) POPLE=.FALSE.
      IF(KTYPE(ISH).GT.2) POPLE=.FALSE.
      IF(KTYPE(JSH).GT.2) POPLE=.FALSE.
C
      IF(POPLE) THEN
         KSH=ISH
         LSH=JSH
         CALL GENR70(IEXCH,.FALSE.)
      ELSE
         CALL SHELLS(1,ISH,JSH,ISH,JSH,.TRUE.)
         CALL IJPRIM(DDIJ)
         CALL SHELLS(2,ISH,JSH,ISH,JSH,.TRUE.)
         CALL ZQOUT(GHONDO)
         IF(IJKL.EQ.1) CALL S0000(GHONDO,DDIJ)
         IF(IJKL.GT.1) CALL GENRAL(GHONDO,DDIJ)
      END IF
C
C     ----- PICK OUT LARGEST EXCHANGE INTEGRAL FOR THIS BLOCK -----
C
      VMAX = ZERO
      MINI = KMIN(ISH)
      MINJ = KMIN(JSH)
      MAXI = KMAX(ISH)
      JMAX = KMAX(JSH)
      IANDJ=ISH.EQ.JSH
      IBB = IB(1,IEXCH)
      JBB = IB(2,IEXCH)
      KBB = IB(3,IEXCH)
      LBB = IB(4,IEXCH)
      IJN = 0
      DO 300 I=MINI,MAXI
         IF(IANDJ) JMAX = I
         DO 200 J=MINJ,JMAX
            IF(POPLE) THEN
               NN = IBPOP(IBB,I) + IBPOP(JBB,J)
     *            + IBPOP(KBB,I) + IBPOP(LBB,J) + 1
               VAL = GPOPLE(NN)
            ELSE
               IJN = IJN+1
               NN = IJGT(IJN) + KLGT(IJN)
               VAL = GHONDO(NN)
            END IF
            IF(VAL.GT.ZERO) NINT=NINT+1
            IF(VAL.GT.VMAX) VMAX=VAL
  200    CONTINUE
  300 CONTINUE
      XINTS(IJIJ)=VMAX
C
C     ----- END PARALLEL
C
  400 CONTINUE
C
  500 CONTINUE
  600 CONTINUE
C
C     ----- SUM UP PARTIAL CONTRIBUTIONS IF PARALLEL -----
C
      IF (GOPARR) THEN
         CALL DDI_GSUMF(1050,XINTS,NSH2)
         CALL DDI_GSUMI(1051,NINT ,1)
      END IF
C
      IF(OUT) THEN
         WRITE(IW,*) 'MAX EXCHANGE INTEGRAL IN SHELL'
         CALL PRTRI(XINTS,NSHELL)
      END IF
C
      DO 700 I=1,NSH2
         XINTS(I) = SQRT(XINTS(I))
  700 CONTINUE
C
      CALL TSECND(TIM)
      TEXCH = TIM-TIM0
      IF(SOME) WRITE(IW,9000) NINT,TEXCH
C
      TOL = TOLSV
      CALL DAWRIT(IDAF,IODA,XINTS,NSH2,54,0)
      RETURN
 9000 FORMAT(1X,'SCHWARZ INEQUALITY OVERHEAD:',I10,' INTEGRALS, T=',
     *       F12.2)
      END
C*MODULE INT2A   *DECK DEBUT
      SUBROUTINE DEBUT(INTG76,DIRSCF,BUFP,BUFK,IX,NINTMX,NEED,DIRTRF)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL DIRSCF,DIRTRF
      LOGICAL DIR,GOPARR,DSKWRK,MASWRK,PK,PANDK,BLOCK,OUT
C
      DIMENSION BUFP(NINTMX),BUFK(NINTMX),IX(*)
C
      PARAMETER (MXSH=1000, MXGTOT=5000,  MXATM=500, MXAO=2047)
C
      COMMON /B     / CO(MXSH,3)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /INTPR / QINT(3),VALINT(3),JCINT(16)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     2                CF(MXGTOT),CG(MXGTOT),
     3                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     4                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
      COMMON /PKFIL / PK,PANDK,BLOCK
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SHLT  / TOL,CUTOFF,ICOUNT,OUT
C
      PARAMETER (ONE=1.0D+00, TEN=10.D+00, RLN10=2.30258D+00)
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA CHECK/8HCHECK   /
#else
      CHARACTER*8 :: CHECK_STR
      EQUIVALENCE (CHECK, CHECK_STR)
      DATA CHECK_STR/"CHECK   "/
#endif
C
C     ----- INITIALIZE TWO ELECTRON INTEGRAL CALCULATION -----
C
      TOL= ITOL*RLN10
      CUTOFF= ONE/(TEN**ICUT)
      DIR= DIRSCF .OR. DIRTRF
C
      DO 100 I=1,NUM
         IA(I)=(I*I-I)/2
  100 CONTINUE
C
C     ----- READ ERROR FUNCTION INTERPOLATION TABLE -----
C
      IF(INTG76.EQ.1 .AND. EXETYP.NE.CHECK) CALL GAMGEN(2)
C
      IF((NPRINT.NE.-5) .AND. MASWRK) THEN
         IF(DIR) THEN
            IF(DIRSCF) WRITE(IW,9000)
            IF(DIRSCF) WRITE(IW,9040)
            IF(DIRTRF) WRITE(IW,9045)
         ELSE
            WRITE(IW,9000)
            IF(PK) THEN
               IF(     PANDK .AND. NPRINT.NE.-5) WRITE(IW,9010)
               IF(.NOT.PANDK) WRITE(IW,9020)
            ELSE
               WRITE(IW,9030)
            END IF
            NBYTES = 8 + (LABSIZ*8)/NWDVAR
            IF(PANDK) NBYTES = NBYTES+8
            WRITE(IW,9050) NINTMX,NBYTES
            WRITE(IW,9060) NEED
         END IF
      END IF
C
      OUT = NPRINT.EQ.4 .AND. MASWRK
      JCINT(1) = 0
C
      DO 200 I=1,NSHELL
         ICC = KATOM(I)
         CO(I,1)= C(1,ICC)
         CO(I,2)= C(2,ICC)
         CO(I,3)= C(3,ICC)
  200 CONTINUE
C
      IF(DIRSCF .OR. DIRTRF .OR. EXETYP.EQ.CHECK) GO TO 400
C
      CALL SEQREW(IS)
C
      IF(IREST.LT.1 .OR. NREC.LE.1 .OR. INTLOC.LE.1) GO TO 400
  300 CONTINUE
C
C     ----- POSITION THE INTEGRAL FILE FOR A RESTART JOB -----
C
      ICOUNT = INTLOC
      N = NREC-1
      IF(MASWRK) THEN
         DO 310 I=1,N
            READ(IS)
  310    CONTINUE
      END IF
      IF(.NOT.PANDK) CALL PREAD (IS,BUFP,IX,NXX,NINTMX)
      IF(     PANDK) CALL PKREAD(IS,BUFP,BUFK,IX,NXX,NINTMX)
      CALL SEQREW(IS)
      IF(MASWRK) THEN
         DO 320 I=1,N
            READ(IS)
  320    CONTINUE
      END IF
      GO TO 999
  400 CONTINUE
C
C     ----- NORMAL START -----
C
      IF(IST.LT.1) IST = 1
      IF(JST.LT.1) JST = 1
      IF(KST.LT.1) KST = 1
      IF(LST.LT.1) LST = 1
      IF(IST.GT.NSHELL) GO TO 999
      IF(IST.NE.1 .OR. JST.NE.1 .OR. KST.NE.1 .OR. LST.NE.1) GO TO 300
      NREC   = 1
      INTLOC = 1
      ICOUNT = 1
  999 CONTINUE
      RETURN
 9000 FORMAT(/10X,20("-")/10X,'2 ELECTRON INTEGRALS'/10X,20("-")/)
 9010 FORMAT(' THE -PK- OPTION IS ON, CREATING -P- AND -K-',
     *       ' SUPERMATRICES.')
 9020 FORMAT(' THE -PK- OPTION IS ON, CREATING A -P- SUPERMATRIX.')
 9030 FORMAT(' THE -PK- OPTION IS OFF, THE INTEGRALS ARE NOT IN',
     *       ' SUPERMATRIX FORM.')
 9040 FORMAT(' DIRECT SCF METHOD SKIPS INTEGRAL STORAGE ON DISK.')
 9045 FORMAT(' DIRECT TRANSFORMATION SKIPS AO INTEGRAL STORAGE',
     *       ' ON DISK.')
 9050 FORMAT(' STORING',I8,' INTEGRALS/RECORD ON DISK, USING',I3,
     *       ' BYTES/INTEGRAL.')
 9060 FORMAT(' TWO ELECTRON INTEGRAL EVALUATION REQUIRES',I8,
     *       ' WORDS OF MEMORY.')
      END
C*MODULE INT2A   *DECK FINAL
      SUBROUTINE FINAL(INDEX,II,JJ,KK,LL,PANDK,BUFP,BUFK,IX,NINTMX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL PANDK,OUT,GOPARR,DSKWRK,MASWRK
C
      DIMENSION BUFP(NINTMX),BUFK(NINTMX),IX(*)
C
      PARAMETER (MXSH=1000, MXGTOT=5000)
C
      COMMON /INTPR / Q(3),V(3),JC,N1(3),J1(3),J2(3),J3(3),J4(3)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /SHLT  / TOL,CUTOFF,ICOUNT,OUT
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
C
      IF(OUT .AND. JC.GT.0)
     * WRITE(IW,9000) (J1(M),J2(M),J3(M),J4(M),Q(M),N1(M),V(M),M=1,JC)
C
      IF (INDEX.EQ.1) GO TO 140
C
C         RAN OUT OF TIME, FLUSH PARTIAL BUFFER, PRINT RESTART DATA
C
      IREST = 1
      IST = II
      JST = JJ
      KST = KK
      LST = LL+1
      IF(LST.LE.KK) GO TO 120
      LST = 1
      KST = KK+1
      IF(KST.LE.JJ) GO TO 120
      KST = 1
      JST = JJ+1
      IF(JST.LE.II) GO TO 120
      JST = 1
      IST = II+1
      IF(IST.GT.NSHELL) GO TO 140
C
  120 CONTINUE
      NXX = ICOUNT-1
      IF(.NOT.PANDK) CALL PWRIT (IS,BUFP,IX,NXX,NINTMX)
      IF(     PANDK) CALL PKWRIT(IS,BUFP,BUFK,IX,NXX,NINTMX)
      NINT = NINTMX*(NREC-1)+ICOUNT-1
      IF (MASWRK) THEN
         WRITE(IW,9010) NINT,NREC,IS
         WRITE(IW,9020) NREC,ICOUNT,IST,JST,KST,LST
      END IF
      RETURN
C
C        DONE WITH INTEGRALS, WRITE LAST BUFFER, PRINT STATISTICS
C
  140 CONTINUE
      IREST = 0
      IST = 1
      JST = 1
      KST = 1
      LST = 1
      NXX = ICOUNT-1
      NXX = -NXX
      IF(.NOT.PANDK) CALL PWRIT (IS,BUFP,IX,NXX,NINTMX)
      IF(     PANDK) CALL PKWRIT(IS,BUFP,BUFK,IX,NXX,NINTMX)
      NINT = NINTMX*(NREC-1)+ICOUNT-1
      IF (GOPARR) THEN
         CALL DDI_GSUMI(1056,NINT,1)
         CALL DDI_GSUMI(1057,NREC,1)
      END IF
      IF (MASWRK .AND. NPRTGO.NE.2) WRITE(IW,9010) NINT,NREC,IS
      RETURN
C
 9000 FORMAT(3(4I3,F6.3,I5,E20.12))
 9010 FORMAT(1X,'TOTAL NUMBER OF NONZERO TWO-ELECTRON INTEGRALS =',I20/
     *       1X,I10,' INTEGRAL RECORDS WERE STORED ON DISK FILE',I3,'.')
 9020 FORMAT(/1X,'...... WARNING   .......   WARNING   .......'/
     *        1X,'TIME LIMIT HAS EXPIRED.  THIS JOB MUST BE RESTARTED.'/
     *        1X,'IF YOU SAVED THE INTEGRALS, RESTART WITH IREST=1,'/
     *        1X,'NREC=',I8,' INTLOC=',I6,' IST,JST,KST,LST=',4I6)
      END
C*MODULE INT2A   *DECK FORMS
      SUBROUTINE FORMS(GHONDO)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION GHONDO(*)
C
      COMMON /DENS  / DKL(225),DIJ(225)
      COMMON /INTDEX/ IJGT(225),IJX(225),IJY(225),IJZ(225),IK(225),
     *                KLGT(225),KLX(225),KLY(225),KLZ(225)
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     *                NIJ,IJ,KL,IJKL
      COMMON /ROOT  / XX,U(9),W(9),NROOTS
      COMMON /XYZ   / XIN(5625),YIN(5625),ZIN(5625)
C
C     ----- FORM INTEGRALS OVER FUNCTIONS -----
C     DIMENSIONING XIN(81,5), AND ROLLING UP THE COMPUTATION
C     OF GHONDO IN A LOOP OF LENGTH NROOTS ADDS 33 SECONDS TO
C     A 240 SECOND INTEGRAL COMPUTATION JOB.  LEAVE IT UNROLLED.
C
      GO TO (100,140,180,220,260,300,340,380,420),NROOTS
C
  100 DO 120 I = 1,IJ
      D1 = DIJ(I)
      NX = IJX(I)
      NY = IJY(I)
      NZ = IJZ(I)
      N1 = IJGT(I)
      MAX = IK(I)
      DO 120 K = 1,MAX
      MX = NX+KLX(K)
      MY = NY+KLY(K)
      MZ = NZ+KLZ(K)
      N = N1+KLGT(K)
  120 GHONDO(N) = ( XIN(MX )*YIN(MY )*ZIN(MZ ) )*D1*DKL(K)+GHONDO(N)
      RETURN
C
  140 DO 160 I = 1,IJ
      D1 = DIJ(I)
      NX = IJX(I)
      NY = IJY(I)
      NZ = IJZ(I)
      N1 = IJGT(I)
      MAX = IK(I)
      DO 160 K = 1,MAX
      MX = NX+KLX(K)
      MY = NY+KLY(K)
      MZ = NZ+KLZ(K)
      N = N1+KLGT(K)
  160 GHONDO(N) = ( XIN(MX )*YIN(MY )*ZIN(MZ ) +XIN(MX+625)*YIN(MY+625)*
     +     ZIN(MZ+625) )*D1*DKL(K)+GHONDO(N)
      RETURN
C
  180 DO 200 I = 1,IJ
      D1 = DIJ(I)
      NX = IJX(I)
      NY = IJY(I)
      NZ = IJZ(I)
      N1 = IJGT(I)
      MAX = IK(I)
      DO 200 K = 1,MAX
      MX = NX+KLX(K)
      MY = NY+KLY(K)
      MZ = NZ+KLZ(K)
      N = N1+KLGT(K)
  200 GHONDO(N) = ( XIN(MX )*YIN(MY )*ZIN(MZ ) +XIN(MX+625)*YIN(MY+625)*
     +     ZIN(MZ+625) +XIN(MX+1250)*YIN(MY+1250)*ZIN(MZ+1250) )*D1*
     +     DKL(K)+GHONDO(N)
      RETURN
C
  220 DO 240 I = 1,IJ
      D1 = DIJ(I)
      NX = IJX(I)
      NY = IJY(I)
      NZ = IJZ(I)
      N1 = IJGT(I)
      MAX = IK(I)
      DO 240 K = 1,MAX
      MX = NX+KLX(K)
      MY = NY+KLY(K)
      MZ = NZ+KLZ(K)
      N = N1+KLGT(K)
  240 GHONDO(N) = ( XIN(MX )*YIN(MY )*ZIN(MZ ) +XIN(MX+625)*YIN(MY+625)*
     +     ZIN(MZ+625) +XIN(MX+1250)*YIN(MY+1250)*ZIN(MZ+1250) +XIN(MX+
     +     1875)*YIN(MY+1875)*ZIN(MZ+1875) )*D1*DKL(K)+GHONDO(N)
      RETURN
C
  260 DO 280 I = 1,IJ
      D1 = DIJ(I)
      NX = IJX(I)
      NY = IJY(I)
      NZ = IJZ(I)
      N1 = IJGT(I)
      MAX = IK(I)
      DO 280 K = 1,MAX
      MX = NX+KLX(K)
      MY = NY+KLY(K)
      MZ = NZ+KLZ(K)
      N = N1+KLGT(K)
  280 GHONDO(N) = ( XIN(MX )*YIN(MY )*ZIN(MZ ) +XIN(MX+625)*YIN(MY+625)*
     +     ZIN(MZ+625) +XIN(MX+1250)*YIN(MY+1250)*ZIN(MZ+1250) +XIN(MX+
     +     1875)*YIN(MY+1875)*ZIN(MZ+1875) +XIN(MX+2500)*YIN(MY+2500)*
     +     ZIN(MZ+2500) )*D1*DKL(K)+GHONDO(N)
      RETURN
C
  300 DO 320 I = 1,IJ
      D1 = DIJ(I)
      NX = IJX(I)
      NY = IJY(I)
      NZ = IJZ(I)
      N1 = IJGT(I)
      MAX = IK(I)
      DO 320 K = 1,MAX
      MX = NX+KLX(K)
      MY = NY+KLY(K)
      MZ = NZ+KLZ(K)
      N = N1+KLGT(K)
  320 GHONDO(N) = ( XIN(MX )*YIN(MY )*ZIN(MZ ) +XIN(MX+625)*YIN(MY+625)*
     +     ZIN(MZ+625) +XIN(MX+1250)*YIN(MY+1250)*ZIN(MZ+1250) +XIN(MX+
     +     1875)*YIN(MY+1875)*ZIN(MZ+1875) +XIN(MX+2500)*YIN(MY+2500)*
     +     ZIN(MZ+2500) +XIN(MX+3125)*YIN(MY+3125)*ZIN(MZ+3125))
     +     *D1*DKL(K)+GHONDO(N)
      RETURN
C
  340 DO 360 I = 1,IJ
      D1 = DIJ(I)
      NX = IJX(I)
      NY = IJY(I)
      NZ = IJZ(I)
      N1 = IJGT(I)
      MAX = IK(I)
      DO 360 K = 1,MAX
      MX = NX+KLX(K)
      MY = NY+KLY(K)
      MZ = NZ+KLZ(K)
      N = N1+KLGT(K)
  360 GHONDO(N) = ( XIN(MX )*YIN(MY )*ZIN(MZ ) +XIN(MX+625)*YIN(MY+625)*
     +     ZIN(MZ+625) +XIN(MX+1250)*YIN(MY+1250)*ZIN(MZ+1250) +XIN(MX+
     +     1875)*YIN(MY+1875)*ZIN(MZ+1875) +XIN(MX+2500)*YIN(MY+2500)*
     +     ZIN(MZ+2500) +XIN(MX+3125)*YIN(MY+3125)*ZIN(MZ+3125) +XIN(MX+
     +     3750)*YIN(MY+3750)*ZIN(MZ+3750))
     +     *D1*DKL(K)+GHONDO(N)
      RETURN
C
  380 DO 400 I = 1,IJ
      D1 = DIJ(I)
      NX = IJX(I)
      NY = IJY(I)
      NZ = IJZ(I)
      N1 = IJGT(I)
      MAX = IK(I)
      DO 400 K = 1,MAX
      MX = NX+KLX(K)
      MY = NY+KLY(K)
      MZ = NZ+KLZ(K)
      N = N1+KLGT(K)
  400 GHONDO(N) = ( XIN(MX )*YIN(MY )*ZIN(MZ ) +XIN(MX+625)*YIN(MY+625)*
     +     ZIN(MZ+625) +XIN(MX+1250)*YIN(MY+1250)*ZIN(MZ+1250) +XIN(MX+
     +     1875)*YIN(MY+1875)*ZIN(MZ+1875) +XIN(MX+2500)*YIN(MY+2500)*
     +     ZIN(MZ+2500) +XIN(MX+3125)*YIN(MY+3125)*ZIN(MZ+3125) +XIN(MX+
     +     3750)*YIN(MY+3750)*ZIN(MZ+3750) +XIN(MX+4375)*YIN(MY+4375)*
     +     ZIN(MZ+4375))*D1*DKL(K)+GHONDO(N)
      RETURN
C
  420 DO 440 I = 1,IJ
      D1 = DIJ(I)
      NX = IJX(I)
      NY = IJY(I)
      NZ = IJZ(I)
      N1 = IJGT(I)
      MAX = IK(I)
      DO 440 K = 1,MAX
      MX = NX+KLX(K)
      MY = NY+KLY(K)
      MZ = NZ+KLZ(K)
      N = N1+KLGT(K)
  440 GHONDO(N) = ( XIN(MX )*YIN(MY )*ZIN(MZ ) +XIN(MX+625)*YIN(MY+625)*
     +     ZIN(MZ+625) +XIN(MX+1250)*YIN(MY+1250)*ZIN(MZ+1250) +XIN(MX+
     +     1875)*YIN(MY+1875)*ZIN(MZ+1875) +XIN(MX+2500)*YIN(MY+2500)*
     +     ZIN(MZ+2500) +XIN(MX+3125)*YIN(MY+3125)*ZIN(MZ+3125) +XIN(MX+
     +     3750)*YIN(MY+3750)*ZIN(MZ+3750) +XIN(MX+4375)*YIN(MY+4375)*
     +     ZIN(MZ+4375) +XIN(MX+5000)*YIN(MY+5000)*ZIN(MZ+5000))
     +     *D1*DKL(K)+GHONDO(N)
      RETURN
      END
C*MODULE INT2A   *DECK GENRAL
      SUBROUTINE GENRAL(GHONDO,DDIJ)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION GHONDO(*),DDIJ(*)
C
      LOGICAL IANDJ,KANDL,SAME,OUT,NORM,DOUBLE
C
      PARAMETER (MXGSH=30, MXG2=MXGSH*MXGSH)
C
      COMMON /DENS  / DKL(225),DIJ(225)
      COMMON /IJGNRL/ AA(MXG2),R(MXG2),X1(MXG2),Y1(MXG2),Z1(MXG2),
     *                IJD(225)
      COMMON /MISC  / IANDJ,KANDL,SAME
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /ROOT  / XX,U(9),W(9),NROOTS
      COMMON /SETINT/ IN(9),KN(9),NI,NJ,NK,NL,NMAX,MMAX,
     +                BP01,B00,B10,XCP00,XC00,YCP00,YC00,ZCP00,ZC00,F00,
     +                DXIJ,DYIJ,DZIJ,DXKL,DYKL,DZKL
      COMMON /SHLINF/ AG(MXGSH),CSA(MXGSH),CPA(MXGSH),CDA(MXGSH),
     *                CFA(MXGSH),CGA(MXGSH),
     *                BG(MXGSH),CSB(MXGSH),CPB(MXGSH),CDB(MXGSH),
     *                CFB(MXGSH),CGB(MXGSH),
     *                CG(MXGSH),CSC(MXGSH),CPC(MXGSH),CDC(MXGSH),
     *                CFC(MXGSH),CGC(MXGSH),
     *                DG(MXGSH),CSD(MXGSH),CPD(MXGSH),CDD(MXGSH),
     *                CFD(MXGSH),CGD(MXGSH),
     *                XI,YI,ZI,XJ,YJ,ZJ,RRI,XK,YK,ZK,XL,YL,ZL,RRK,
     *                NGA,NGB,NGC,NGD
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     +                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     +                NIJ,IJ,KL,IJKL
      COMMON /SHLT  / TOL,CUTOFF,ICOUNT,OUT
C
      DIMENSION IN1(9)
C
      PARAMETER (SQRT3=1.73205080756888D+00, SQRT5=2.23606797749979D+00,
     *           SQRT7=2.64575131106459D+00, PI252=34.986836655250D+00,
     *           ZERO=0.0D+00, HALF=0.5D+00, ONE=1.0D+00)
C
C     GENERAL INTEGRAL ROUTINE FOR SPD FUNCTIONS
C
      FACTOR = PI252*QQ4
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
      NI = LIT-1
      NJ = LJT-1
      NK = LKT-1
      NL = LLT-1
      DXIJ = XI-XJ
      DYIJ = YI-YJ
      DZIJ = ZI-ZJ
      DXKL = XK-XL
      DYKL = YK-YL
      DZKL = ZK-ZL
      NMAX = NI+NJ
      MMAX = NK+NL
      MAX = NMAX+1
      DO 100 I = 1,MAX
         N = I-1
         IF (N .LE. NI) IN1(I) = 125*N+1
         IF (N .GT. NI) IN1(I) = 125*NI+25*(N-NI)+1
  100 CONTINUE
      MAX = MMAX+1
      DO 120 K = 1,MAX
         N = K-1
         IF (N .LE. NK) KN(K) = 5*N
         IF (N .GT. NK) KN(K) = 5*NK+N-NK
  120 CONTINUE
C
C     ----- K PRIMITIVE
C
      LGMAX = NGD
      DO 480 KG = 1,NGC
         AK = CG(KG)
         BRRK = AK*RRK
         AKXK = AK*XK
         AKYK = AK*YK
         AKZK = AK*ZK
         CSK = CSC(KG)*FACTOR
         CPK = CPC(KG)*FACTOR
         CDK = CDC(KG)*FACTOR
         CFK = CFC(KG)*FACTOR
         CGK = CGC(KG)*FACTOR
C
C        ----- L PRIMITIVE
C
         IF (KANDL) LGMAX = KG
         DO 460 LG = 1,LGMAX
            AL = DG(LG)
            B = AK+AL
            BINV = ONE/B
            BBRRK = AL*BRRK*BINV
            IF (BBRRK .GT. TOL) GO TO 460
            CSL = CSD(LG)
            CPL = CPD(LG)
            CDL = CDD(LG)
            CFL = CFD(LG)
            CGL = CGD(LG)
            XB = (AKXK+AL*XL)*BINV
            YB = (AKYK+AL*YL)*BINV
            ZB = (AKZK+AL*ZL)*BINV
            BXBK = B*(XB-XK)
            BYBK = B*(YB-YK)
            BZBK = B*(ZB-ZK)
            BXBI = B*(XB-XI)
            BYBI = B*(YB-YI)
            BZBI = B*(ZB-ZI)
C
C           ----- DENSITY FACTOR
C
            DOUBLE=KANDL.AND.KG.NE.LG
            N = 0
            MAX = MAXL
            DUM1 = ZERO
            DUM2 = ZERO
            DO 370 K = MINK,MAXK
               GO TO (140,160,220,220,180,220,220,200,220,220,
     1                201,220,220,202,220,220,220,220,220,203,
     1                204,220,220,205,220,220,220,220,220,206,
     1                220,220,207,220,220),K
  140          DUM1 = CSK*BINV
               GO TO 220
  160          DUM1 = CPK*BINV
               GO TO 220
  180          DUM1 = CDK*BINV
               GO TO 220
  200          IF (NORM) DUM1 = DUM1*SQRT3
               GO TO 220
  201          DUM1 = CFK*BINV
               GO TO 220
  202          IF (NORM) DUM1 = DUM1*SQRT5
               GO TO 220
  203          IF (NORM) DUM1 = DUM1*SQRT3
               GO TO 220
  204          DUM1 = CGK*BINV
               GO TO 220
  205          IF (NORM) DUM1 = DUM1*SQRT7
               GO TO 220
  206          IF (NORM) DUM1 = DUM1*SQRT5/SQRT3
               GO TO 220
  207          IF (NORM) DUM1 = DUM1*SQRT3
  220          IF (KANDL) MAX = K
               DO 360 L = MINL,MAX
                  GO TO (240,280,340,340,300,340,340,320,340,340,
     1                   321,340,340,322,340,340,340,340,340,323,
     1                   324,340,340,325,340,340,340,340,340,326,
     1                   340,340,327,340,340),L
  240             DUM2 = DUM1*CSL
                  IF ( .NOT. DOUBLE) GO TO 340
                  IF (K .GT. 1) GO TO 260
                  DUM2 = DUM2+DUM2
                  GO TO 340
  260             DUM2 = DUM2+CSK*CPL*BINV
                  GO TO 340
  280             DUM2 = DUM1*CPL
                  IF (DOUBLE) DUM2 = DUM2+DUM2
                  GO TO 340
  300             DUM2 = DUM1*CDL
                  IF (DOUBLE) DUM2 = DUM2+DUM2
                  GO TO 340
  320             IF (NORM) DUM2 = DUM2*SQRT3
                  GO TO 340
  321             DUM2 = DUM1*CFL
                  IF (DOUBLE) DUM2 = DUM2+DUM2
                  GO TO 340
  322             IF (NORM) DUM2 = DUM2*SQRT5
                  GO TO 340
  323             IF (NORM) DUM2 = DUM2*SQRT3
                  GO TO 340
  324             DUM2 = DUM1*CGL
                  IF (DOUBLE) DUM2 = DUM2+DUM2
                  GO TO 340
  325             IF (NORM) DUM2 = DUM2*SQRT7
                  GO TO 340
  326             IF (NORM) DUM2 = DUM2*SQRT5/SQRT3
                  GO TO 340
  327             IF (NORM) DUM2 = DUM2*SQRT3
  340             N = N+1
                  DKL(N) = DUM2
  360          CONTINUE
  370       CONTINUE
C
C           ----- PAIR OF I,J PRIMITIVES
C
            NN = 0
            DO 440 N = 1,NIJ
               DUM = BBRRK+R(N)
               IF (DUM .GT. TOL) GO TO 440
               DO 380 I = 1,IJ
                  DIJ(I) = DDIJ(IJD(I)+NN)
  380          CONTINUE
               A = AA(N)
               AB = A*B
               AANDB = A+B
               EXPE = EXP(-DUM)/SQRT(AANDB)
               RHO = AB/AANDB
               XA = X1(N)
               YA = Y1(N)
               ZA = Z1(N)
               XX = RHO*((XA-XB)*(XA-XB) + (YA-YB)*(YA-YB)
     *                                   + (ZA-ZB)*(ZA-ZB))
               AXAK = A*(XA-XK)
               AYAK = A*(YA-YK)
               AZAK = A*(ZA-ZK)
               AXAI = A*(XA-XI)
               AYAI = A*(YA-YI)
               AZAI = A*(ZA-ZI)
               C1X = BXBK+AXAK
               C2X = A*BXBK
               C3X = BXBI+AXAI
               C4X = B*AXAI
               C1Y = BYBK+AYAK
               C2Y = A*BYBK
               C3Y = BYBI+AYAI
               C4Y = B*AYAI
               C1Z = BZBK+AZAK
               C2Z = A*BZBK
               C3Z = BZBI+AZAI
               C4Z = B*AZAI
C
C              ----- ROOTS AND WEIGHTS FOR QUADRATURE
C
               IF (NROOTS .LE. 3) CALL RT123
               IF (NROOTS .EQ. 4) CALL ROOT4
               IF (NROOTS .EQ. 5) CALL ROOT5
               IF (NROOTS .GE. 6) CALL ROOT6
               MM = 0
               MAX = NMAX+1
C
C              COMPUTE TWO-ELECTRON INTEGRALS FOR EACH ROOT
C
               DO 420 M = 1,NROOTS
                  U2 = U(M)*RHO
                  F00 = EXPE*W(M)
                  DO 400 I = 1,MAX
                     IN(I) = IN1(I)+MM
  400             CONTINUE
                  DUMINV = ONE/(AB+U2*AANDB)
                  DM2INV = HALF*DUMINV
                  BP01 = (A+U2)*DM2INV
                  B00 = U2*DM2INV
                  B10 = (B+U2)*DM2INV
                  XCP00 = (U2*C1X+C2X)*DUMINV
                  XC00 = (U2*C3X+C4X)*DUMINV
                  YCP00 = (U2*C1Y+C2Y)*DUMINV
                  YC00 = (U2*C3Y+C4Y)*DUMINV
                  ZCP00 = (U2*C1Z+C2Z)*DUMINV
                  ZC00 = (U2*C3Z+C4Z)*DUMINV
                  CALL XYZINT
                  MM = MM+625
  420          CONTINUE
C
C              ----- FORM (I,J//K,L) INTEGRALS OVER FUNCTIONS
C
               CALL FORMS(GHONDO)
  440       NN = NN+16
  460    CONTINUE
  480 CONTINUE
C
      RETURN
      END
C*MODULE INT2A   *DECK IJPRIM
      SUBROUTINE IJPRIM(DDIJ)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL IANDJ,KANDL,SAME,OUT,NORM
C
      PARAMETER (MXGSH=30, MXG2=MXGSH*MXGSH)
C
      DIMENSION DDIJ(16*MXG2)
C
      COMMON /IJGNRL/ A(MXG2),R(MXG2),X1(MXG2),Y1(MXG2),Z1(MXG2),
     *                IJD(225)
      COMMON /MISC  / IANDJ,KANDL,SAME
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /SHLINF/ AG(MXGSH),CSA(MXGSH),CPA(MXGSH),CDA(MXGSH),
     *                CFA(MXGSH),CGA(MXGSH),
     *                BG(MXGSH),CSB(MXGSH),CPB(MXGSH),CDB(MXGSH),
     *                CFB(MXGSH),CGB(MXGSH),
     *                CG(MXGSH),CSC(MXGSH),CPC(MXGSH),CDC(MXGSH),
     *                CFC(MXGSH),CGC(MXGSH),
     *                DG(MXGSH),CSD(MXGSH),CPD(MXGSH),CDD(MXGSH),
     *                CFD(MXGSH),CGD(MXGSH),
     *                XI,YI,ZI,XJ,YJ,ZJ,RRI,XK,YK,ZK,XL,YL,ZL,RRK,
     *                NGA,NGB,NGC,NGD
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     *                NIJ,IJ,KL,IJKL
      COMMON /SHLT  / TOL,CUTOFF,ICOUNT,OUT
C
      PARAMETER (SQRT3=1.73205080756888D+00,
     *           SQRT5=2.23606797749979D+00,
     *           SQRT7=2.64575131106459D+00,
     *           ZERO=0.0D+00, ONE=1.0D+00)
C
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
      MAX = MAXJ
      N = 0
      NN = 0
      NM = -2**20
      DO 180 I = MINI,MAXI
         GO TO (100,100,120,120,100,120,120,100,120,120,
     1          100,120,120,100,120,120,120,120,120,100,
     1          100,120,120,100,120,120,120,120,120,100,
     1          120,120,100,120,120),I
  100    NM = NN
  120    NN = NM
         IF (IANDJ) MAX = I
         DO 170 J = MINJ,MAX
            GO TO (140,140,160,160,140,160,160,140,160,160,
     1             140,160,160,140,160,160,160,160,160,140,
     1             140,160,160,140,160,160,160,160,160,140,
     1             160,160,140,160,160),J
  140       NN = NN+1
  160       N = N+1
            IJD(N) = NN
  170    CONTINUE
  180 CONTINUE
C
C     ----- I PRIMITIVE
C
      NIJ = 0
      JBMAX = NGB
      DO 540 IA = 1,NGA
         AI = AG(IA)
         ARRI = AI*RRI
         AXI = AI*XI
         AYI = AI*YI
         AZI = AI*ZI
         CSI = CSA(IA)
         CPI = CPA(IA)
         CDI = CDA(IA)
         CFI = CFA(IA)
         CGI = CGA(IA)
C
C        ----- J PRIMITIVE
C
         IF (IANDJ) JBMAX = IA
         DO 520 JB = 1,JBMAX
            AJ = BG(JB)
            AA = AI+AJ
            AAINV = ONE/AA
            DUM = AJ*ARRI*AAINV
            IF (DUM .GT. TOL) GO TO 520
            CSJ = CSB(JB)
            CPJ = CPB(JB)
            CDJ = CDB(JB)
            CFJ = CFB(JB)
            CGJ = CGB(JB)
            NM = 16*NIJ
            NN = NM
            NIJ = NIJ+1
            R(NIJ) = DUM
            A(NIJ) = AA
            X1(NIJ) = (AXI+AJ*XJ)*AAINV
            Y1(NIJ) = (AYI+AJ*YJ)*AAINV
            Z1(NIJ) = (AZI+AJ*ZJ)*AAINV
C
C           ----- DENSITY FACTOR
C
            DUM1 = ZERO
            DUM2 = ZERO
            DO 420 I = MINI,MAXI
               GO TO (200,220,420,420,240,420,420,260,420,420,
     1                261,420,420,262,420,420,420,420,420,263,
     1                264,420,420,265,420,420,420,420,420,266,
     1                420,420,267,420,420),I
  200          DUM1 = CSI*AAINV
               GO TO 280
  220          DUM1 = CPI*AAINV
               GO TO 280
  240          DUM1 = CDI*AAINV
               GO TO 280
  260          IF (NORM) DUM1 = DUM1*SQRT3
               GO TO 280
  261          DUM1 = CFI*AAINV
               GO TO 280
  262          IF (NORM) DUM1 = DUM1*SQRT5
               GO TO 280
  263          IF (NORM) DUM1 = DUM1*SQRT3
               GO TO 280
  264          DUM1 = CGI*AAINV
               GO TO 280
  265          IF (NORM) DUM1 = DUM1*SQRT7
               GO TO 280
  266          IF (NORM) DUM1 = DUM1*SQRT5/SQRT3
               GO TO 280
  267          IF (NORM) DUM1 = DUM1*SQRT3
  280          IF (IANDJ) MAX = I
               DO 400 J = MINJ,MAX
                  GO TO (300,320,400,400,340,400,400,360,400,400,
     1                   361,400,400,362,400,400,400,400,400,363,
     1                   364,400,400,365,400,400,400,400,400,366,
     1                   400,400,367,400,400),J
  300             DUM2 = DUM1*CSJ
                  GO TO 380
  320             DUM2 = DUM1*CPJ
                  GO TO 380
  340             DUM2 = DUM1*CDJ
                  GO TO 380
  360             IF (NORM) DUM2 = DUM2*SQRT3
                  GO TO 380
  361             DUM2 = DUM1*CFJ
                  GO TO 380
  362             IF (NORM) DUM2 = DUM2*SQRT5
                  GO TO 380
  363             IF (NORM) DUM2 = DUM2*SQRT3
                  GO TO 380
  364             DUM2 = DUM1*CGJ
                  GO TO 380
  365             IF (NORM) DUM2 = DUM2*SQRT7
                  GO TO 380
  366             IF (NORM) DUM2 = DUM2*SQRT5/SQRT3
                  GO TO 380
  367             IF (NORM) DUM2 = DUM2*SQRT3
  380             NN = NN+1
                  DDIJ(NN) = DUM2
  400          CONTINUE
  420       CONTINUE
            IF ( .NOT. IANDJ) GO TO 520
            IF (IA .EQ. JB) GO TO 520
            GO TO (500,440,460,455,450),LIT
  440       IF (MINI .EQ. 2) GO TO 500
            DDIJ(NM+2) = DDIJ(NM+2)+CSI*CPJ*AAINV
            GO TO 480
  450       DDIJ(NM+10) = DDIJ(NM+10)+DDIJ(NM+10)
            DDIJ(NM+9) = DDIJ(NM+9)+DDIJ(NM+9)
            DDIJ(NM+8) = DDIJ(NM+8)+DDIJ(NM+8)
            DDIJ(NM+7) = DDIJ(NM+7)+DDIJ(NM+7)
  455       DDIJ(NM+6) = DDIJ(NM+6)+DDIJ(NM+6)
            DDIJ(NM+5) = DDIJ(NM+5)+DDIJ(NM+5)
            DDIJ(NM+4) = DDIJ(NM+4)+DDIJ(NM+4)
  460       DDIJ(NM+2) = DDIJ(NM+2)+DDIJ(NM+2)
  480       DDIJ(NM+3) = DDIJ(NM+3)+DDIJ(NM+3)
  500       DDIJ(NM+1) = DDIJ(NM+1)+DDIJ(NM+1)
  520    CONTINUE
  540 CONTINUE
      RETURN
      END
C*MODULE INT2A   *DECK INTIN
      SUBROUTINE INTIN
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION INTGRL,MCSCF,MOROKM
      LOGICAL PK,PANDK,BLOCK,PACK2E,SCHWRZ,DIRSCF,FDIFF,
     *        GOPARR,DSKWRK,MASWRK,SVDSKW,DIRTRF,SCREEN,
     *        MOIDON,EDCOMP,DIPDCM,DEPRNT,QADDCM,ZDO,
     *        POLDCM,POLANG,POLAPP,KMIDPT
      LOGICAL QOPS,QFMM
C
      PARAMETER (NNAM=19)
      PARAMETER (MXATM=500,NMO=500)
C
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
C
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *        ITERMS,QOPS,ISCUT
      COMMON /DFGRID/ DFTTHR,SW0,NDFTFG,NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0
      COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
     *                                                    NAUXSHL
      COMMON /EDCMP / MOIDNO(5,NMO),ZIJ(NMO),ZMO(5,NMO),IJMO(2,NMO),
     *                MOIJ(NMO),NMOIJ(NMO),NMOAT(NMO),OCCUP(NMO),MOIDON,
     *                EDCOMP,DIPDCM,IPROT(5),NPROT,DEPRNT,QADDCM,ZDO,
     *                POLDCM,POLANG,POLAPP,KMIDPT
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,IPOPLE
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /ORDOPT/ NORDER,NDAR  ,LDAR  ,NBOXMX,NWORD,NOMEM,NSQUAR
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
      COMMON /PKFIL / PK,PANDK,BLOCK
      COMMON /PRPOPT/ ILOCAL
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCINP / VLAMB,SCREEN
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,DIRTRF
      COMMON /WFNOPT/ SCFTYP,CITYP,DFTYPE,CCTYP,MPLEVL,MPCTYP
C
      DATA IJKO/24/
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA UHF,ROHF,GVB/8HUHF     ,8HROHF    ,8HGVB     /
#else
      CHARACTER*8 :: GVB_STR
      EQUIVALENCE (GVB, GVB_STR)
      CHARACTER*8 :: UHF_STR
      EQUIVALENCE (UHF, UHF_STR)
      CHARACTER*8 :: ROHF_STR
      EQUIVALENCE (ROHF, ROHF_STR)
      DATA UHF_STR,ROHF_STR,GVB_STR/"UHF     ","ROHF    ","GVB     "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA MCSCF,RNONE/8HMCSCF   ,8HNONE    /
#else
      CHARACTER*8 :: RNONE_STR
      EQUIVALENCE (RNONE, RNONE_STR)
      CHARACTER*8 :: MCSCF_STR
      EQUIVALENCE (MCSCF, MCSCF_STR)
      DATA MCSCF_STR,RNONE_STR/"MCSCF   ","NONE    "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA MOROKM/8HMOROKUMA/
#else
      CHARACTER*8 :: MOROKM_STR
      EQUIVALENCE (MOROKM, MOROKM_STR)
      DATA MOROKM_STR/"MOROKUMA"/
#endif
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA INTGRL/8HINTGRL  /
#else
      CHARACTER*8 :: INTGRL_STR
      EQUIVALENCE (INTGRL, INTGRL_STR)
      DATA INTGRL_STR/"INTGRL  "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA QNAM/8HNORDER  ,8HNDAR    ,8HLDAR    ,8HNBOXMX  ,
     *          8HNWORD   ,8HNINTMX  ,8HNOMEM   ,8HNSQUAR  ,
     *          8HNOPK    ,
     *          8HIST     ,8HJST     ,8HKST     ,8HLST     ,
     *          8HNREC    ,8HINTLOC  ,8HSCHWRZ  ,
     *          8HSCREEN  ,8HVLAMB   ,8HQFMM    /
#else
      CHARACTER*8 :: QNAM_STR(NNAM)
      EQUIVALENCE (QNAM, QNAM_STR)
      DATA QNAM_STR/"NORDER  ","NDAR    ","LDAR    ","NBOXMX  ",
     *          "NWORD   ","NINTMX  ","NOMEM   ","NSQUAR  ",
     *          "NOPK    ",
     *          "IST     ","JST     ","KST     ","LST     ",
     *          "NREC    ","INTLOC  ","SCHWRZ  ",
     *          "SCREEN  ","VLAMB   ","QFMM    "/
#endif
      DATA KQNAM/1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,3,0/
C
C     ----- INITIALIZE VARIABLES FOR NAMELIST $INTGRL -----
C
      NORDER = 0
      NDAR   = 2000
      CALL RASIZE(LDAR)
      NBOXMX = 200
      NWORD  = 0
      NINTMX = 0
      NOMEM  = 0
      NSQUAR = 0
      QFMM  =.FALSE.
C                    INITIAL VALUE OF NOPK IS ILLEGAL
      NOPK   = -27
      IST    = 1
      JST    = 1
      KST    = 1
      LST    = 1
      NREC   = 1
      INTLOC = 1
      SCHWRZ =.FALSE.
      SCREEN=.FALSE.
      VLAMB=0.0D+00
      IF(NAT.GT.5) SCHWRZ=.TRUE.
      IF(DIRSCF) SCHWRZ=.TRUE.
C
C    ----- READ NAMELIST $INTGRL -----
C
      CALL NAMEIO(IR,JRET,INTGRL,NNAM,QNAM,KQNAM,
     *            NORDER,NDAR,LDAR,NBOXMX,NWORD,NINTMX,NOMEM,NSQUAR,
     *            NOPK,IST,JST,KST,LST,NREC,INTLOC,SCHWRZ,SCREEN,VLAMB,
     *            QFMM,
     *            0,0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,    0,0,0,0,0,  0,0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,    0,0,0,0,0,  0,0,0,0,0)
      IF(JRET.EQ.2) THEN
         IF (MASWRK) WRITE(IW,9000)
         CALL ABRT
      END IF
C
      IF (QFMM) CALL QFMMIN
C
C     IF SCREEN THEN SCHWARZ INEQUALITIES ARE SKIPPED
C
      IF (SCREEN) SCHWRZ=.FALSE.
C
      ISCHWZ = 0
      IF(SCHWRZ) ISCHWZ = 1
C
C     ----- DETERMINE WHICH 2E- INTEGRAL SCHEME TO USE -----
C     NOPK=0 MEANS A -P- SUPERMATRIX, AND POSSIBLY -K- SUPERMATRIX.
C     NOPK=1 MEANS A CONVENTIONAL -J- INTEGRAL LIST WILL BE USED.
C     SUPERMATRIX IS INCORRECT FOR MOROKUMA ANALYSIS.
C     ANYTHING THAT DOES AN INTEGRAL TRANSFORMATION (E.G. MCSCF,
C     CI, MP2, RUEDENBERG LOCALIZATION, ANALYTIC HESSIAN, LOCALIZED
C     ORBITAL POLARIZABILITIES) MAY NOT USE A SUPERMATRIX.
C
      CALL DERCHK(NDER)
      IF(NDFTFG.NE.0)              NOPK = 1
      IF(DFTTYP(1) .NE. 0.0D+00)   NOPK = 1
      IF(RUNTYP.EQ.MOROKM)         NOPK = 1
      IF(SCFTYP.EQ.MCSCF)          NOPK = 1
      IF(CITYP.NE.RNONE)           NOPK = 1
      IF(ILOCAL.EQ.2)              NOPK = 1
      IF(POLDCM)                   NOPK = 1
      IF(NDER.EQ.2)                NOPK = 1
C
C         SINCE J FILE IS MUCH SHORTER THAN P OR PK FILE,
C         AND I/O IS STILL QUITE BAD EVEN IF STRIPING,
C         WE MAKE ALL INTEGRAL FILES NON-SUPERMATRIX,
C         UNLESS THE USER HAS SPECIFICALLY ASKED FOR ONE.
C
      IF(NOPK.EQ.-27)              NOPK = 1
      IF(NOPK.NE.1)                NOPK = 0
C
      PK = NOPK.EQ.0
      PANDK = (PK .AND. SCFTYP.EQ. UHF) .OR.
     *        (PK .AND. SCFTYP.EQ.ROHF) .OR.
     *        (PK .AND. SCFTYP.EQ. GVB)
C
      IF(      PANDK .AND. NINTMX.EQ.0) NINTMX=10000
      IF(.NOT. PANDK .AND. NINTMX.EQ.0) NINTMX=15000
C
C     ----- OPEN INTEGRAL FILES -----
C
      IF(DIRSCF  .OR.  DIRTRF) THEN
         PK    = .FALSE.
         PANDK = .FALSE.
         NOPK  = 1
      ELSE
         SVDSKW = DSKWRK
         DSKWRK = .TRUE.
         CALL SEQOPN(IS,'AOINTS','UNKNOWN',.FALSE.,'UNFORMATTED')
C
C     EXCHANGE -IJKO- AND -IS- SO WE DON'T GET TWO COPIES OF 2E-INTS
C
         IF (RUNTYP.EQ.MOROKM) THEN
            CALL SEQOPN(IJKO,'ORDINT','UNKNOWN',.FALSE.,'UNFORMATTED')
            ISK = IJKO
            IJKO = IS
            IS = ISK
         END IF
         DSKWRK = SVDSKW
      END IF
C
C     ARRAY DIMENSIONS THROUGH OUT THE PROGRAM ALLOW -MXAO- AO-S,
C     EXCEPT IN THE CI CODE WHERE THE LIMIT IS -MXAOCI-.
C     THESE LIMITS ARE TESTED NEAR WHERE THE MOLECULE IS READ IN,
C     AND NEED NOT CONCERN US FURTHER.
C     FOR CONVENTIONAL SCF, WITH A P OR PK SUPERMATRIX, THE 16
C     BIT PACKING LIMITS THE AOS TO 361.  ELSEWHERE WE USE 8
C     BITS TO HANDLE CASES SMALLER THAN 256, 16 BITS OTHERWISE.
C
      MAXAO=255
      IF(PK) MAXAO=361
      LABSIZ = 1
      IF(NUM.GT.MAXAO) LABSIZ = 2
      IF(PK  .AND.  NUM.GT.MAXAO) THEN
         IF(MASWRK) WRITE(IW,*) 'TOO MANY AOS TO USE PK SUPERMATRIX.'
         IF(MASWRK) WRITE(IW,*) 'USE J INTEGRAL LIST, OR DIRECT SCF'
         CALL ABRT
      END IF
C
      IF (MASWRK) WRITE(IW,9010) NOPK,NORDER,SCHWRZ
C
C     CHECK IF IT IS AN SCREEN CALCULATION. IF SO, TELL IT ,
C     MAKE SCHWZ FALSE AND
C     CALL TO THE INITFCTS SUBROUTINE TO GENERATE THE VALUES
C     FOR COMMON /FCTS/
C
      IF (SCREEN) THEN
          WRITE(IW,9011) SCREEN,VLAMB
          CALL INITFCTS
      END IF
C
      RETURN
C
 9000 FORMAT(1X,'ERROR IN $INTGRL INPUT')
 9010 FORMAT(/10X,22("-")/10X,'INTEGRAL INPUT OPTIONS'/10X,22("-")/
     *       1X,'NOPK  =',I8,' NORDER=',I8,' SCHWRZ=',L8)
 9011 FORMAT(/,'SCREENED INTEGRALS',10X,
     *       ' SCREEN=',L8,' VLAMB= ',F6.3,/)
      END
C*MODULE INT2A   *DECK INTOUT
      SUBROUTINE INTOUT(I1,I2,I3,I4,Q4,NN,VAL)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /INTPR / Q(3),V(3),JC,N1(3),J1(3),J2(3),J3(3),J4(3)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      JC = JC+1
      J1(JC) = I1
      J2(JC) = I2
      J3(JC) = I3
      J4(JC) = I4
      Q(JC) = Q4
      N1(JC) = NN
      V(JC) = VAL
      IF (JC .LT. 3) GO TO 100
      JC = 0
      IF (MASWRK) WRITE (IW,9008)
     *   (J1(M),J2(M),J3(M),J4(M),Q(M),N1(M),V(M),M = 1,3)
  100 CONTINUE
      RETURN
 9008 FORMAT(3(4I3,F6.3,I5,E20.12))
      END
C*MODULE INT2A   *DECK JANDK
      SUBROUTINE JANDK
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL SCHWRZ,PACK2E,PK,PANDK,BLOCK,DIRTRF,FDIFF
      LOGICAL GOPARR,DSKWRK,MASWRK,TDSKWRK,DIRSCF
C
      PARAMETER (MXSH=1000, MXGTOT=5000, MXGSH=30, MXG2=MXGSH*MXGSH)
C
      COMMON /FMCOM / XX(1)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTG76
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),MIN(MXSH),MAX(MXSH),NSHELL
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /ORDOPT/ NORDER,NDAR,LDAR,NBOXMX,NWORD,NOMEM,NSQUAR
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /PKFIL / PK,PANDK,BLOCK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,DIRTRF
      COMMON /WFNOPT/ SCFTYP,CITYP,DFTYPE,CCTYP,MPLEVL,MPCTYP
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA CHECK/8HCHECK   /
#else
      CHARACTER*8 :: CHECK_STR
      EQUIVALENCE (CHECK, CHECK_STR)
      DATA CHECK_STR/"CHECK   "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA NONE/4HNONE/
#else
      CHARACTER*4 :: NONE_STR
      EQUIVALENCE (NONE, NONE_STR)
      DATA NONE_STR/"NONE"/
#endif
C
C     ----- MAIN DRIVER FOR CALCULATION OF 2E- INTEGRALS -----
C
C     ----- MOPAC 2-ELECTRON INTEGRALS ALREADY CALCULATED -----
C
      IF(MPCTYP.NE.NONE) RETURN
C
C     HONDO INTEGRAL PACKAGE REQUIRES A BUFFER DIMENSIONED FOR
C     THE MAXIMUM ANGULAR MOMENTUM OCCURING IN THE BASIS SET.
C     A PURE SP BASIS USING THE POPLE INTEGRALS DOESN'T NEED THIS.
C
      CALL BASCHK(LMAX)
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
                 MAXG = NANGM**4
      IF(PK)     MAXG = MAXG*3
      IF(DIRSCF) MAXG = 1
C
      NSH2 = (NSHELL*NSHELL+NSHELL)/2
C
      CALL VALFM(LOADFM)
      LBUFP  = LOADFM + 1
      LBUFK  = LBUFP  + NINTMX
      LIX    = LBUFK  + NINTMX
      LXINTS = LIX    + NINTMX
      LGHOND = LXINTS + NSH2
      LDDIJ  = LGHOND + MAXG
      LAST   = LDDIJ  + 16*MXG2
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      IF(EXETYP.EQ.CHECK) THEN
         IF(ISCHWZ.GT.0) THEN
            CALL VCLR(XX(LXINTS),1,NSH2)
            CALL DAWRIT(IDAF,IODA,XX(LXINTS),NSH2,54,0)
         END IF
      END IF
C
C           INITIALIZE THE CALCULATION
C
      TDSKWRK = DSKWRK
      DSKWRK  = .TRUE.
      CALL DEBUT(INTG76,DIRSCF,XX(LBUFP),XX(LBUFK),XX(LIX),
     *           NINTMX,NEED,DIRTRF)
      IF(EXETYP.EQ.CHECK)  GO TO 200
      IF(DIRSCF.OR.DIRTRF) GO TO 200
C
C     ----- PACKING PARAMETERS
C           NHEX = DESIRED HEXADECIMAL ACCURACY.
C           NTUPL= # OF BYTES PER INTEGER WORD TO BE PACKED.
C                  THE NEGATIVE VALUE OF -NTUPL- MEANS THAT THE
C                  INTEGER LABELS ARE NOT TO BE PACKED.
C     THIS IS AN INACTIVE OPTION.
C
      PACK2E = ICUT .LT. 0
      NTUPL = -4
      IF (PACK2E .AND. MASWRK) WRITE (IW,9088) NHEX,NTUPL
 9088 FORMAT(" THE INTEGRALS ARE PACKED WITH A.D.MCLEAN",
     *     26H PACKING UTILITIES (1977).,8H NHEX = ,I5,9H NTUPL = ,I5/)
C
C           GENERATE ALL EXCHANGE INTEGRALS
C
      SCHWRZ = ISCHWZ.GT.0
      IF(SCHWRZ) CALL EXCHNG(XX(LXINTS),XX(LGHOND),XX(LDDIJ),
     *                       NSH2,MAXG,INTG76)
C
C           CRUNCH OUT THE INTEGRALS
C
      IDUMMY=0
      DUMMY=0.0D+00
      CALL TWOEI(SCFTYP,.FALSE.,.FALSE.,.FALSE.,.FALSE.,
     *           INTG76,SCHWRZ,NINT,NSCHWZ,1,1,
     *           XX(LBUFP),XX(LBUFK),XX(LIX),NINTMX,
     *           XX(LXINTS),NSH2,XX(LGHOND),MAXG,XX(LDDIJ),
     *           IDUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,1)
C
  200 CONTINUE
      DSKWRK  = TDSKWRK
      CALL RETFM(NEED)
      IF (MASWRK .AND. NPRTGO.NE.2)
     *   WRITE(IW,*) ' ...... END OF TWO-ELECTRON INTEGRALS .....'
      IF (MASWRK) CALL TEXIT(1,1)
C
C     ----- INTEGRAL ORDERING -----
C
      IF (NORDER.EQ.1) CALL ORDRJK
      RETURN
      END
C*MODULE INT2A   *DECK PKFILE
      SUBROUTINE PKFILE(II,JJ,KK,LL,SKIPA,SKIPB,SKIPC,NPSYM,POPLE,
     *                  BUFP,BUFK,IX,NINTMX,GHONDO)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION BUFP(NINTMX),BUFK(NINTMX),IX(NINTMX),GHONDO(*)
      DIMENSION IB(15),JB(15),KB(15),LB(15),IBPOP(4,4)
C
      LOGICAL SKIPA,SKIPB,SKIPC,NPSYM,POPLE
      LOGICAL PKFL,PANDK,BLOCK,IANDJ,KANDL,SAME,OUT,FIRST
C
      PARAMETER (MXSH=1000, MXGTOT=5000, MXAO=2047)
C
      COMMON /FLIPS / IB1,JB1,KB1,LB1,IB2,JB2,KB2,LB2,IB3,JB3,KB3,LB3
      COMMON /GOUT  / GPOPLE(768),NORG
      COMMON /IJPAIR/ IJADD(MXAO)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /MISC  / IANDJ,KANDL,SAME
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),MIN(MXSH),MAX(MXSH),NSHELL
      COMMON /PCKLAB/ LABSIZ
      COMMON /PKFIL / PKFL,PANDK,BLOCK
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     *                NIJ,IJ,KL,IJKL
      COMMON /SHLT  / TOL,CUTOFF,ICOUNT,OUT
C
      PARAMETER (ZERO=0.0D+00, HALF=0.5D+00)
C
      SAVE FIRST,NORG1H,NORG2H,NORG3H,IB,JB,KB,LB
C
      DATA IBPOP/0,0,0,0,64,16,4,1,128,32,8,2,192,48,12,3/
      DATA FIRST/.TRUE./
C
C     ----- WRITE THIS SHELL'S P OR PK INTEGRAL FILE -----
C
      IF(FIRST) THEN
         FIRST=.FALSE.
         CALL BASCHK(LMAX)
                       NANGM =  4
         IF(LMAX.EQ.2) NANGM =  6
         IF(LMAX.EQ.3) NANGM = 10
         IF(LMAX.EQ.4) NANGM = 15
         NORG1H = 1
         NORG2H = NORG1H + NANGM**4
         NORG3H = NORG2H + NANGM**4
         DO 50 I=1,NANGM
            LB(I) = I-1
            KB(I) = LB(I) * NANGM
            JB(I) = KB(I) * NANGM
            IB(I) = JB(I) * NANGM
  50     CONTINUE
      END IF
C
      IND = 1
      IF (SKIPA .AND. NPSYM) IND = 2
      IF (SKIPB .AND. NPSYM) IND = 3
      IF (SKIPC .AND. NPSYM) IND = 3
      IF (SKIPA .AND. SKIPB .AND. NPSYM) IND = 4
C
      IF(POPLE) THEN
         NORG1 = 1
         NORG2 = 257
         NORG3 = 513
      ELSE
         NORG1 = NORG1H
         NORG2 = NORG2H
         NORG3 = NORG3H
      END IF
C
      LIT = KTYPE(II)
      MINI = MIN(II)
      MAXI = MAX(II)
      LOCI = KLOC(II)-MINI
      MINJ = MIN(JJ)
      MAXJ = MAX(JJ)
      LOCJ = KLOC(JJ)-MINJ
      LKT = KTYPE(KK)
      MINK = MIN(KK)
      MAXK = MAX(KK)
      LOCK = KLOC(KK)-MINK
      MINL = MIN(LL)
      MAXL = MAX(LL)
      LOCL = KLOC(LL)-MINL
      IANDJ = II .EQ. JJ
      KANDL = KK .EQ. LL
      SAME = (II .EQ. KK) .AND. (JJ .EQ. LL)
C
      IF(POPLE) THEN
         IF ( .NOT. SKIPA) GO TO 100
         IF ( .NOT. NPSYM) NORG2 = 1
         IB2 = IB1
         JB2 = JB1
         KB2 = KB1
         LB2 = LB1
  100    IF ( .NOT. SKIPB) GO TO 140
         IF ( .NOT. NPSYM) NORG3 = NORG1
         IF (II .NE. KK) GO TO 120
         IF (JJ .EQ. LL) GO TO 120
         IB3 = KB1
         JB3 = LB1
         KB3 = JB1
         LB3 = IB1
         GO TO 180
  120    IB3 = IB1
         JB3 = JB1
         KB3 = LB1
         LB3 = KB1
         GO TO 180
  140    CONTINUE
         IF ( .NOT. SKIPC) GO TO 180
         IF ( .NOT. NPSYM) NORG3 = NORG2
         IF (II .NE. JJ) GO TO 160
         IF (KK .EQ. LL) GO TO 160
         IB3 = KB2
         JB3 = LB2
         KB3 = IB2
         LB3 = JB2
         GO TO 180
  160    IB3 = IB2
         JB3 = JB2
         KB3 = KB2
         LB3 = LB2
  180    CONTINUE
      ELSE
C
C     TYPE = 1 FOR (II II II II)
C            2     (II JJ JJ JJ)
C            3     (II II KK KK) AND  LIT.GE.LKT
C            4     (II II KK KK) AND  LIT.LT.LKT
C            5     (II II II LL)
C            6     (II JJ KK KK)
C            7     (II JJ JJ LL)
C            8     (II II KK LL)
C            9     (II JJ KK LL)
C
         NTYP = 0
         IF (II .EQ. JJ .AND. JJ .EQ. KK .AND. KK .EQ. LL) NTYP = 1
         IF (II .GT. JJ .AND. JJ .EQ. KK .AND. KK .EQ. LL) NTYP = 2
         IF (II .EQ. JJ .AND. JJ .GT. KK .AND. KK .EQ. LL
     *                                 .AND. LIT .GE. LKT) NTYP = 3
         IF (II .EQ. JJ .AND. JJ .GT. KK .AND. KK .EQ. LL
     *                                 .AND. LIT .LT. LKT) NTYP = 4
         IF (II .EQ. JJ .AND. JJ .EQ. KK .AND. KK .GT. LL) NTYP = 5
         IF (II .GT. JJ .AND. JJ .GT. KK .AND. KK .EQ. LL) NTYP = 6
         IF (II .GT. JJ .AND. JJ .EQ. KK .AND. KK .GT. LL) NTYP = 7
         IF (II .EQ. JJ .AND. JJ .GT. KK .AND. KK .GT. LL) NTYP = 8
         IF (II .GT. JJ .AND. JJ .GT. KK .AND. KK .GT. LL) NTYP = 9
         IF (SKIPA .AND. .NOT. NPSYM) NORG2 = 1
         IF (SKIPC .AND. .NOT. NPSYM) NORG3 = NORG2H
         IF (SKIPB .AND. .NOT. NPSYM) NORG3 = 1
      END IF
C
C     ----- BEGIN LOOPS OVER PRIMITIVES IN THIS SHELL -----
C
C     INTEGRAL TYPES N1,G1 FOR (I,J//K,L)
C                    N2,G2 FOR (I,K//J,L)
C                    N3,G3 FOR (I,L//J,K)
C
C                      POPLE INTEGRALS
C        N1 = IBPOP(IB1,I)+IBPOP(JB1,J)+
C    *        IBPOP(KB1,K)+IBPOP(LB1,L)+NORG1
C        N2 = IBPOP(IB2,I)+IBPOP(JB2,K)+
C    *        IBPOP(KB2,J)+IBPOP(LB2,L)+NORG2
C        N3 = IBPOP(IB3,I)+IBPOP(JB3,L)+
C    *        IBPOP(KB3,J)+IBPOP(LB3,K)+NORG3
C                      HONDO INTEGRALS
C        N1 = IB(IA)+JB(JA)+KB(KA)+LB(LA)+NORG1
C        N2 = IB(IA)+JB(KA)+KB(JA)+LB(LA)+NORG2
C
      JMAX = MAXJ
      KMAX = MAXK
      LMAX = MAXL
      DO 860 I = MINI,MAXI
      IAO = LOCI + I
      IF(POPLE) THEN
         N1I = NORG1 + IBPOP(IB1,I)
         N2I = NORG2 + IBPOP(IB2,I)
         N3I = NORG3 + IBPOP(IB3,I)
      ELSE
         IA = I-MINI+1
         N1I = NORG1 + IB(IA)
         N2I = NORG2 + IB(IA)
      END IF
C
      IF (IANDJ) JMAX = I
      DO 840 J = MINJ,JMAX
      IF (JJ .EQ. KK) KMAX = J
      JAO = LOCJ + J
      IF(POPLE) THEN
         N1IJ = N1I + IBPOP(JB1,J)
         N2IJ = N2I + IBPOP(KB2,J)
         N3IJ = N3I + IBPOP(KB3,J)
      ELSE
         JA = J-MINJ+1
         N1IJ = N1I + JB(JA)
         N2IJ = N2I + KB(JA)
      END IF
C
      DO 820 K = MINK,KMAX
      KAO = LOCK + K
      IF(POPLE) THEN
         N1IJK = N1IJ + IBPOP(KB1,K)
         N2IJK = N2IJ + IBPOP(JB2,K)
         N3IJK = N3IJ + IBPOP(LB3,K)
      ELSE
         KA = K-MINK+1
         N1IJK = N1IJ + KB(KA)
         N2IJK = N2IJ + JB(KA)
      END IF
C
      IF (KANDL) LMAX = K
      DO 800 L = MINL,LMAX
      LAO = LOCL + L
      IF(POPLE) THEN
         N1 = N1IJK + IBPOP(LB1,L)
         N2 = N2IJK + IBPOP(LB2,L)
         N3 = N3IJK + IBPOP(JB3,L)
      ELSE
         LA = L-MINL+1
         N1 = N1IJK + LB(LA)
         N2 = N2IJK + LB(LA)
C
         GO TO (200,220,230,250,270,280,290,300,310),NTYP
  200    IF (IA .EQ. JA) GO TO 210
         N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
         GO TO 400
  210    N3 = IB(JA)+JB(KA)+KB(IA)+LB(LA)+NORG3
         GO TO 400
  220    N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
         GO TO 400
  230    IF (IA .EQ. JA) GO TO 240
         N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
         GO TO 400
  240    N3 = IB(JA)+JB(KA)+KB(IA)+LB(LA)+NORG3
         GO TO 400
  250    IF (KA .EQ. LA) GO TO 260
         N3 = IB(JA)+JB(KA)+KB(IA)+LB(LA)+NORG3
         GO TO 400
  260    N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
         GO TO 400
  270    N3 = IB(JA)+JB(KA)+KB(IA)+LB(LA)+NORG3
         GO TO 400
  280    N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
         GO TO 400
  290    N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
         GO TO 400
  300    N3 = IB(JA)+JB(KA)+KB(IA)+LB(LA)+NORG3
         GO TO 400
  310    N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
      END IF
C
C     ----- FORM FIRST LINEAR COMBINATION -----
C
  400 CONTINUE
      IF(POPLE) THEN
         G1 = GPOPLE(N1)
         G2 = GPOPLE(N2)
         G3 = GPOPLE(N3)
      ELSE
         G1 = GHONDO(N1)
         G2 = GHONDO(N2)
         G3 = GHONDO(N3)
      END IF
C
      JUMP = 1
      I1 = IAO
      I2 = JAO
      I3 = KAO
      I4 = LAO
      IF (I2 .EQ. I3) JUMP = 2
      IF ((I2 .EQ. I4) .OR. (I1 .EQ. I3)) JUMP = 3
C
      GO TO (410,420,430,440),IND
  410 VALK = G2+G3
      VALP = (G1+G1)+(G1+G1)-VALK
      GO TO 460
  420 VALK = G3
      VALP = (G1+G1)+(G1+G1)-VALK
      GO TO 460
  430 VALK = G2
      VALP = (G1+G1)+(G1+G1)-VALK
      GO TO 460
  440 VALK = ZERO
      VALP = (G1+G1)+(G1+G1)
  460 CONTINUE
      NN = N1
      GO TO 700
C
C     ----- FORM SECOND LINEAR COMBINATION -----
C
  500 CONTINUE
      GO TO (510,520,530,540),IND
  510 VALK = G3+G1
      VALP = (G2+G2)+(G2+G2)-VALK
      GO TO 560
  520 VALK = G1+G3
      VALP = -VALK
      GO TO 560
  530 VALK = G1
      VALP = (G2+G2)+(G2+G2)-VALK
      GO TO 560
  540 VALK = G1
      VALP = -VALK
  560 CONTINUE
      NN = N2
      JUMP = 2
      IF ((I1 .EQ. I2) .OR. (I3 .EQ. I4)) JUMP = 3
      I2 = KAO
      I3 = JAO
      GO TO 700
C
C     ----- FORM THIRD LINEAR COMBINATION -----
C
  600 CONTINUE
      GO TO (610,620,630,640),IND
  610 VALK = G1+G2
      VALP = (G3+G3)+(G3+G3)-VALK
      GO TO 660
  620 VALK = G1
      VALP = (G3+G3)+(G3+G3)-VALK
      GO TO 660
  630 VALK = G1+G2
      VALP = -VALK
      GO TO 660
  640 VALK = G1
      VALP = -VALK
  660 CONTINUE
      NN = N3
      I2 = LAO
      I3 = JAO
      I4 = KAO
      JUMP = 3
C
C     ----- STORE INTEGRAL AND INDICES -----
C
  700 CONTINUE
      IF (PANDK) GO TO 740
C
C     ----- -P- SUPERMATRIX ONLY -----
C
      IF (ABS(VALP) .LT. CUTOFF) GO TO 780
      IF (OUT) CALL INTOUT(I1,I2,I3,I4,QQ4,NN,VALP)
      IF (I1.EQ.I3 .AND. I2.EQ.I4) VALP = VALP*HALF
      I1I2 = IJADD(I1) + I2
      I3I4 = IJADD(I3) + I4
C
                 NPACK = ICOUNT
                 IPACK = I1I2
                 JPACK = I3I4
                 IF (LABSIZ .EQ. 2) THEN
#if !defined(SPEC_CPU_ILP64)
                   IX( 2*NPACK-1 ) = IPACK
                   IX( 2*NPACK   ) = JPACK
#endif
#if defined(SPEC_CPU_ILP64)
                   LABEL = ISHFT( IPACK, 32 ) + JPACK
                   IX(NPACK) = LABEL
#endif
                 ELSE IF (LABSIZ .EQ. 1) THEN
#if !defined(SPEC_CPU_ILP64)
                   LABEL = ISHFT( IPACK, 16 ) + JPACK
                   IX(NPACK) = LABEL
#endif
#if defined(SPEC_CPU_ILP64)
                   IF ( MOD(NPACK,2) .EQ. 0 ) THEN
                     LABEL = ISHFT( IPACK, 16 ) + JPACK
                     IX( NPACK/2 ) = IX( NPACK/2 ) + LABEL
                   ELSE
                     LABEL = ISHFT( IPACK, 48 ) + ISHFT( JPACK, 32 )
                     IX( (NPACK/2)+1 ) = LABEL
                   END IF
#endif
                 END IF
C
      BUFP(ICOUNT) = VALP
      ICOUNT = ICOUNT+1
      IF (ICOUNT .GT. NINTMX) THEN
         NXX = NINTMX
         CALL PWRIT(IS,BUFP,IX,NXX,NINTMX)
         ICOUNT = 1
         NREC = NREC+1
      END IF
      GO TO 780
C
C     ----- -P- AND -K- SUPERMATRICES -----
C
  740 CONTINUE
      IF (ABS(VALP) .LT. CUTOFF .AND. ABS(VALK) .LT. CUTOFF) GO TO 780
      IF(OUT) THEN
         CALL INTOUT(I1,I2,I3,I4,QQ4,NN,VALP)
         CALL INTOUT(I1,I2,I3,I4,QQ4,NN,VALK)
      END IF
      IF (I1.EQ.I3 .AND. I2.EQ.I4) THEN
         VALP = VALP*HALF
         VALK = VALK*HALF
      END IF
      I1I2 = IJADD(I1) + I2
      I3I4 = IJADD(I3) + I4
C
                 NPACK = ICOUNT
                 IPACK = I1I2
                 JPACK = I3I4
                 IF (LABSIZ .EQ. 2) THEN
#if !defined(SPEC_CPU_ILP64)
                   IX( 2*NPACK-1 ) = IPACK
                   IX( 2*NPACK   ) = JPACK
#endif
#if defined(SPEC_CPU_ILP64)
                   LABEL = ISHFT( IPACK, 32 ) + JPACK
                   IX(NPACK) = LABEL
#endif
                 ELSE IF (LABSIZ .EQ. 1) THEN
#if !defined(SPEC_CPU_ILP64)
                   LABEL = ISHFT( IPACK, 16 ) + JPACK
                   IX(NPACK) = LABEL
#endif
#if defined(SPEC_CPU_ILP64)
                   IF ( MOD(NPACK,2) .EQ. 0 ) THEN
                     LABEL = ISHFT( IPACK, 16 ) + JPACK
                     IX( NPACK/2 ) = IX( NPACK/2 ) + LABEL
                   ELSE
                     LABEL = ISHFT( IPACK, 48 ) + ISHFT( JPACK, 32 )
                     IX( (NPACK/2)+1 ) = LABEL
                   END IF
#endif
                 END IF
C
      BUFP(ICOUNT) = VALP
      BUFK(ICOUNT) = VALK
      ICOUNT = ICOUNT+1
      IF (ICOUNT .GT. NINTMX) THEN
         NXX = NINTMX
         CALL PKWRIT(IS,BUFP,BUFK,IX,NXX,NINTMX)
         ICOUNT = 1
         NREC = NREC+1
      END IF
  780 CONTINUE
      GO TO (500,600,800),JUMP
  800 CONTINUE
  820 CONTINUE
  840 CONTINUE
  860 CONTINUE
      RETURN
      END
C*MODULE INT2A   *DECK QOUT
      SUBROUTINE QOUT(IEXCH,POPLE,BUFP,IX,NINTMX,GHONDO)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL IANDJ,KANDL,SAME,OUT,POPLE
C
      DIMENSION BUFP(NINTMX),IX(*),GHONDO(*)
C
      PARAMETER (MXSH=1000, MXGTOT=5000)
C
      COMMON /FLIPS / IB(4,3)
      COMMON /GOUT  / GPOPLE(768),NORG
      COMMON /INTDEX/ IJGT(225),IJX(225),IJY(225),IJZ(225),IK(225),
     *                KLGT(225),KLX(225),KLY(225),KLZ(225)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /MISC  / IANDJ,KANDL,SAME
      COMMON /NSHEL / EXX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PCKLAB/ LABSIZ
      COMMON /SHLG70/ ISH,JSH,KSH,LSH,IJKLXX(4)
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     *                NIJ,IJ,KL,IJKL
      COMMON /SHLT  / TOL,CUTOFF,ICOUNT,OUT
C
      DIMENSION IBPOP(4,4)
C
C-NEXT STATEMENT IS FOR VARIOUS IBM XLF 3.X AND 5.X COMPILERS-
C
      SAVE IJN,KLN,IBB,JBB,KBB,LBB
C
      DATA IBPOP/0,0,0,0,64,16,4,1,128,32,8,2,192,48,12,3/
      DATA HALF /0.5D+00/
C
C     ----- PACK THE 4 INDICES OF INTEGRAL INTO ONE WORD
C     ----- WRITE LABEL + INTEGRAL ON TAPE (IS)
C
      IF(POPLE) THEN
         IANDJ = ISH.EQ.JSH
         KANDL = KSH.EQ.LSH
         SAME  = ISH.EQ.KSH  .AND.  JSH.EQ.LSH
         IBB  = IB(1,IEXCH)
         JBB  = IB(2,IEXCH)
         KBB  = IB(3,IEXCH)
         LBB  = IB(4,IEXCH)
         MINI = KMIN(ISH)
         MINJ = KMIN(JSH)
         MINK = KMIN(KSH)
         MINL = KMIN(LSH)
         MAXI = KMAX(ISH)
         MAXJ = KMAX(JSH)
         MAXK = KMAX(KSH)
         MAXL = KMAX(LSH)
         LOCI = KLOC(ISH)-MINI
         LOCJ = KLOC(JSH)-MINJ
         LOCK = KLOC(KSH)-MINK
         LOCL = KLOC(LSH)-MINL
      END IF
C
      IJN = 0
      JMAX = MAXJ
      DO 260 I = MINI,MAXI
         IF (IANDJ) JMAX = I
         DO 240 J = MINJ,JMAX
            IJN = IJN+1
            IF(POPLE) THEN
               N1 = IBPOP(IBB,I)+IBPOP(JBB,J)+1+NORG
            ELSE
               N1 = IJGT(IJN)
            END IF
            LMAX = MAXL
            KLN = 0
            DO 220 K =  MINK,MAXK
               IF (KANDL) LMAX = K
               DO 200 L = MINL,LMAX
                  KLN = KLN+1
                  IF(SAME  .AND.  KLN.GT.IJN) GO TO 240
                  IF(POPLE) THEN
                     NN = N1+IBPOP(KBB,K)+IBPOP(LBB,L)
                     VAL = GPOPLE(NN)
                  ELSE
                     NN = N1+KLGT(KLN)
                     VAL = GHONDO(NN)
                  END IF
                  IF(ABS(VAL).LT.CUTOFF) GO TO 200
                  I1 = LOCI+I
                  I2 = LOCJ+J
                  I3 = LOCK+K
                  I4 = LOCL+L
                  IF (I1 .GE. I2) GO TO 100
                  N = I1
                  I1 = I2
                  I2 = N
  100             IF (I3 .GE. I4) GO TO 120
                  N = I3
                  I3 = I4
                  I4 = N
  120             IF (I1-I3) 140,160,180
  140             N = I1
                  I1 = I3
                  I3 = N
                  N = I2
                  I2 = I4
                  I4 = N
                  GO TO 180
  160             IF (I2 .LT. I4) GO TO 140
  180             CONTINUE
C
                  IF (OUT) CALL INTOUT(I1,I2,I3,I4,QQ4,NN,VAL)
                  IF (I1 .EQ. I2) VAL = VAL*HALF
                  IF (I3 .EQ. I4) VAL = VAL*HALF
                  IF (I1 .EQ. I3 .AND. I2 .EQ. I4) VAL = VAL*HALF
C
               NPACK = ICOUNT
               IPACK = I1
               JPACK = I2
               KPACK = I3
               LPACK = I4
               IF (LABSIZ .EQ. 2) THEN
#if !defined(SPEC_CPU_ILP64)
                 LABEL1 = ISHFT( IPACK, 16 ) + JPACK
                 LABEL2 = ISHFT( KPACK, 16 ) + LPACK
                 IX( 2*NPACK-1 ) = LABEL1
                 IX( 2*NPACK   ) = LABEL2
#endif
#if defined(SPEC_CPU_ILP64)
                 LABEL = ISHFT( IPACK, 48 ) + ISHFT( JPACK, 32 ) +
     *                   ISHFT( KPACK, 16 ) + LPACK
                 IX(NPACK) = LABEL
#endif
               ELSE IF (LABSIZ .EQ. 1) THEN
#if !defined(SPEC_CPU_ILP64)
                 LABEL = ISHFT( IPACK, 24 ) + ISHFT( JPACK, 16 ) +
     *                   ISHFT( KPACK,  8 ) + LPACK
                 IX(NPACK) = LABEL
#endif
#if defined(SPEC_CPU_ILP64)
                 IF ( MOD(NPACK,2) .EQ. 0 ) THEN
                   LABEL = ISHFT( IPACK, 24 ) + ISHFT( JPACK, 16 ) +
     *                     ISHFT( KPACK,  8 ) + LPACK
                   IX( NPACK/2 ) = IX( NPACK/2 ) + LABEL
                 ELSE
                   LABEL = ISHFT( IPACK, 56 ) + ISHFT( JPACK, 48 ) +
     *                     ISHFT( KPACK, 40 ) + ISHFT( LPACK, 32 )
                   IX( (NPACK/2)+1 ) = LABEL
                 END IF
#endif
               END IF
C
                  BUFP(ICOUNT) = VAL
                  ICOUNT = ICOUNT+1
                  IF (ICOUNT .GT. NINTMX) THEN
                     NXX = NINTMX
                     CALL PWRIT(IS,BUFP,IX,NXX,NINTMX)
                     ICOUNT = 1
                     NREC = NREC+1
                  END IF
  200          CONTINUE
  220       CONTINUE
  240    CONTINUE
  260 CONTINUE
      RETURN
      END
C*MODULE INT2A   *DECK S0000
      SUBROUTINE S0000(GHONDO,DDIJ)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL IANDJ,KANDL,SAME,OUT
C
      PARAMETER (MXGSH=30, MXG2=MXGSH*MXGSH)
C
      DIMENSION GHONDO(*),DDIJ(16*MXG2)
C
      COMMON /IJGNRL/ A(MXG2),R(MXG2),X1(MXG2),Y1(MXG2),Z1(MXG2),
     *                IJD(225)
      COMMON /GOUT  / GPOPLE(768),NORG
      COMMON /MISC  / IANDJ,KANDL,SAME
      COMMON /SHLINF/ AG(MXGSH),CSA(MXGSH),CPA(MXGSH),CDA(MXGSH),
     *                CFA(MXGSH),CGA(MXGSH),
     *                BG(MXGSH),CSB(MXGSH),CPB(MXGSH),CDB(MXGSH),
     *                CFB(MXGSH),CGB(MXGSH),
     *                CG(MXGSH),CSC(MXGSH),CPC(MXGSH),CDC(MXGSH),
     *                CFC(MXGSH),CGC(MXGSH),
     *                DG(MXGSH),CSD(MXGSH),CPD(MXGSH),CDD(MXGSH),
     *                CFD(MXGSH),CGD(MXGSH),
     *                XI,YI,ZI,XJ,YJ,ZJ,RRI,XK,YK,ZK,XL,YL,ZL,RRK,
     *                NGA,NGB,NGC,NGD
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     *                NIJ,IJ,KL,IJKL
      COMMON /SHLT  / TOL,CUTOFF,ICOUNT,OUT
C
      PARAMETER (PI252=34.986836655250D+00, PIE4=7.85398163397448D-01,
     *           ZERO=0.0D+00, ONE=1.0D+00)
C
C     SPECIAL SSSS INTEGRAL ROUTINE WHEN USING HONDO INTEGRALS
C
      GGOUT = ZERO
      LGMAX = NGD
      DO 300 KG = 1,NGC
      BK = CG(KG)
      BRRK = BK*RRK
      BXK = BK*XK
      BYK = BK*YK
      BZK = BK*ZK
      CSK = CSC(KG)
      IF (KANDL) LGMAX = KG
      DO 280 LG = 1,LGMAX
      BL = DG(LG)
      BB = BK+BL
      BBINV = ONE/BB
      DUM = BL*BRRK*BBINV
      IF (DUM .GT. TOL) GO TO 280
      BBRRK = DUM
      D2 = CSD(LG)*CSK*BBINV
      IF (KANDL .AND. LG .NE. KG) D2 = D2+D2
      BBX = (BXK+BL*XL)*BBINV
      BBY = (BYK+BL*YL)*BBINV
      BBZ = (BZK+BL*ZL)*BBINV
      SUM = ZERO
      NN = 1
      DO 260 N = 1,NIJ
      DUM = BBRRK+R(N)
      IF (DUM .GT. TOL) GO TO 260
      EXPE = EXP(-DUM)
      AA = A(N)
      AB = AA+BB
      DUM = X1(N)-BBX
      XX = DUM*DUM
      DUM = Y1(N)-BBY
      XX = DUM*DUM+XX
      DUM = Z1(N)-BBZ
      XX = DUM*DUM+XX
      X = XX*AA*BB/AB
C
      IF (X .GT. 5.0D+00) GO TO 160
      IF (X .GT. 1.0D+00) GO TO 120
      IF (X .GT. 3.0D-07) GO TO 100
      WW1 = 1.0D+00-X/3.0D+00
      GO TO 240
C
  100 CONTINUE
      F1 = ((((((((-8.36313918003957D-08*X+1.21222603512827D-06 )*X-
     +     1.15662609053481D-05 )*X+9.25197374512647D-05 )*X-
     +     6.40994113129432D-04 )*X+3.78787044215009D-03 )*X-
     +     1.85185172458485D-02 )*X+7.14285713298222D-02 )*X-
     +     1.99999999997023D-01 )*X+3.33333333333318D-01
      WW1 = (X+X)*F1+EXP(-X)
      GO TO 240
C
  120 CONTINUE
      IF (X .GT. 3.0D+00) GO TO 140
      Y = X-2.0D+00
      F1 = ((((((((((-1.61702782425558D-10*Y+1.96215250865776D-09 )*Y-
     +     2.14234468198419D-08 )*Y+2.17216556336318D-07 )*Y-
     +     1.98850171329371D-06 )*Y+1.62429321438911D-05 )*Y-
     +     1.16740298039895D-04 )*Y+7.24888732052332D-04 )*Y-
     +     3.79490003707156D-03 )*Y+1.61723488664661D-02 )*Y-
     +     5.29428148329736D-02 )*Y+1.15702180856167D-01
      WW1 = (X+X)*F1+EXP(-X)
      GO TO 240
C
  140 CONTINUE
      Y = X-4.0D+00
      F1 = ((((((((((-2.62453564772299D-11*Y+3.24031041623823D-10 )*Y-
     +     3.614965656163D-09)*Y+3.760256799971D-08)*Y-
     +     3.553558319675D-07)*Y+3.022556449731D-06)*Y-
     +     2.290098979647D-05)*Y+1.526537461148D-04)*Y-
     +     8.81947375894379D-04 )*Y+4.33207949514611D-03 )*Y-
     +     1.75257821619926D-02 )*Y+5.28406320615584D-02
      WW1 = (X+X)*F1+EXP(-X)
      GO TO 240
C
  160 CONTINUE
      IF (X .GT. 15.0D+00) GO TO 200
      E = EXP(-X)
      IF (X .GT. 10.0D+00) GO TO 180
      XINV = ONE/X
      WW1 = (((((( 4.6897511375022D-01*XINV-6.9955602298985D-01)*XINV +
     +     5.3689283271887D-01)*XINV-3.2883030418398D-01)*XINV +
     +     2.4645596956002D-01)*XINV-4.9984072848436D-01)*XINV -
     +     3.1501078774085D-06)*E + SQRT(PIE4*XINV)
      GO TO 240
C
  180 CONTINUE
      XINV = ONE/X
      WW1 = (((-1.8784686463512D-01*XINV+2.2991849164985D-01)*XINV
     +         -4.9893752514047D-01)*XINV-2.1916512131607D-05)*E
     +         + SQRT(PIE4*XINV)
      GO TO 240
C
  200 CONTINUE
      IF (X .GT. 33.0D+00) GO TO 220
      XINV = ONE/X
      E = EXP(-X)
      WW1 = (( 1.9623264149430D-01*XINV-4.9695241464490D-01)*XINV -
     +     6.0156581186481D-05)*E + SQRT(PIE4*XINV)
      GO TO 240
C
  220 WW1 = SQRT(PIE4/X)
C
  240 SUM = SUM+DDIJ(NN)*WW1*EXPE/SQRT(AB)
  260 NN = NN+16
      GGOUT = GGOUT+D2*SUM
  280 CONTINUE
  300 CONTINUE
      GHONDO(NORG+1) = GGOUT*PI252*QQ4
      RETURN
      END
C*MODULE INT2A   *DECK SCHWDN
      DOUBLE PRECISION FUNCTION SCHWDN(DSH,ISH,JSH,KSH,LSH,IA)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION DSH(*),IA(*)
C
      PARAMETER (FOUR=4.0D+00)
C
C     ----- FIND MAXIMUM DENSITY CONTRIBUTION TO THIS SHELL SET -----
C     -DSH- IS THE DENSITY MATRIX ALREADY COMPRESSED TO SHELLS
C
      IJ = IA(ISH)+JSH
      IK = IA(ISH)+KSH
      IL = IA(ISH)+LSH
      KL = IA(KSH)+LSH
      JK = IA(JSH)+KSH
      JL = IA(JSH)+LSH
      IF(JSH.LT.KSH) JK=IA(KSH)+JSH
      IF(JSH.LT.LSH) JL=IA(LSH)+JSH
      SCHWDN=MAX(FOUR*DSH(IJ),FOUR*DSH(KL),
     *           DSH(JL),DSH(JK),DSH(IL),DSH(IK))
      RETURN
      END
C*MODULE INT2A   *DECK SHELLS
      SUBROUTINE SHELLS(NELEC,ISH,JSH,KSH,LSH,FLIP)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL FLIP
      LOGICAL IANDJ,KANDL,SAME,FIRST
C
      DIMENSION IX(35),IY(35),IZ(35),
     *          JX(35),JY(35),JZ(35),
     *          KX(35),KY(35),KZ(35),
     *          LX(35),LY(35),LZ(35)
C
      PARAMETER (MXSH=1000, MXGSH=30, MXGTOT=5000, MXATM=500)
C
      COMMON /GOUT  / GPOPLE(768),NORG
      COMMON /INTDEX/ IJGT(225),IJX(225),IJY(225),IJZ(225),IK(225),
     *                KLGT(225),KLX(225),KLY(225),KLZ(225)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /MISC  / IANDJ,KANDL,SAME
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /ROOT  / XX,U(9),W(9),NROOTS
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     +                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     +                NIJ,IJ,KL,IJKL
      COMMON /SHLINF/ GA(MXGSH),CSA(MXGSH),CPA(MXGSH),CDA(MXGSH),
     *                CFA(MXGSH),CGA(MXGSH),
     *                GB(MXGSH),CSB(MXGSH),CPB(MXGSH),CDB(MXGSH),
     *                CFB(MXGSH),CGB(MXGSH),
     *                GC(MXGSH),CSC(MXGSH),CPC(MXGSH),CDC(MXGSH),
     *                CFC(MXGSH),CGC(MXGSH),
     *                GD(MXGSH),CSD(MXGSH),CPD(MXGSH),CDD(MXGSH),
     *                CFD(MXGSH),CGD(MXGSH),
     *                AX,AY,AZ,BX,BY,BZ,RAB,CX,CY,CZ,DX,DY,DZ,RCD,
     *                NGA,NGB,NGC,NGD
C
      SAVE FIRST,IGT,JGT,KGT,LGT
C
      DATA LX /   0,  1,  0,  0,  2,  0,  0,  1,  1,  0,
     *            3,  0,  0,  2,  2,  1,  0,  1,  0,  1,
     *            4,  0,  0,  3,  3,  1,  0,  1,  0,  2,
     *            2,  0,  2,  1,  1/
      DATA KX /   0,  5,  0,  0, 10,  0,  0,  5,  5,  0,
     *           15,  0,  0, 10, 10,  5,  0,  5,  0,  5,
     *           20,  0,  0, 15, 15,  5,  0,  5,  0, 10,
     *           10,  0, 10,  5,  5/
      DATA JX /   0, 25,  0,  0, 50,  0,  0, 25, 25,  0,
     *           75,  0,  0, 50, 50, 25,  0, 25,  0, 25,
     *          100,  0,  0, 75, 75, 25,  0, 25,  0, 50,
     *           50,  0, 50, 25, 25/
      DATA IX /   1,126,  1,  1,251,  1,  1,126,126,  1,
     *          376,  1,  1,251,251,126,  1,126,  1,126,
     *          501,  1,  1,376,376,126,  1,126,  1,251,
     *          251,  1,251,126,126/
      DATA LY /   0,  0,  1,  0,  0,  2,  0,  1,  0,  1,
     *            0,  3,  0,  1,  0,  2,  2,  0,  1,  1,
     *            0,  4,  0,  1,  0,  3,  3,  0,  1,  2,
     *            0,  2,  1,  2,  1/
      DATA KY /   0,  0,  5,  0,  0, 10,  0,  5,  0,  5,
     *            0, 15,  0,  5,  0, 10, 10,  0,  5,  5,
     *            0, 20,  0,  5,  0, 15, 15,  0,  5, 10,
     *            0, 10,  5, 10,  5/
      DATA JY /   0,  0, 25,  0,  0, 50,  0, 25,  0, 25,
     *            0, 75,  0, 25,  0, 50, 50,  0, 25, 25,
     *            0,100,  0, 25,  0, 75, 75,  0, 25, 50,
     *            0, 50, 25, 50, 25/
      DATA IY /   1,  1,126,  1,  1,251,  1,126,  1,126,
     *            1,376,  1,126,  1,251,251,  1,126,126,
     *            1,501,  1,126,  1,376,376,  1,126,251,
     *            1,251,126,251,126/
      DATA LZ /   0,  0,  0,  1,  0,  0,  2,  0,  1,  1,
     *            0,  0,  3,  0,  1,  0,  1,  2,  2,  1,
     *            0,  0,  4,  0,  1,  0,  1,  3,  3,  0,
     *            2,  2,  1,  1,  2/
      DATA KZ /   0,  0,  0,  5,  0,  0, 10,  0,  5,  5,
     *            0,  0, 15,  0,  5,  0,  5, 10, 10,  5,
     *            0,  0, 20,  0,  5,  0,  5, 15, 15,  0,
     *           10, 10,  5,  5, 10/
      DATA JZ /   0,  0,  0, 25,  0,  0, 50,  0, 25, 25,
     *            0,  0, 75,  0, 25,  0, 25, 50, 50, 25,
     *            0,  0,100,  0, 25,  0, 25, 75, 75,  0,
     *           50, 50, 25, 25, 50/
      DATA IZ /   1,  1,  1,126,  1,  1,251,  1,126,126,
     *            1,  1,376,  1,126,  1,126,251,251,126,
     *            1,  1,501,  1,126,  1,126,376,376,  1,
     *          251,251,126,126,251/
      DATA FIRST/.TRUE./
C
      IF(FIRST) THEN
         FIRST=.FALSE.
         CALL BASCHK(LMAX)
                       NANGM =  4
         IF(LMAX.EQ.2) NANGM =  6
         IF(LMAX.EQ.3) NANGM = 10
         IF(LMAX.EQ.4) NANGM = 15
         LGT = 1
         KGT = LGT * NANGM
         JGT = KGT * NANGM
         IGT = JGT * NANGM
      END IF
C
C     PREPARE SHELL INFORMATION/FOR HONDO INTEGRATION
C
      IF(NELEC.EQ.2) GO TO 200
C
C     ----- PERMUTE ISH AND JSH SHELLS, FOR THEIR TYPE
C     THIS IS DONE FOR SPEED REASONS.  THE CODE GETS THE RIGHT ANSWER
C     WITHOUT THE ANGULAR MOMENTUM FLIPPING, AND THEREFORE A CALLING
C     ARGUMENT ALLOWS ONE DO EXACTLY THE INTEGRAL BLOCK AS SPECIFIED,
C     SHOULD THAT BE DESIRED.
C
      IANDJ = ISH .EQ. JSH
      IF (KTYPE(ISH) .LT. KTYPE(JSH)  .AND.  FLIP) THEN
         INU = JSH
         JNU = ISH
         NGTI = JGT
         NGTJ = IGT
      ELSE
         INU = ISH
         JNU = JSH
         NGTI = IGT
         NGTJ = JGT
      END IF
C
C     ----- ISHELL
C
      I = KATOM(INU)
      AX = C(1,I)
      AY = C(2,I)
      AZ = C(3,I)
      I1 = KSTART(INU)
      I2 = I1+KNG(INU)-1
      LIT = KTYPE(INU)
      MINI = KMIN(INU)
      MAXI = KMAX(INU)
      LOCI = KLOC(INU)-MINI
      NGA = 0
      DO 140 I = I1,I2
         NGA = NGA+1
         GA(NGA) = EX(I)
         CSA(NGA) = CS(I)
         CPA(NGA) = CP(I)
         CDA(NGA) = CD(I)
         CFA(NGA) = CF(I)
         CGA(NGA) = CG(I)
  140 CONTINUE
C
C     ----- JSHELL
C
      J = KATOM(JNU)
      BX = C(1,J)
      BY = C(2,J)
      BZ = C(3,J)
      J1 = KSTART(JNU)
      J2 = J1+KNG(JNU)-1
      LJT = KTYPE(JNU)
      MINJ = KMIN(JNU)
      MAXJ = KMAX(JNU)
      LOCJ = KLOC(JNU)-MINJ
      NGB = 0
      DO 160 J = J1,J2
         NGB = NGB+1
         GB(NGB) = EX(J)
         CSB(NGB) = CS(J)
         CPB(NGB) = CP(J)
         CDB(NGB) = CD(J)
         CFB(NGB) = CF(J)
         CGB(NGB) = CG(J)
  160 CONTINUE
      RAB = ((AX-BX)*(AX-BX) + (AY-BY)*(AY-BY) + (AZ-BZ)*(AZ-BZ))
C
C     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS
C
      IJ = 0
      JMAX = MAXJ
      DO 190 I = MINI,MAXI
         NX = IX(I)
         NY = IY(I)
         NZ = IZ(I)
         IF (IANDJ) JMAX = I
         DO 180 J = MINJ,JMAX
            IJ = IJ+1
            IJX(IJ) = NX+JX(J)
            IJY(IJ) = NY+JY(J)
            IJZ(IJ) = NZ+JZ(J)
            IJGT(IJ) = NGTI*(I-MINI)+NGTJ*(J-MINJ)+1+NORG
  180    CONTINUE
  190 CONTINUE
      RETURN
C     ******
C
C        K AND L SHELL
C
  200 CONTINUE
      KANDL = KSH .EQ. LSH
      SAME = ISH .EQ. KSH .AND. JSH .EQ. LSH
C
C     ----- PERMUTE KSH AND LSH SHELLS, FOR THEIR TYPE
C
      IF (KTYPE(KSH) .LT. KTYPE(LSH)  .AND.  FLIP) THEN
         KNU = LSH
         LNU = KSH
         NGTK = LGT
         NGTL = KGT
      ELSE
         KNU = KSH
         LNU = LSH
         NGTK = KGT
         NGTL = LGT
      END IF
C
C     ----- K SHELL
C
      K = KATOM(KNU)
      CX = C(1,K)
      CY = C(2,K)
      CZ = C(3,K)
      K1 = KSTART(KNU)
      K2 = K1+KNG(KNU)-1
      LKT = KTYPE(KNU)
      MINK = KMIN(KNU)
      MAXK = KMAX(KNU)
      LOCK = KLOC(KNU)-MINK
      NGC = 0
      DO 260 K = K1,K2
         NGC = NGC+1
         GC(NGC) = EX(K)
         CSC(NGC) = CS(K)
         CPC(NGC) = CP(K)
         CDC(NGC) = CD(K)
         CFC(NGC) = CF(K)
         CGC(NGC) = CG(K)
  260 CONTINUE
C
C     ----- LSHELL
C
      L = KATOM(LNU)
      DX = C(1,L)
      DY = C(2,L)
      DZ = C(3,L)
      L1 = KSTART(LNU)
      L2 = L1+KNG(LNU)-1
      LLT = KTYPE(LNU)
      MINL = KMIN(LNU)
      MAXL = KMAX(LNU)
      LOCL = KLOC(LNU)-MINL
      NGD = 0
      DO 280 L = L1,L2
         NGD = NGD+1
         GD(NGD) = EX(L)
         CSD(NGD) = CS(L)
         CPD(NGD) = CP(L)
         CDD(NGD) = CD(L)
         CFD(NGD) = CF(L)
         CGD(NGD) = CG(L)
  280 CONTINUE
      NROOTS = (LIT+LJT+LKT+LLT-2)/2
      RCD = ((CX-DX)*(CX-DX) + (CY-DY)*(CY-DY) + (CZ-DZ)*(CZ-DZ))
C
C     ----- PREPARE INDICES FOR PAIRS OF (K,L) FUNCTIONS
C
      KL = 0
      LMAX = MAXL
      DO 310 K = MINK,MAXK
         NX = KX(K)
         NY = KY(K)
         NZ = KZ(K)
         IF (KANDL) LMAX = K
         DO 300 L = MINL,LMAX
            KL = KL+1
            KLX(KL) = NX+LX(L)
            KLY(KL) = NY+LY(L)
            KLZ(KL) = NZ+LZ(L)
            KLGT(KL) = NGTK*(K-MINK)+NGTL*(L-MINL)
  300    CONTINUE
  310 CONTINUE
      MAX = KL
      DO 320 I = 1,IJ
      IF (SAME) MAX = I
  320 IK(I) = MAX
      IJKL = IJ*KL
      IF (SAME) IJKL = IJ*(IJ+1)/2
      RETURN
      END
C*MODULE INT2A   *DECK TWOEI
      SUBROUTINE TWOEI(TYPSCF,DIRSCF,DIRNLO,DIRTRF,DIRCIS,
     *                 INTG76,SCHWRZ,NINT,NSCHWZ,L1,L2,
     *                 BUFP,BUFK,IX,NINTMX,
     *                 XINTS,NSH2,GHONDO,MAXG,DDIJ,
     *                 IA,DA,FA,DB,FB,DSH,DNLO,FNLO,NFLMAT)
C
C       MANY ARGUMENTS ARE OPTIONAL, YOU MUST ALLOCATE STORAGE FOR
C              ALL CALLS: GHONDO, DDIJ, XINTS
C           CONVENTIONAL: BUFP, IX, AND POSSIBLY BUFK
C             DIRECT SCF: IA, DSH, DA, FA, AND POSSIBLY DB, FB
C             DIRECT CIS: IA, DSH, DA, FA, AND POSSIBLY DB, FB
C             DIRECT NLO: DNLO, FNLO, NFLMAT
C  DIRECT TRANSFORMATION: BUFP, IX
C     RESPONSE EQUATIONS: MUST DEFINE NFLMAT.NE.1
C  NOTE THAT THE TYPE OF FOCK MATRIX BUILT (TYPSCF) DOES NOT
C  NECESSARILY HAVE TO MATCH THIS RUNS SCFTYP VALUE.
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DIRSCF,DIRNLO,DIRTRF,DIRCIS,CMBDIR
      LOGICAL OUT,SCHWRZ,SCHSKP,GOPARR,DSKWRK,MASWRK,NXT
      LOGICAL SKIPA,SKIPB,SKIPC,NPSYM
      LOGICAL PK,PANDK,NOTPK,BLOCK,POPLE,GPSAVE,SCREEN,VECDIR,ASKVEC
C
      DIMENSION BUFP(NINTMX),BUFK(NINTMX),IX(*),XINTS(NSH2),
     *          GHONDO(MAXG),IA(L1),DA(L2),FA(L2),DB(L2),FB(L2),
     *          DSH(NSH2),DDIJ(*),DNLO(L1,L1),FNLO(L1,L1)
      DIMENSION MI(48),MJ(48),MK(48),M0(48),NORGP(3),NORGH(3)
C
      PARAMETER (MXSH=1000, MXGTOT=5000, MXATM=500)
C
      COMMON /GOUT  / GPOPLE(768),NORG
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PKFIL / PK,PANDK,BLOCK
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /SCINP / VLAMB,SCREEN
      COMMON /SHLG70/ ISH,JSH,KSH,LSH,IJKLXX(4)
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     *                NIJ,IJ,KL,IJKL
      COMMON /SHLT  / TOL,CUTOFF,ICOUNT,OUT
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
      COMMON /WFNOPT/ SCFTYP,CITYP,DFTYPE,CCTYP,MPLEVL,MPCTYP
C
      PARAMETER (ZERO=0.0D+00)
C
      DATA NORGP/0,  256,   512/
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA RNONE/8HNONE    /
#else
      CHARACTER*8 :: RNONE_STR
      EQUIVALENCE (RNONE, RNONE_STR)
      DATA RNONE_STR/"NONE    "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA RHF/8HRHF     /
#else
      CHARACTER*8 :: RHF_STR
      EQUIVALENCE (RHF, RHF_STR)
      DATA RHF_STR/"RHF     "/
#endif
C
C     ----- TWO-ELECTRON INTEGRALS -----
C     ----- THIS VERSION CAN HANDLE G SHELLS -----
C
      TIM = ZERO
      CALL TSECND(TIM)
C
C           PERHAPS CALL XABI LOPEZ/JOSE UGALDE'S SCREENED INTEGRAL CODE
C
      IF (SCREEN) THEN
         WRITE(IW,36)
  36     FORMAT (/,'#########',/,'SCREEN TWO-ELECTRON INTEGRAL',/)
         CALL STWOEI(TYPSCF,DIRSCF,DIRNLO,DIRTRF,
     *               INTG76,SCHWRZ,NINT,NSCHWZ,L1,L2,
     *               BUFP,BUFK,IX,NINTMX,
     *               XINTS,NSH2,GHONDO,MAXG,DDIJ,
     *               IA,DA,FA,DB,FB,DSH,DNLO,FNLO)
         RETURN
      END IF
C
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C
      NXT = IBTYP.EQ.1
      IPCOUNT = ME - 1
      NEXT = -1
      MINE = -1
      ICONT=  0
      CMBDIR= DIRSCF .OR. DIRNLO .OR. DIRTRF .OR. DIRCIS
      GPSAVE = GOPARR
      IF(DIRTRF) GOPARR=.FALSE.
C
      VECDIR = SCFTYP.EQ.RHF  .AND.  ASKVEC()
C
      CALL BASCHK(LMAX)
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      NORGH(1) = 0
      NORGH(2) = NORGH(1) + NANGM**4
      NORGH(3) = NORGH(2) + NANGM**4
C
      NOTPK = .NOT.PK
      NINT  = 0
      NSCHWZ= 0
      SCHSKP=.FALSE.
      DENMAX = ZERO
C
C        HONDO INTEGRALS ARE MORE ACCURATE FOR DIFFUSE SHELLS.
C        THE PROBLEM IS MOST ACCUTE FOR DETERMINING THE LCAO
C        MATRIX FOR VIRTUAL ORBITALS, WHERE DIFFUSE FUNCTIONS
C        OFTEN HAVE COEFFICIENTS OF THE ORDER OF ONE HUNDRED.
C        ERRORS IN VIRTUALS SHOW UP IN CORRELATED RUNS IN WHICH
C        THE VIRTUALS ARE OCCUPIED, SO WE NEED TO BE EVEN MORE
C        CAREFUL ABOUT INTEGRALS IN THOSE CASES.
C        AN ANION OF FORMULA C6NO2H12 WITH A 6-31+G(D) BASIS HAS
C        AN ENERGY CHANGE OF 2.5D-5 USING THE POPLE PACKAGE FOR
C        ITS DIFFUSE, SO WE SHOULD ALWAYS BE CAREFUL WITH ANIONS.
C
C        BETWEEN AUG 2001 AND NOV 2002, THE BASE ZTHRSH=0.01
C
                         ZTHRSH = 0.10D+00
      IF(MPLEVL.GT.0)    ZTHRSH = 0.10D+00
      IF(CITYP.NE.RNONE) ZTHRSH = 0.10D+00
      IF(CCTYP.NE.RNONE) ZTHRSH = 0.10D+00
      IF(ICH.LT.0)       ZTHRSH = 0.10D+00
C
C     ----- I SHELL -----
C
      DO 920 II = IST,NSHELL
C
C     ----- CHECK CPU TIME -----
C
      CALL TSECND(TIM)
      IF(TIM.GE.TIMLIM) THEN
         IF(.NOT.CMBDIR)
     *      CALL FINAL(0,II,1,1,1,PANDK,BUFP,BUFK,IX,NINTMX)
         IF(MASWRK) WRITE(IW,9030)
         CALL ABRT
      END IF
C
C     ----- PRINT INTERMEDIATE RESTART DATA -----
C
      IF(NPRINT.NE.-5.AND..NOT.CMBDIR.AND.MASWRK)
     *   WRITE(IW,9010) II,JST,KST,LST,NREC,ICOUNT
C
C     ----- SKIP I SHELL IF NOT SYMMETRY UNIQUE -----
C
      DO 120 IT = 1,NT
         ID = MAPSHL(II,IT)
         IF (ID .GT. II) GO TO 920
         MI(IT) = ID
  120 CONTINUE
C
C     OBTAIN SMALLEST EXPONENT IN THIS CONTRACTION
C
      ZMINI=1.0D+30
      IG1=KSTART(II)
      IG2=IG1+KNG(II)-1
      DO IG=IG1,IG2
         ZMINI=MIN(ZMINI,EX(IG))
      END DO
C
C     ----- J SHELL -----
C
      J0 = JST
      DO 900 JJ = J0,II
      JST = 1
      DO 200 IT = 1,NT
      ID = MI(IT)
      JD = MAPSHL(JJ,IT)
      MJ(IT) = JD
      IF (ID .GE. JD) GO TO 160
      ND = ID
      ID = JD
      JD = ND
  160 IF (ID-II) 200,180,900
  180 IF (JD-JJ) 200,200,900
  200 CONTINUE
C
C     ----- GO PARALLEL! -----
C
      IF (NXT .AND. GOPARR) THEN
         MINE = MINE + 1
         IF (MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
         IF (NEXT.NE.MINE) GO TO 900
      END IF
C
      ZMINJ=1.0D+30
      JG1=KSTART(JJ)
      JG2=JG1+KNG(JJ)-1
      DO JG=JG1,JG2
         ZMINJ=MIN(ZMINJ,EX(JG))
      END DO
C
C     ----- K SHELL -----
C
      K0 = KST
      DO 880 KK = K0,JJ
      KST = 1
      DO 340 IT = 1,NT
      ID = MI(IT)
      JD = MJ(IT)
      KD = MAPSHL(KK,IT)
      MK(IT) = KD
  240 IF (ID .GE. JD) GO TO 260
      ND = ID
      ID = JD
      JD = ND
  260 IF (JD .GE. KD) GO TO 280
      ND = JD
      JD = KD
      KD = ND
      GO TO 240
  280 IF (ID-II) 340,300,880
  300 IF (JD-JJ) 340,320,880
  320 IF (KD-KK) 340,340,880
  340 CONTINUE
C
      ZMINK=1.0D+30
      KG1=KSTART(KK)
      KG2=KG1+KNG(KK)-1
      DO KG=KG1,KG2
         ZMINK=MIN(ZMINK,EX(KG))
      END DO
C
C     ----- L SHELL ----
C
      L0 = LST
      DO 860 LL = L0,KK
      LST = 1
      N4 = 0
      DO 540 IT = 1,NT
      ID = MI(IT)
      JD = MJ(IT)
      KD = MK(IT)
      LD = MAPSHL(LL,IT)
  380 IF (ID .GE. JD) GO TO 400
      ND = ID
      ID = JD
      JD = ND
  400 IF (JD .GE. KD) GO TO 420
      ND = JD
      JD = KD
      KD = ND
      GO TO 380
  420 IF (KD .GE. LD) GO TO 440
      ND = KD
      KD = LD
      LD = ND
      GO TO 400
  440 IF (ID-II) 540,460,860
  460 IF (JD-JJ) 540,480,860
  480 IF (KD-KK) 540,500,860
  500 IF (LD-LL) 540,520,860
  520 N4 = N4+1
      M0(N4) = IT
  540 CONTINUE
C
C     ----- GO PARALLEL! -----
C
      IF ((.NOT.NXT) .AND. GOPARR) THEN
         IPCOUNT = IPCOUNT + 1
         IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 860
      END IF
C
      ZMINL=1.0D+30
      LG1=KSTART(LL)
      LG2=LG1+KNG(LL)-1
      DO LG=LG1,LG2
         ZMINL=MIN(ZMINL,EX(LG))
      END DO
      ZMIN = MIN(ZMINI,ZMINJ,ZMINK,ZMINL)
C
C     ----- CHECK FOR REDUNDANIES BETWEEN THE 3 COMBINATIONS
C           (II,JJ//KK,LL),(II,KK//JJ,LL),(II,LL//JJ,KK)
C
      SKIPA =  JJ.EQ.KK
      SKIPB = (II.EQ.KK) .OR. (JJ.EQ.LL)
      SKIPC = (II.EQ.JJ) .OR. (KK.EQ.LL)
      NPSYM = .FALSE.
      IF (SKIPA .OR. SKIPB .OR. SKIPC) GO TO 720
      NPSYM = .TRUE.
      DO 640 M = 1,N4
         IT = M0(M)
         IH = MI(IT)
         JH = MJ(IT)
         IF(JH.LE.IH) THEN
            ID = IH
            JD = JH
         ELSE
            ID = JH
            JD = IH
         END IF
         IF(.NOT.SKIPA) SKIPA = (ID.EQ.II .AND. JD.EQ.KK) .OR.
     *                          (ID.EQ.JJ .AND. JD.EQ.LL)
         IF(.NOT.SKIPB) SKIPB = (ID.EQ.II .AND. JD.EQ.LL) .OR.
     *                          (ID.EQ.JJ .AND. JD.EQ.KK)
         IF (SKIPA .AND. SKIPB) GO TO 660
         KH = MK(IT)
         IF(KH.LE.IH) THEN
            ID = IH
            KD = KH
         ELSE
            ID = KH
            KD = IH
         END IF
         IF(.NOT.SKIPC) SKIPC = (ID.EQ.II .AND. KD.EQ.LL) .OR.
     *                          (ID.EQ.JJ .AND. KD.EQ.KK)
         IF(SKIPA .AND. SKIPC) GO TO 680
         IF(SKIPB .AND. SKIPC) GO TO 700
  640 CONTINUE
      GO TO 720
C
  660 SKIPC = .TRUE.
      GO TO 720
  680 SKIPB = .TRUE.
      GO TO 720
  700 SKIPA = .TRUE.
C
  720 CONTINUE
      Q4 = NT
      Q4 = Q4 / N4
C
C     ----- (II,JJ//KK,LL) -----
C
      IEXCH = 1
      ISH = II
      JSH = JJ
      KSH = KK
      LSH = LL
      QQ4 = Q4
      IF(SKIPA .AND. NPSYM) QQ4 = QQ4+Q4
      IF(SKIPB .AND. NPSYM) QQ4 = QQ4+Q4
      GO TO 780
C
C     ----- (II,KK//JJ,LL) -----
C
  740 IF (SKIPA) GO TO 760
      IEXCH = 2
      ISH = II
      JSH = KK
      KSH = JJ
      LSH = LL
      QQ4 = Q4
      IF (SKIPC .AND. NPSYM) QQ4 = QQ4+Q4
      GO TO 780
C
C     ----- (II,LL//JJ,KK) -----
C
  760 IF (SKIPB .OR. SKIPC) GO TO 840
      IEXCH = 3
      ISH = II
      JSH = LL
      KSH = JJ
      LSH = KK
      QQ4 = Q4
C
C        ----- COMPUTE TWO-ELECTRON INTEGRALS ----
C
  780 CONTINUE
C
C     APPLY THE SCHWARZ INEQUALITY, WHICH IS
C     (II,JJ//KK,LL) .LE.  SQRT( (II,JJ//II,JJ)*(KK,LL//KK,LL) )
C     SEE, FOR EXAMPLE, J.L.WHITTEN, J.CHEM.PHYS. 58,4496-4501(1973)
C
      IF(SCHWRZ) THEN
         IJIJ = (ISH*ISH-ISH)/2 + JSH
         KLKL = (KSH*KSH-KSH)/2 + LSH
         TEST = QQ4*XINTS(IJIJ)*XINTS(KLKL)
         IF(DIRSCF) THEN
            DENMAX = SCHWDN(DSH,ISH,JSH,KSH,LSH,IA)
            TEST = TEST*DENMAX
         END IF
         SCHSKP = TEST.LT.CUTOFF
         IF(SCHSKP) NSCHWZ = NSCHWZ + 1
      END IF
C
      IF(NOTPK  .AND.  SCHSKP) GO TO 820
C
C     USE POPLE CODE FOR ANY PURE SP INTEGRAL BLOCKS,
C     USE HONDO RYS POLYNOMIAL CODE FOR OTHER BLOCKS
C
      POPLE=.TRUE.
      IF(INTG76.EQ.0) POPLE=.FALSE.
      IF(KTYPE(ISH).GT.2) POPLE=.FALSE.
      IF(KTYPE(JSH).GT.2) POPLE=.FALSE.
      IF(KTYPE(KSH).GT.2) POPLE=.FALSE.
      IF(KTYPE(LSH).GT.2) POPLE=.FALSE.
      IF(ZMIN.LT.ZTHRSH)  POPLE=.FALSE.
C
      IF(POPLE) THEN
         NORG = NORGP(IEXCH)
         CALL GENR70(IEXCH,SCHSKP)
      ELSE
         IF(PK  .AND.  IEXCH.EQ.1)
     *      CALL ZPKOUT(ISH,JSH,KSH,LSH,GHONDO,SKIPA,SKIPB,SKIPC,NPSYM)
         IF(SCHSKP) GO TO 820
C
C        ----- GET INFORMATION ABOUT ISH AND JSH -----
C        ----- FORM PAIRS OF PRIMITIVES FROM ISH AND JSH -----
C        ----- GET INFORMATION ABOUT KSH AND LSH -----
C
         NORG=0
         IF(PK) NORG=NORGH(IEXCH)
         CALL SHELLS(1,ISH,JSH,KSH,LSH,.TRUE.)
         CALL IJPRIM(DDIJ)
         IF(NIJ.EQ.0) GO TO 820
         CALL SHELLS(2,ISH,JSH,KSH,LSH,.TRUE.)
         IF(NOTPK) CALL ZQOUT(GHONDO)
C
C        ----- DO INTEGRAL BATCH, SSSS IS A SPECIAL CASE -----
C
         IF(IJKL.EQ.1) THEN
            CALL S0000(GHONDO,DDIJ)
         ELSE
            CALL GENRAL(GHONDO,DDIJ)
         END IF
      END IF
C
C        USE THE INTEGRALS JUST FORMED.  AT MOST, 1 OF THESE IS CALLED
C
      IF(DIRSCF) THEN
         IF(VECDIR) THEN
            CALL DIRFCKV(TYPSCF,IEXCH,POPLE,IA,DA,FA,DB,FB,GHONDO,
     *                   L2,NINT,NFLMAT)
         ELSE
            CALL DIRFCK(TYPSCF,IEXCH,POPLE,IA,DA,FA,DB,FB,GHONDO,
     *                  L2,NINT,NFLMAT)
         END IF
      ELSE IF(DIRCIS) THEN
         CALL DRFCIS(IEXCH,POPLE,DA,FA,DB,FB,GHONDO,
     *               L1,NINT,NFLMAT)
      ELSE IF(DIRNLO) THEN
         CALL DFCKNS(IEXCH,POPLE,DNLO,FNLO,GHONDO,L1,NINT,NFLMAT)
      ELSE IF(DIRTRF) THEN
         CALL DIRTRN(IEXCH,POPLE,BUFP,IX,NINTMX,GHONDO,ICONT,NINT)
      ELSE
         IF(NOTPK) CALL QOUT(IEXCH,POPLE,BUFP,IX,NINTMX,GHONDO)
      END IF
C
  820 CONTINUE
      GO TO (740,760,840),IEXCH
C
C     ----- WRITE THE PK INTEGRALS TO FILE (IS) -----
C
  840 CONTINUE
      IF(PK) CALL PKFILE(II,JJ,KK,LL,SKIPA,SKIPB,SKIPC,NPSYM,POPLE,
     *                   BUFP,BUFK,IX,NINTMX,GHONDO)
  860 CONTINUE
  880 CONTINUE
  900 CONTINUE
  920 CONTINUE
C
C     ----- END OF SHELL LOOPS -----
C
      IF(NXT  .AND.  GOPARR) CALL DDI_DLBRESET
C
C     ----- OUTPUT THE LAST BITS OF INTEGRALS -----
C
      IF(DIRTRF) CALL ONEIDX(BUFP,IX,ICONT)
      IF(.NOT.CMBDIR) THEN
         IF(SCHWRZ) THEN
            IF(GOPARR) CALL DDI_GSUMI(1055,NSCHWZ,1)
            IF(NPRINT.NE.-5 .AND. MASWRK) WRITE(IW,9020) NSCHWZ
         END IF
         CALL FINAL(1,II,II,II,II,PANDK,BUFP,BUFK,IX,NINTMX)
      END IF
      GOPARR = GPSAVE
      RETURN
C
 9010 FORMAT(1X,'II,JST,KST,LST =',4I3,' NREC =',I10,' INTLOC =',I5)
 9020 FORMAT(1X,'SCHWARZ INEQUALITY TEST SKIPPED',I10,
     *        ' INTEGRAL BLOCKS.')
 9030 FORMAT(//1X,'*** THIS JOB HAS EXHAUSTED ITS CPU TIME ***'/
     *         1X,'     (WHILE COMPUTING 2E- INTEGRALS)'///)
      END
C*MODULE INT2A   *DECK XYZINT
      SUBROUTINE XYZINT
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL N0,N1,M0,M1,FIRST1,FIRST2,FIRST3,FIRST4
C
      COMMON /SETINT/ I(9),K(9),NIMAX,NJMAX,NKMAX,NLMAX,NMAX,MMAX
     +               ,BP01,B00,B10,XCP00,XC00,YCP00,YC00,ZCP00,ZC00,F00
     +               ,DXIJ,DYIJ,DZIJ,DXKL,DYKL,DZKL
      COMMON /XYZ   / XINT(5625),YINT(5625),ZINT(5625)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      N0 = NMAX .EQ. 0
      N1 = NMAX .LE. 1
      M0 = MMAX .EQ. 0
      M1 = MMAX .LE. 1
C
C     ----- I(0,0) -----
C
      I1 = I(1)
      XINT(I1) = ONE
      YINT(I1) = ONE
      ZINT(I1) = F00
      IF (N0 .AND. M0) RETURN
      I2 = I(2)
      K2 = K(2)
      CP10 = B00
C
C     ----- I(1,0) -----
C
      IF (.NOT. N0) THEN
        XINT(I2) = XC00
        YINT(I2) = YC00
        ZINT(I2) = ZC00*F00
        IF (M0) GO TO 120
      END IF
C
C     ----- I(0,1) -----
C
      I3 = I1+K2
      XINT(I3) = XCP00
      YINT(I3) = YCP00
      ZINT(I3) = ZCP00*F00
C
C     ----- I(1,1) -----
C
      IF (.NOT. N0) THEN
        I3 = I2+K2
        XINT(I3) = XCP00*XINT(I2)+CP10
        YINT(I3) = YCP00*YINT(I2)+CP10
        ZINT(I3) = ZCP00*ZINT(I2)+CP10*F00
      END IF
C
  120 CONTINUE
      IF (.NOT. N1) THEN
        C10 = ZERO
        I3 = I1
        I4 = I2
        DO 160 N = 2,NMAX
          C10 = C10+B10
C
C     ----- I(N,0) -----
C
          I5 = I(N+1)
          XINT(I5) = C10*XINT(I3)+XC00*XINT(I4)
          YINT(I5) = C10*YINT(I3)+YC00*YINT(I4)
          ZINT(I5) = C10*ZINT(I3)+ZC00*ZINT(I4)
          IF ( .NOT. M0) THEN
            CP10 = CP10+B00
C
C     ----- I(N,1) -----
C
            I3 = I5+K2
            XINT(I3) = XCP00*XINT(I5)+CP10*XINT(I4)
            YINT(I3) = YCP00*YINT(I5)+CP10*YINT(I4)
            ZINT(I3) = ZCP00*ZINT(I5)+CP10*ZINT(I4)
          END IF
          I3 = I4
          I4 = I5
  160     CONTINUE
      END IF
      IF ( .NOT. M1) THEN
        CP01 = ZERO
        C01 = B00
        I3 = I1
        I4 = I1+K2
        DO 220 M = 2,MMAX
          CP01 = CP01+BP01
C
C     ----- I(0,M) -----
C
          I5 = I1+K(M+1)
          XINT(I5) = CP01*XINT(I3)+XCP00*XINT(I4)
          YINT(I5) = CP01*YINT(I3)+YCP00*YINT(I4)
          ZINT(I5) = CP01*ZINT(I3)+ZCP00*ZINT(I4)
C
C     ----- I(1,M) -----
C
          IF (.NOT. N0) THEN
            C01 = C01+B00
            I3 = I2+K(M+1)
            XINT(I3) = XC00*XINT(I5)+C01*XINT(I4)
            YINT(I3) = YC00*YINT(I5)+C01*YINT(I4)
            ZINT(I3) = ZC00*ZINT(I5)+C01*ZINT(I4)
          END IF
          I3 = I4
          I4 = I5
  220   CONTINUE
      END IF
C
C     ----- I(N,M) -----
C
      IF (.NOT. N1 .AND. .NOT. M1) THEN
        C01 = B00
        K3 = K2
        DO 280 M = 2,MMAX
          K4 = K(M+1)
          C01 = C01+B00
          I3 = I1
          I4 = I2
          C10 = B10
          DO 260 N = 2,NMAX
            I5 = I(N+1)
            XINT(I5+K4) = C10*XINT(I3+K4)+XC00*XINT(I4+K4)
     *                    +C01*XINT(I4+K3)
            YINT(I5+K4) = C10*YINT(I3+K4)+YC00*YINT(I4+K4)
     *                    +C01*YINT(I4+K3)
            ZINT(I5+K4) = C10*ZINT(I3+K4)+ZC00*ZINT(I4+K4)
     *                    +C01*ZINT(I4+K3)
            C10 = C10+B10
            I3 = I4
            I4 = I5
  260     CONTINUE
          K3 = K4
  280   CONTINUE
      END IF
C
C     ----- I(NI,NJ,M) -----
C
      IF (NJMAX .GT. 0) THEN
        M = 0
        I5 = I(NMAX+1)
        FIRST1 = .TRUE.
        DO 430 WHILE (FIRST1 .OR. M .LE. MMAX)
          MIN = NIMAX
          KM = K(M+1)
          FIRST2 = .TRUE.
          DO 360 WHILE (FIRST2 .OR. MIN .LT. NMAX)
            N = NMAX
            I3 = I5+KM
            FIRST3 = .TRUE.
            DO 340 WHILE (FIRST3 .OR. N .GT. MIN)
              I4 = I(N)+KM
              XINT(I3) = XINT(I3)+DXIJ*XINT(I4)
              YINT(I3) = YINT(I3)+DYIJ*YINT(I4)
              ZINT(I3) = ZINT(I3)+DZIJ*ZINT(I4)
              I3 = I4
              N = N-1
              FIRST3 = .FALSE.
  340       END DO
            MIN = MIN+1
            FIRST2 = .FALSE.
  360     END DO
          IF (NIMAX .GT. 0) THEN
            I3 = 25+KM+I1
            DO 400 NJ = 1,NJMAX
              I4 = I3
              DO 380 NI = 1,NIMAX
                XINT(I4) = XINT(I4+100)+DXIJ*XINT(I4-25)
                YINT(I4) = YINT(I4+100)+DYIJ*YINT(I4-25)
                ZINT(I4) = ZINT(I4+100)+DZIJ*ZINT(I4-25)
  380         I4 = I4+125
  400       I3 = I3+25
          END IF
          M = M+1
          FIRST1 = .FALSE.
  430   END DO
      END IF
C
C     ----- I(NI,NJ,NK,NL) -----
C
      IF (NLMAX .GT. 0) THEN
        I5 = K(MMAX+1)
        IA = I1
        NI = 0
        FIRST4 = .TRUE.
        DO 580 WHILE (FIRST4 .OR. NI .LE. NIMAX)
          NJ = 0
          IB = IA
          FIRST1 = .TRUE.
          DO 570 WHILE (FIRST1 .OR. NJ .LE. NJMAX)
            MIN = NKMAX
            FIRST2 = .TRUE.
            DO 530 WHILE (FIRST2 .OR. MIN .LT. MMAX)
              M = MMAX
              I3 = IB+I5
              FIRST3 = .TRUE.
              DO 520 WHILE (FIRST3 .OR. M .GT. MIN)
                I4 = IB+K(M)
                XINT(I3) = XINT(I3)+DXKL*XINT(I4)
                YINT(I3) = YINT(I3)+DYKL*YINT(I4)
                ZINT(I3) = ZINT(I3)+DZKL*ZINT(I4)
                I3 = I4
                M = M-1
                FIRST3 = .FALSE.
  520         END DO
              MIN = MIN+1
              FIRST2 = .FALSE.
  530       END DO
            IF (NKMAX .GT. 0) THEN
              I3 = IB+1
              DO 560 NL = 1,NLMAX
                I4 = I3
                DO 540 NK = 1,NKMAX
                  XINT(I4) = XINT(I4+4)+DXKL*XINT(I4-1)
                  YINT(I4) = YINT(I4+4)+DYKL*YINT(I4-1)
                  ZINT(I4) = ZINT(I4+4)+DZKL*ZINT(I4-1)
                  I4 = I4+5
  540           END DO
              I3 = I3+1
  560         END DO
            END IF
            NJ = NJ+1
            IB = IB+25
            FIRST1 = .FALSE.
  570     END DO
          NI = NI+1
          IA = IA+125
          FIRST4 = .FALSE.
  580   END DO
      END IF
C
      RETURN
      END
C*MODULE INT2A   *DECK ZPKOUT
      SUBROUTINE ZPKOUT(II,JJ,KK,LL,GHONDO,SKIPA,SKIPB,SKIPC,NPSYM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION GHONDO(*)
      DIMENSION IB(15),JB(15),KB(15),LB(15)
C
      LOGICAL SKIPA,SKIPB,SKIPC,NPSYM,IANDJ,KANDL,FIRST
C
      PARAMETER (MXSH=1000, MXGTOT=5000)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),MIN(MXSH),MAX(MXSH),NSHELL
C
      PARAMETER (ZERO=0.0D+00)
C
      SAVE FIRST,NORG1H,NORG2H,NORG3H,IB,JB,KB,LB
C
      DATA FIRST/.TRUE./
C
C     ----- ZERO HONDO PK INTEGRAL FORMATION REGION -----
C
      IF(FIRST) THEN
         FIRST=.FALSE.
         CALL BASCHK(LMAX)
                       NANGM =  4
         IF(LMAX.EQ.2) NANGM =  6
         IF(LMAX.EQ.3) NANGM = 10
         IF(LMAX.EQ.4) NANGM = 15
         NORG1H = 1
         NORG2H = NORG1H + NANGM**4
         NORG3H = NORG2H + NANGM**4
         DO 100 I=1,NANGM
            LB(I) = I-1
            KB(I) = LB(I) * NANGM
            JB(I) = KB(I) * NANGM
            IB(I) = JB(I) * NANGM
 100     CONTINUE
      END IF
C
      NORG1 = NORG1H
      NORG2 = NORG2H
      NORG3 = NORG3H
C
      LIT = KTYPE(II)
      MINI = MIN(II)
      MAXI = MAX(II)
      MINJ = MIN(JJ)
      MAXJ = MAX(JJ)
      LKT = KTYPE(KK)
      MINK = MIN(KK)
      MAXK = MAX(KK)
      MINL = MIN(LL)
      MAXL = MAX(LL)
      IANDJ = II .EQ. JJ
      KANDL = KK .EQ. LL
C
C     TYPE = 1 FOR (II II II II)
C            2     (II JJ JJ JJ)
C            3     (II II KK KK) AND  LIT.GE.LKT
C            4     (II II KK KK) AND  LIT.LT.LKT
C            5     (II II II LL)
C            6     (II JJ KK KK)
C            7     (II JJ JJ LL)
C            8     (II II KK LL)
C            9     (II JJ KK LL)
C
      NTYP = 0
      IF(II.EQ.JJ .AND. JJ.EQ.KK .AND. KK.EQ.LL) NTYP = 1
      IF(II.GT.JJ .AND. JJ.EQ.KK .AND. KK.EQ.LL) NTYP = 2
      IF(II.EQ.JJ .AND. JJ.GT.KK .AND. KK.EQ.LL
     *                         .AND. LIT.GE.LKT) NTYP = 3
      IF(II.EQ.JJ .AND. JJ.GT.KK .AND. KK.EQ.LL
     *                         .AND. LIT.LT.LKT) NTYP = 4
      IF(II.EQ.JJ .AND. JJ.EQ.KK .AND. KK.GT.LL) NTYP = 5
      IF(II.GT.JJ .AND. JJ.GT.KK .AND. KK.EQ.LL) NTYP = 6
      IF(II.GT.JJ .AND. JJ.EQ.KK .AND. KK.GT.LL) NTYP = 7
      IF(II.EQ.JJ .AND. JJ.GT.KK .AND. KK.GT.LL) NTYP = 8
      IF(II.GT.JJ .AND. JJ.GT.KK .AND. KK.GT.LL) NTYP = 9
C
      IF(SKIPA .AND. .NOT.NPSYM) NORG2 = 1
      IF(SKIPC .AND. .NOT.NPSYM) NORG3 = NORG2H
      IF(SKIPB .AND. .NOT.NPSYM) NORG3 = 1
C
C     ----- BEGIN LOOPS OVER PRIMITIVES IN THIS SHELL -----
C
C     INTEGRAL TYPES N1,G1 FOR (I,J//K,L)
C                    N2,G2 FOR (I,K//J,L)
C                    N3,G3 FOR (I,L//J,K)
C
C                      HONDO INTEGRALS
C        N1 = IB(IA)+JB(JA)+KB(KA)+LB(LA)+NORG1
C        N2 = IB(IA)+JB(KA)+KB(JA)+LB(LA)+NORG2
C
      JMAX = MAXJ
      KMAX = MAXK
      LMAX = MAXL
      DO 860 I = MINI,MAXI
      IA = I-MINI+1
      N1I = NORG1 + IB(IA)
      N2I = NORG2 + IB(IA)
C
      IF (IANDJ) JMAX = I
      DO 840 J = MINJ,JMAX
      IF (JJ .EQ. KK) KMAX = J
      JA = J-MINJ+1
      N1IJ = N1I + JB(JA)
      N2IJ = N2I + KB(JA)
C
      DO 820 K = MINK,KMAX
      KA = K-MINK+1
      N1IJK = N1IJ + KB(KA)
      N2IJK = N2IJ + JB(KA)
C
      IF (KANDL) LMAX = K
      DO 800 L = MINL,LMAX
      LA = L-MINL+1
      N1 = N1IJK + LB(LA)
      N2 = N2IJK + LB(LA)
C
      GO TO (200,220,230,250,270,280,290,300,310),NTYP
  200 IF (IA .EQ. JA) GO TO 210
      N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
      GO TO 400
  210 N3 = IB(JA)+JB(KA)+KB(IA)+LB(LA)+NORG3
      GO TO 400
  220 N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
      GO TO 400
  230 IF (IA .EQ. JA) GO TO 240
      N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
      GO TO 400
  240 N3 = IB(JA)+JB(KA)+KB(IA)+LB(LA)+NORG3
      GO TO 400
  250 IF (KA .EQ. LA) GO TO 260
      N3 = IB(JA)+JB(KA)+KB(IA)+LB(LA)+NORG3
      GO TO 400
  260 N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
      GO TO 400
  270 N3 = IB(JA)+JB(KA)+KB(IA)+LB(LA)+NORG3
      GO TO 400
  280 N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
      GO TO 400
  290 N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
      GO TO 400
  300 N3 = IB(JA)+JB(KA)+KB(IA)+LB(LA)+NORG3
      GO TO 400
  310 N3 = IB(IA)+JB(LA)+KB(JA)+LB(KA)+NORG3
C
  400 CONTINUE
      GHONDO(N1) = ZERO
      GHONDO(N2) = ZERO
      GHONDO(N3) = ZERO
  800 CONTINUE
  820 CONTINUE
  840 CONTINUE
  860 CONTINUE
      RETURN
      END
C*MODULE INT2A   *DECK ZQOUT
      SUBROUTINE ZQOUT(GHONDO)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION GHONDO(*)
C
      LOGICAL IANDJ,KANDL,SAME
C
      COMMON /INTDEX/ IJGT(225),IJX(225),IJY(225),IJZ(225),IK(225),
     *                KLGT(225),KLX(225),KLY(225),KLZ(225)
      COMMON /MISC  / IANDJ,KANDL,SAME
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     *                NIJX,IJ,KL,IJKL
C
      PARAMETER (ZERO=0.0D+00)
C
C     ----- ZERO HONDO CONVENTIONAL INTEGRAL OUTPUT REGION -----
C
      IJN = 0
      JMAX = MAXJ
      DO 260 I = MINI,MAXI
         IF (IANDJ) JMAX = I
         DO 240 J = MINJ,JMAX
            IJN = IJN+1
            N1 = IJGT(IJN)
            LMAX = MAXL
            KLN = 0
            DO 220 K =  MINK,MAXK
               IF (KANDL) LMAX = K
               DO 200 L = MINL,LMAX
                  KLN = KLN+1
                  IF (SAME .AND. KLN .GT. IJN) GO TO 240
                  NN = N1+KLGT(KLN)
                  GHONDO(NN) = ZERO
  200          CONTINUE
  220       CONTINUE
  240    CONTINUE
  260 CONTINUE
      RETURN
      END
C*MODULE INT2A  DIRFCKV
      SUBROUTINE DIRFCKV(TYPSCF,IEXCH,POPLE,IA,DA,FA,DB,FB,GHONDO,
     *                   L2,NINT,NFLMAT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL POPLE
      DIMENSION IA(*),DA(*),FA(*),DB(*),FB(*),GHONDO(*)
C
C        JUST A DUMMY, AS SCALAR RUNS SHOULD NEVER GET TO HERE
C        THE REAL ROUTINE IS IN VECTOR.SRC
C        THE REAL ROUTINE SHOULD HAVE UHF,ROHF,GVB IMPLEMENTED
C        SO THAT IT CAN HAVE THE SAME NAME (NO V) AS DIRFCK
C
C        THE REST OF THIS ROUTINE IS TO AVOID FTNCHEK ERRORS
C
      SUM = DA(1) + DB(1) + FA(1) + FB(1) + GHONDO(1)
      ISUM = IA(1) + L2 + NINT + NFLMAT + IEXCH
      WRITE(6,900) TYPSCF,SUM,ISUM,POPLE
      CALL ABRT
      STOP
  900 FORMAT(1X,'SHOULD NOT BE IN -DIRFCKV- ',A8,F10.2,I6,L3)
      END

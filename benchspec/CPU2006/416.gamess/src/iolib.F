C  9 DEC 03 - OQ  - RAISE MXUNIT FROM 100 TO 299 (THIS IS BAD FOR F2C)
C  4 NOV 03 - DGF - DAREAD,DAWRIT: ALLOW EACH NODE TO HAVE ITS OWN DAF
C  3 SEP 03 - MWS - RAOPEN,RACLOS,CCOPEN,SEQOPN,SEQCLO: MAX. FILE NUMBER
C  3 JUL 03 - JMM - SUPPRESS PRINTING FOR MONTE CARLO JOBS
C 12 DEC 02 - MWS - DAREAD: IMPROVED ERROR HANDLING/MESSAGES
C 17 APR 02 - MWS - SYNCH UP FRGINF COMMON
C 26 MAR 02 - MWS - ADD ROUTINE TO OPEN CC DIRECT ACCESS FILES
C  6 SEP 01 - HU  - PREADP: CORRECT LABEL READING LENGTHS
C 20 FEB 01 - PND - PUVIB: ADITIONAL PRINT OUT CONTROL
C 21 DEC 99 - DGF - RAOPEN,RAOPEN2: PHYSICAL RECORD SIZE CHANGES
C 12 NOV 98 - GDF - PREAD,PKREAD,PWRIT,PKWRIT: CHOOSE INT. LENGTHS
C 27 SEP 98 - MWS - RAOPEN: CHANGE FORMAT FIELD WIDTH
C 27 FEB 98 - AL  - PARENV: STRIP OF PATH NAME MADE MORE OPTIONAL
C  6 JAN 98 - MWS - RAOPEN: PASS CORRECT FILE NAMES TO OTHER NODES
C 14 OCT 97 - DGF - ADD RAWRITE ROUTINE
C 28 SEP 97 - MWS - CONVERT PARALLEL CALLS FROM TCGMSG TO DDI
C  2 SEP 97 - MWS - PKWRIT,PWRIT1,PWRIT2,PXWRIT,SQWRIT,SEQREW,
C                   PKREAD,PREAD1,PREAD2,PXREAD: ADD ERROR BRANCHES
C 16 JUL 97 - GNM - PUVIB: CHANGE FOR FRAGONLY OPTION
C 10 JUL 97 - MWS - SQREAD: ERROR BRANCH LEADS TO JOB TERMINATION
C  7 FEB 97 - MWS - DAREAD,DAWRIT: IMPROVE ERROR MESSAGE CONTENT
C  6 NOV 96 - MWS - ADD MQOPDA,MQDARE,MQDAWR
C 30 OCT 96 - HN  - SEQOPN,SEQCLO: ALLOW UNIT NUMBERS TO 99
C 24 MAY 96 - GMC - RAOPEN: CHANGE FILE NAME TO MCDIIS FOR UNIT 30
C  3 JAN 96 - MWS - BRING XABI'S THREE DUMMY ROUTINES HERE
C 24 MAY 95 - MWS - INCLUDE NEW PREADP ROUTINE
C 21 APR 95 - MWS - SEQCLO,SEQOPN: AVOID REPEAT OPEN REQUESTS
C 17 NOV 94 - WC  - PUVIB: FRAGMENT RELATED CHANGES
C 10 NOV 94 - MWS - REMOVE SOME FTNCHEK WARNINGS
C 11 AUG 94 - MWS - INCREASE NUMBER OF DAF RECORDS
C  4 AUG 94 - MWS - PREAD,PWRIT: ALLOW DOUBLE LABELS
C 31 MAY 94 - PRD - PUVIB: ADD FRAGMENT OUTPUT
C  4 JAN 94 - MWS - FIX RA ROUTINES TO WORK ON ALL NODES
C 16 JUL 93 - MWS - ADD PXREAD ROUTINE
C  5 JUN 92 - TLW - ADD ROUTINE PARENV; CHANGE ROUTINE ADVFIL TO SEQFIL;
C                   MAKE SEQENTIAL DISK OPS WORK ON DIFFERENT NODES
C  3 APR 92 - TLW - DAREAD/WRIT: ACCOUNT FOR PURELY INTEGER RECORDS
C  2 MAR 92 - TLW - SQREAD: BROADCAST INFORMATION
C 21 FEB 92 - TLW - RARD: BROADCAST INFORMATION
C  3 FEB 92 - TLW - DARD: BROADCAST DAF INFORMATION
C 30 JAN 92 - TLW - OPENDA: BROADCAST OLD DAF INFORMATION IF NEEDED
C 11 JAN 92 - TLW - MAKE READS PARALLEL
C 10 JAN 92 - TLW - MAKE NEW ROUTINE SEQREW
C 10 JAN 92 - TLW - MAKE OPENS AND CLOSES PARALLEL
C 10 JAN 92 - TLW,MWS - DELETE OPEN ROUTINES OPENCI,OPENCF,OPENDF,
C                   OPENFM,OPENIP,OPENIR,OPENIS,OPENIW,OPENJK,OPENPK,
C                   OPNIRC TO USE GENERIC SEQOPN; SEQCLO REPLACED CLOSJK
C  7 JAN 92 - TLW - MAKE WRITES PARALLEL; ADD COMMON PAR
C 18 NOV 91 - MWS,JHJ - SEQOPN:INTRODUCED FROM UTILS.CODE.
C 19 JAN 90 - MWS - INITIALIZE FILENM IN OPENIW IN UNIX SECTION
C 21 DEC 89 - STE - ADD ERROR MESSAGES TO PKREAD,PREAD
C 26 SEP 89 - MWS - ADD NFT13,NFT14 TO /CIFILS/
C 12 APR 89 - STE - ADD FILE CIINTS (NFT14) TO OPENCI
C 28 MAR 89 - MWS - RAOPEN RETURNS W/O OPENING IF EXETYP.EQ.CHECK
C 25 FEB 89 - MWS - USE FLSHBF IN PUVIB, LOWER CASE CTSS SUFFIXES
C 27 JAN 89 - MWS - OPENCI OPENS A FILE ONLY IF ITS LRECL IS NONZERO
C 18 JAN 89 - MWS - ADD ROUTINE OPENDF, DELETE RDGRD AND WRTGRD
C 14 NOV 88 - MWS - PKREAD,PKWRIT,PREAD,PWRIT: NX,IX BEFORE XP,XK VALUES
C  7 OCT 88 - MWS - ADD NEW ROUTINE OPENFM
C  1 APR 88 - MWS - INCREASE NON-IBM RECORD SIZES FOR DASORT
C                   TO VAX MAXIMUM OF 2047 W.P. WORDS.
C 15 MAR 88 - MWS - ALTER IBM CLOSE IN RAOPEN, FIX VAX LDAR IN RASIZE
C 29 FEB 88 - STE - ADD FPS INFO TO OPENCF
C 18 FEB 88 - MWS - ADD NEW ROUTINE OPENCF
C 11 JAN 88 - MWS - ADD DIPOLE TO $VIB OUTPUT GROUP
C  2 NOV 87 - STE - CHANGE VAX RECL TO WORK WITH REMOTE DISKS
C 24 AUG 87 - STE - OPENJK: FIX FPS TO WORK LIKE OTHER FILES
C  6 AUG 87 - MWS - INCLUDE ETA VERSION
C 26 JUN 87 - MWS - DON'T PRINT FORCE RESTART DATA IN PUVIB
C  5 MAY 87 - STE - PUVIB: DIMENSION BLANK,VIBWRD
C 12 APR 87 - MWS - ROUTINE PUVIB TRANSFERRED FROM FORCE MODULE
C 15 OCT 86 - MWS - ADD CRAY/CTSS SPECIFIC INSTRUCTIONS IN ORDER
C                   TO BUILD UNIQUE FILENAMES UNDER CTSS
C 13 OCT 86 - MWS - USE IDMY IN DAWRIT COMMON TO AVOID ARG COLLISIONS
C 14 AUG 86 - MWS - REMOVE MULTIPLE FILE OPTION STUFF FOR IBM
C                   IN PREAD,PWRIT,PKREAD,PKWRIT,   ADD ROUTINE OPNIRC
C  1 AUG 86 - MWS - OBTAIN FILE NAME FROM THE ENVIRONMENT FOR CELERITY
C  9 JUL 86 - MWS - OPEN/CLOSE STATEMENTS FOR CELERITY AND CRAY,
C                   SANITIZE FLOATING POINT CONSTANTS, MOVE ROUTINES
C                   ABRT,MCHPAR,SECOND,TMDATE TO MODULE GAMESS
C 11 JUN 86 - MWS - WRITE CORRECT ERROR MESSAGE IN DAWRIT
C 25 APR 86 - LAM - OPEN IP WITH CC='LIST' IN OPENIP ON THE VAX
C 16 APR 86 - LAM - CHANGE FORMAT STATEMENT IN RAOPEN
C 26 FEB 86 - LAM - FIX PKREAD AND PWRIT TO READ INTEGRALS PROPERLY
C                   FROM MORE THAN ONE FILE
C 13 FEB 86 - LAM - PKREAD, PKWRIT, PREAD, PWRIT CHANGED TO HANDLE
C                   MULTIPLE (TAPE) FILES FOR IBM
C 31 JAN 86 - LAM - DEFINE LOCAL VARIABLE FIRLCL IN SECOND
C 13 NOV 85 - STE - FPS COMMAND LINE CONTROL OF FILES
C 26 OCT 85 - STE - TMDATE: FPS CAN GET DATE NOW
C 23 OCT 85 - STE - OPENCI: CHANGE CALL
C  9 SEP 85 - STE - FIX FPS OPEN IN OPENIS; CHANGE 700 IN RACLOS TO 7
C                   ADD /IOFILE/ FOR FPS IN OPENCI
C  6 SEP 85 - LAM - IRECLN=512 IN OPENDA, IRECLN=4094 IN RAOPEN
C                   AND LDAR=4090 IN RASIZE (IBM)
C 12 JUL 85 - MWS - 7 CHAR FILENAMES, JKFILE UNKOWN, KNOWN
C                   DON'T OPEN IBM FT06F001
C 30 MAY 85 - MWS - ADD NPRINT ARGUMENT TO RAOPEN
C 15 APR 85 - MWS - PUT ERR= BRANCH IN RACLOS
C 10 APR 85 - MWS - REMOVE VAX RECL= FROM OPENCI
C 15 MAR 85 - MWS - ADD ROUTINE RASIZE TO SET LDAR
C 10 MAR 85 - MWS - ADD ROUTINE OPENCI,OPENJK,SEQCLO,
C                   CONVERT IBM VERSION TO VS FORTRAN OPEN/CLOSES,
C 22 AUG 84 - STE - REMOVE UNUSED PARAMETER N FROM MSREAD/WRITE
C 21 JUL 84 - STE - ADD IS,IPK TO UNIT10 REC=1 IN DAWRIT,OPENDA
C 15 MAY 84 - STE - FPS TRACEBACK IN ABRT
C 28 APR 84 - STE - FIX MSREAD,MSWRIT TO ALLOW RESTARTS
C 26 MAR 84 - STE - ALLOW RUN-TIME ACCESS TO OPEN STATEMENTS
C 23 FEB 84 - STE - INCLUDE PXWRIT
C  2 FEB 84 - STE - REMOVE REWRITE LENGTH CHECK FROM RAWRIT
C 21 JAN 84 - STE - OPEN VAX INPUT READONLY, SHARED
C 17 JAN 84 - STE - EVALUATE ELAPSED REAL TIME IN SECOND
C 10 JAN 84 - STE - CHANGE STATUS=NEW TO STATUS=UNKNOWN, EXCEPT IW
C 28 DEC 83 - STE - REMOVE INTEGER*2 IN P/PK-READ/WRIT
C 27 DEC 83 - STE - ADD ROUTINES SQREAD AND SQWRIT
C 19 DEC 83 - STE - SAVE TIME FROM INITIAL CALL TO SECOND FOR VAX
C 15 DEC 83 - STE - ADD LRECL TO OPENIS, OPENPK
C  1 DEC 83 - STE - FIX NWDVAR INDEXING IN MSREAD,MSWRIT,RDGRD,WRTGRD
C 29 NOV 83 - STE - FPS CONVERSION; CHANGE OPENDA,RAOPEN
C 21 NOV 83 - STE - FPS CONVERSION; ADD OPENIP AND OPENPK
C  5 NOV 83 - STE - INCLUDE ABRT,MCHPAR,SECOND,TMDATE FROM IBMLIB
C                   FIX VAX I/O, INITIALIZE IBM TIME CORRECTLY
C                   INSERT CORRECT TMDATE FOR VAX
C                   DELETE BUFINT,DARTRN,REWBF,UNPACK
C 13 MAY 83 - STE - INITIALIZE IBM TIMES TO ZERO.
C  8 MAY 83 - MWS - IOLIB FORMED FROM PIECES OF
C                   GAMESS, IBMLIB, AND CILIB.
C  2 NOV 82 - MWS - DEFINE FILE STATEMENT MADE FOR WORST CASE
C 29 SEP 82 - MWS - CONVERT FOR IBM
C
C   IN THIS FILE,
C       *IBM REFERS TO IBM MAINFRAMES RUNNING MVS OR VM (NOT RS/6000)
C       *VMS REFERS TO VAX OR AXP RUNNING VMS OPERATING SYSTEM
C       *UNX REFERS TO EVERYTHING ELSE, RUNNING A UNIX O/S
C
C*MODULE IOLIB   *DECK CHGMIU
      SUBROUTINE CHGMIU(IR,IW)
      RETURN
      END
C*MODULE IOLIB   *DECK CHMDAT
      SUBROUTINE CHMDAT(AATOM,AZNUC,CORD,NAT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*10 AATOM(*)
      DIMENSION AZNUC(*),CORD(*)
      RETURN
      END
C*MODULE IOLIB   *DECK FDNAI
      DOUBLE PRECISION FUNCTION FDNAI(PLAMBDA,AI,AJ,
     *                                L1A,M1A,N1A,L2B,M2B,N2B,
     *                                XI,YI,ZI,XJ,YJ,ZJ,CX,CY,CZ)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C        THESE THREE ROUTINES IMPLEMENT THE SCREENED INTEGRAL
C        METHOD OF JOSE UGALDE AND XABI LOPEZ, WHICH IS NOT
C        AT PRESENT IN THE STANDARD GAMESS CODE.
C
      FDNAI = 0.0D+00
      RETURN
      END
C*MODULE IOLIB   *DECK STWOEI
      SUBROUTINE STWOEI(SCFTYP,DIRSCF,DIRNLO,DIRTRF,
     *               INTG76,SCHWRZ,NINT,NSCHWZ,L1,L2,
     *               BUFP,BUFK,IBUF,NINTMX,
     *               XINTS,NSH2,GHONDO,MAXG,DDIJ,
     *               IA,DA,FA,DB,FB,DSH,DNLO,FNLO)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      RETURN
      END
C*MODULE IOLIB   *DECK INITFCTS
      SUBROUTINE INITFCTS
      RETURN
      END
C*MODULE IOLIB   *DECK DARD
      SUBROUTINE DARD(V,LEN,IDAF,NS,IDTYP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION V(LEN)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C       READ A PHYSICAL RECORD FROM THE DAF
C
      IF (MASWRK) READ (UNIT=IDAF, REC=NS) V
      ITYP = 100 + IDAF
      IF (GOPARR) THEN
         IF (IDTYP.NE.1) THEN
            CALL DDI_BCAST(ITYP,'F',V,LEN,MASTER)
         ELSE
            CALL DDI_BCAST(ITYP,'I',V,NWDVAR*LEN,MASTER)
         END IF
      END IF
      RETURN
      END
C*MODULE IOLIB   *DECK DAREAD
      SUBROUTINE DAREAD(IDAF,IODA,V,LEN,NREC,IDTYP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(LEN),IODA(400)
C
      COMMON /DAIOLN/ IRECLN,IRECST,IFILEN(400)
      COMMON /IOFILE/ IR,IW,IP,IIS,IPK,IIDAF,NAV,IIODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C         READ A LOGICAL RECORD FROM THE DAF DICTIONARY FILE
C         A LOGICAL RECORD MAY SPAN SEVERAL PHYSICAL RECORDS.
C
C         CALLING ARGUMENT -IDTYP- IS 0 OR 1 FOR FLOATING POINT
C         OR INTEGER RECORDS.  NO OTHER DATA TYPE IS ALLOWED!
C         RECORDS MUST BE PURELY FLOATING POINT OR PURELY INTEGER.
C         NO MATTER WHAT -IDTYP- IS, THE -LEN- OF THE RECORD
C         MUST BE GIVEN IN TERMS OF FLOATING POINT WORDS.  IN
C         TURN, THIS MEANS THAT INTEGER RECORDS ON 32 BIT MACHINES
C         MUST CONTAIN AN EVEN NUMBER OF INTEGERS.
C
      IF(IDAF.NE.10) THEN
         CALL RAREAD(IDAF,IODA,V,LEN,NREC,NAV)
         RETURN
      ENDIF
C
      N = IODA(NREC)
      IF(N.EQ.-1) GO TO 800
C
C         TRAP TOO LARGE READS, PERMITTING READS WITH SIZES
C         BETWEEN 1 AND THE AVAILABLE RECORD TO PROCEED.
C
      IF(LEN.LE.0           ) GO TO 810
      IF(LEN.GT.IFILEN(NREC)) GO TO 820
C
      IS = -IRECLN + 1
      NS = N
      LENT = LEN
  100 CONTINUE
         IS = IS + IRECLN
         IF = IS + LENT - 1
         IF ((IF-IS+1) .GT. IRECLN) IF = IS + IRECLN - 1
         NSP = NS
         LENW = IF - IS + 1
         CALL DARD(V(IS),LENW,IDAF,NSP,IDTYP)
         LENT = LENT - IRECLN
         NS = NS + 1
         N = NS
      IF (LENT .GE. 1) GO TO 100
      RETURN
C
  800 CONTINUE
      IF(MASWRK) WRITE(IW,9000) NREC,LEN
      GO TO 890
  810 CONTINUE
      IF(MASWRK) WRITE(IW,9010) NREC,LEN
      GO TO 890
  820 CONTINUE
      IF(MASWRK) WRITE(IW,9020) LEN,NREC,IFILEN(NREC)
      GO TO 890
C
  890 CONTINUE
      IF(MASWRK) WRITE(IW,9090)
      CALL ABRT
      RETURN
C
 9000 FORMAT(/1X,'ERROR *** ATTEMPTING A BOGUS READ OF A DAF RECORD.'/
     *       1X,'RECORD NUMBER',I5,' OF LENGTH',I10,
     *          ' WAS NEVER PREVIOUSLY WRITTEN.')
 9010 FORMAT(/1X,'ERROR *** ATTEMPTING A BOGUS READ OF A DAF RECORD.'/
     *       1X,'RECORD NUMBER',I5,' OF LENGTH',I10,' HAS NO LENGTH.')
 9020 FORMAT(/1X,'ERROR *** ATTEMPTING A BOGUS READ OF A DAF RECORD.'/
     *       1X,'ATTEMPTING TO READ',I10,' WORDS FROM RECORD NUMBER',I5/
     *       1X,'BUT THIS RECORD WAS PREVIOUSLY WRITTEN WITH ONLY',
     *          I10,' WORDS.')
 9090 FORMAT(/1X,'THIS ERROR IS LIKELY TO BE A BUG IN THE PROGRAM, BUT'/
     *       1X,'PLEASE CONSIDER INPUT ERRORS AS A POSSIBLE',
     *          ' CAUSE, TOO.'/
     *       1X,'MANUAL CHAPTER -PROG.DOC- HAS A LIST OF ALL',
     *          ' DIRECT ACCESS FILE RECORD NUMBERS,'/
     *       1X,'WHICH WILL HELP YOU UNDERSTAND WHAT THE INCORRECT',
     *          ' DATA IS SUPPOSED TO BE.'/)
      END
C*MODULE IOLIB   *DECK DAWRIT
      SUBROUTINE DAWRIT(IDAF,IODA,V,LEN,NREC,IDTYP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL NEWREC,GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(LEN),IODA(400)
C
      COMMON /DAIOLN/ IRECLN,IRECST,IFILEN(400)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IIDAF,NAV,IIODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IF(IDAF.LT.0) WRITE(6,*) 'BOGUS DAWRIT, IDTYP=',IDTYP
C
C         WRITE A LOGICAL RECORD ON THE DAF DICTIONARY FILE
C         A LOGICAL RECORD MAY SPAN SEVERAL PHYSICAL RECORDS
C
      IF(IDAF.NE.10) THEN
         CALL RAWRIT(IDAF,IODA,V,LEN,NREC,NAV)
         RETURN
      ENDIF
C
      N = IODA(NREC)
      IF (N .GT. 0 .AND. LEN .NE. IFILEN(NREC)) GO TO 800
C
      NEWREC = .FALSE.
      IF (N .GT. 0) GO TO 100
      IODA(NREC) = IRECST
      IFILEN(NREC) = LEN
      NEWREC = .TRUE.
      IRECST = IRECST + (LEN-1)/IRECLN + 1
      N = IODA(NREC)
  100 CONTINUE
      IST = -IRECLN + 1
      NS = N
      LENT = LEN
  120 CONTINUE
         IST = IST + IRECLN
         IF = IST + LENT - 1
         IF ((IF-IST+1) .GT. IRECLN) IF = IST+IRECLN-1
         NSP = NS
         LENW = IF - IST + 1
         CALL DAWRT(V(IST),LENW,IDAF,NSP)
         LENT = LENT - IRECLN
         NS = NS + 1
         N = NS
      IF (LENT .GE. 1) GO TO 120
      IF (NEWREC .AND. MASWRK)
     *      WRITE(UNIT=IDAF,REC=1) IRECST,IODA,IFILEN,IS,IPK
      RETURN
C
  800 CONTINUE
      WRITE (IW,9008) ME,NREC,LEN,IFILEN(NREC)
      CALL ABRT
      RETURN
C
 9008 FORMAT(1X,'*** ERROR *** IN -DAWRIT- ROUTINE ON NODE',I4/
     *       1X,'DAWRIT HAS REQUESTED A RECORD WITH LENGTH',
     *       1X,'DIFFERENT THAN BEFORE - ABORT FORCED.'/
     *       1X,'DAF RECORD ',I5,' NEW LENGTH =',I10,
     *                           ' OLD LENGTH =',I10)
      END
C*MODULE IOLIB   *DECK DAWRT
      SUBROUTINE DAWRT(V,LEN,IDAF,NS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION V(LEN)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- WRITE A PHYSICAL RECORD ON THE DAF -----
C
      IF (MASWRK) WRITE (UNIT=IDAF, REC=NS) V
      RETURN
      END
C*MODULE IOLIB   *DECK OPENDA
      SUBROUTINE OPENDA(IREST)
C
C     - - - - OPEN MASTER DICTIONARY FILE 10 - - - -
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      CHARACTER*256 FILENM
C
      COMMON /DAIOLN/ IRECLN,IRECST,IFILEN(400)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IDAF = 10
      IRECLN=NRASIZ(IDAF)
C
      IF (MASWRK) THEN
C
*IBM  OPEN (UNIT=IDAF, FILE='DICTNRY', STATUS='UNKNOWN',
*IBM *      ACCESS='DIRECT', FORM='UNFORMATTED', RECL=8*IRECLN)
C
#if defined(SPEC_CPU)
      CALL DUMMYGETENV('DICTNRY',FILENM)
#else
      CALL GETENV('DICTNRY',FILENM)
#endif
      OPEN (UNIT=IDAF, FILE=FILENM, STATUS='UNKNOWN',
     *      ACCESS='DIRECT', FORM='UNFORMATTED',
     *      RECL=8*IRECLN)
C
*VMS  OPEN (UNIT=IDAF, FILE='DICTNRY', STATUS='UNKNOWN',
*VMS *      ACCESS='DIRECT', FORM='UNFORMATTED', RECL=2*IRECLN)
C
      END IF
C
C     ----- IS THIS A NEW OR OLD DAF FILE? -----
C     EITHER MARK THE NEW DAF RECORDS AS EMPTY
C     OR ELSE LOAD THE OLD DAF DIRECTORY
C
      IF(IREST.EQ.0) THEN
         IRECST = 1
         DO 100 I = 1,400
            IODA(I) = -1
  100    CONTINUE
         IRECST = IRECST + 1
         IF(MASWRK) WRITE(UNIT=IDAF, REC=1) IRECST,IODA,IFILEN,IS,IPK
      ELSE
         IF(MASWRK) READ (UNIT=IDAF, REC=1) IRECST,IODA,IFILEN,IS,IPK
         IF(GOPARR) THEN
            CALL DDI_BCAST(200,'I',IRECST,1,MASTER)
            CALL DDI_BCAST(201,'I',IODA,400,MASTER)
            CALL DDI_BCAST(202,'I',IFILEN,400,MASTER)
            CALL DDI_BCAST(203,'I',IS,1,MASTER)
            CALL DDI_BCAST(204,'I',IPK,1,MASTER)
         END IF
      END IF
      RETURN
      END
C*MODULE IOLIB   *DECK MQDARE
      SUBROUTINE MQDARE(IDAF,IODA,V,LEN,NREC,IDTYP)
C     FROM       DAREAD(IDAF,IODA,V,LEN,NREC,IDTYP)
C==================================================
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(LEN),IODA(400)
C
C==== MODIFIE BY H.NAKANO ON 8/15/96 ======================
C     COMMON /DAIOLN/ IRECLN,IRECST,IFILEN(400)
C     COMMON /IOFILE/ IR,IW,IP,IIS,IPK,IIDAF,NAV,IIODA(400)
      COMMON /MQDAIO/ IRECLN,IRECST,IFILEN(400)
      COMMON /IOFILE/ IR,IW,IP,IIS,IPK,IDAFX,NAVX,IODAX(400)
C==========================================================
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C         READ A LOGICAL RECORD FROM THE DAF DICTIONARY FILE
C         A LOGICAL RECORD MAY SPAN SEVERAL PHYSICAL RECORDS.
C
C         CALLING ARGUMENT -IDTYP- IS 0 OR 1 FOR FLOATING POINT
C         OR INTEGER RECORDS.  NO OTHER DATA TYPE IS ALLOWED!
C         RECORDS MUST BE PURELY FLOATING POINT OR PURELY INTEGER.
C         NO MATTER WHAT -IDTYP- IS, THE -LEN- OF THE RECORD
C         MUST BE GIVEN IN TERMS OF FLOATING POINT WORDS.  IN
C         TURN, THIS MEANS THAT INTEGER RECORDS ON 32 BIT MACHINES
C         MUST CONTAIN AN EVEN NUMBER OF INTEGERS.
C
      N = IODA(NREC)
      IF(N.EQ.-1) GO TO 800
      IS = -IRECLN + 1
      NS = N
      LENT = LEN
  100 CONTINUE
         IS = IS + IRECLN
         IF = IS + LENT - 1
         IF ((IF-IS+1) .GT. IRECLN) IF = IS + IRECLN - 1
         NSP = NS
         LENW = IF - IS + 1
         CALL DARD(V(IS),LENW,IDAF,NSP,IDTYP)
         LENT = LENT - IRECLN
         NS = NS + 1
         N = NS
      IF (LENT .GE. 1) GO TO 100
      RETURN
C
  800 CONTINUE
      IF (MASWRK) WRITE(IW,9000) NREC,LEN
      CALL ABRT
      RETURN
C
 9000 FORMAT(1X,'*** ERROR ***, ATTEMPT TO READ A -MCQD50- RECORD',
     *         ' THAT WAS NEVER WRITTEN.'/1X,'NREC,LEN=',I5,I10)
      END
C*MODULE IOLIB   *DECK MQDAWR
      SUBROUTINE MQDAWR(IDAF,IODA,V,LEN,NREC,IDTYP)
C     FROM       DAWRIT(IDAF,IODA,V,LEN,NREC,IDTYP)
C==================================================
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL NEWREC,GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(LEN),IODA(400)
C
C==== MODIFIED BY H.NAKANO ON 8/15/96 ====================
C     COMMON /DAIOLN/ IRECLN,IRECST,IFILEN(400)
C     COMMON /IOFILE/ IR,IW,IP,IS,IPK,IIDAF,NAV,IIODA(400)
      COMMON /MQDAIO/ IRECLN,IRECST,IFILEN(400)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAFX,NAVX,IODAX(400)
C=========================================================
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C         WRITE A LOGICAL RECORD ON THE DAF DICTIONARY FILE
C         A LOGICAL RECORD MAY SPAN SEVERAL PHYSICAL RECORDS
C
      IF(IDAF.LT.0) WRITE(6,*) 'BOGUS DAWRIT, IDTYP=',IDTYP
C
      N = IODA(NREC)
      IF (N .GT. 0 .AND. LEN .NE. IFILEN(NREC)) GO TO 800
      NEWREC = .FALSE.
      IF (N .GT. 0) GO TO 100
      IODA(NREC) = IRECST
      IFILEN(NREC) = LEN
      NEWREC = .TRUE.
      IRECST = IRECST + (LEN-1)/IRECLN + 1
      N = IODA(NREC)
  100 CONTINUE
      IST = -IRECLN + 1
      NS = N
      LENT = LEN
  120 CONTINUE
         IST = IST + IRECLN
         IF = IST + LENT - 1
         IF ((IF-IST+1) .GT. IRECLN) IF = IST+IRECLN-1
         NSP = NS
         LENW = IF - IST + 1
         CALL DAWRT(V(IST),LENW,IDAF,NSP)
         LENT = LENT - IRECLN
         NS = NS + 1
         N = NS
      IF (LENT .GE. 1) GO TO 120
      IF (NEWREC .AND. MASWRK)
     *      WRITE(UNIT=IDAF,REC=1) IRECST,IODA,IFILEN,IS,IPK
      RETURN
C
  800 CONTINUE
      IF (MASWRK) WRITE (IW,9008) NREC,LEN,IFILEN(NREC)
      CALL ABRT
      RETURN
C
 9008 FORMAT(1X,'MQDAWR HAS REQUESTED A RECORD WITH LENGTH',
     *       1X,'DIFFERENT THAN BEFORE - ABORT FORCED.'/
     *       1X,'MCQD50 RECORD ',I5,' NEW LENGTH =',I5,
     *          ' OLD LENGTH =',I5)
      END
C*MODULE IOLIB   *DECK MQOPDA
      SUBROUTINE MQOPDA(IREST)
C=====================================================
C     A VARIANT OF OPENDA CREATED BY H. NAKANO 8/14/96
C=====================================================
C
C     - - - - OPEN RANDOM ACCESS FILE - - - -
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      CHARACTER*256 FILENM
C
      COMMON /MQDAIO/ IRECLN,IRECST,IFILEN(400)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAFX,NAVX,IODAX(400)
      COMMON /MQIOFI/                 IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
*IBM  IRECLN = 512
      IRECLN = 1023
*VMS  IRECLN = 512
C
      IF (MASWRK) THEN
C
*IBM  OPEN (UNIT=IDAF, FILE='MCQD50', STATUS='UNKNOWN',
*IBM *      ACCESS='DIRECT', FORM='UNFORMATTED', RECL=8*IRECLN)
C
#if defined(SPEC_CPU)
      CALL DUMMYGETENV('MCQD50',FILENM)
#else
      CALL GETENV('MCQD50',FILENM)
#endif
      OPEN (UNIT=IDAF, FILE=FILENM, STATUS='UNKNOWN',
     *      ACCESS='DIRECT', FORM='UNFORMATTED',
     *      RECL=8*IRECLN)
C
*VMS  OPEN (UNIT=IDAF, FILE='MCQD50', STATUS='UNKNOWN',
*VMS *      ACCESS='DIRECT', FORM='UNFORMATTED', RECL=2*IRECLN)
C
      END IF
C
C     ----- IS THIS A NEW OR OLD DAF FILE? -----
C     EITHER MARK THE NEW DAF RECORDS AS EMPTY
C     OR ELSE LOAD THE OLD DAF DIRECTORY
C
      IF(IREST.EQ.0) THEN
         IRECST = 1
         DO 100 I = 1,400
            IODA(I) = -1
  100    CONTINUE
         IRECST = IRECST + 1
         IF(MASWRK) WRITE(UNIT=IDAF, REC=1) IRECST,IODA,IFILEN,IS,IPK
      ELSE
         IF(MASWRK) READ (UNIT=IDAF, REC=1) IRECST,IODA,IFILEN,IS,IPK
         IF(GOPARR) THEN
            CALL DDI_BCAST(200,'I',IRECST,1,MASTER)
            CALL DDI_BCAST(201,'I',IODA,400,MASTER)
            CALL DDI_BCAST(202,'I',IFILEN,400,MASTER)
            CALL DDI_BCAST(203,'I',IS,1,MASTER)
            CALL DDI_BCAST(204,'I',IPK,1,MASTER)
         END IF
      END IF
      RETURN
      END
C*MODULE IOLIB   *DECK PARENV
      SUBROUTINE PARENV(FNAME,FILENM,IOUT)
C
      IMPLICIT INTEGER (A-Z)
C
      PARAMETER (MAXLEN=256)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      INTEGER CFILENM(MAXLEN)
C
      CHARACTER*(*) FNAME
      CHARACTER*256 FILENM
      CHARACTER*256 DUMMY
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     THIS SUBROUTINE DECIDES WHETHER OR NOT SLAVES SHOULD OPEN A FILE.
C     IF A FILE IS TO BE OPENED, THE SLAVES GET THE NAME OF THE FILE
C     TO OPEN.
C
      IOUT = 0
C
      IF ((FNAME.EQ.'INPUT').OR.(FNAME.EQ.'OUTPUT').OR.
     *    (FNAME.EQ.'PUNCH').OR.(FNAME.EQ.'IRCDATA').OR.
     *    (.NOT.DSKWRK).OR.(NPROC.EQ.1)) THEN
         IF (.NOT.MASWRK) IOUT = 1
         RETURN
      END IF
C
C     IF FILENM IS EMPTY, ABRT ALL SLAVES; ELSE STRIP OFF THE PATH
C     AND SEND THE NAME TO ALL SLAVES.
C
      IF (MASWRK) THEN
C
         IEND = 0
         IF (FILENM(1:1).EQ.' ') THEN
            IEND = 1
            CALL DDI_BCAST(205,'I',IEND,1,MASTER)
            RETURN
         END IF
C
         DUMMY = FILENM
         INDEX = 0
C
C             NEXT CODE STRIPS PATH NAME IF ISTRIP IS 1
C             A 'SED' HACK CAN BE USED TO PREVENT STRIPPING.
C
         ISTRIP=1
         IF(ISTRIP.EQ.1) THEN
            DO 10 I = MAXLEN,1,-1
               IF (FILENM(I:I).EQ.'/') THEN
                  INDEX = I
                  GO TO 20
               END IF
   10       CONTINUE
   20       CONTINUE
C
            IF (INDEX.NE.0) THEN
               LDIFF = MAXLEN - INDEX
               DO 30 I = 1,LDIFF
                  INDEX = INDEX + 1
                  FILENM(I:I) = FILENM(INDEX:INDEX)
   30          CONTINUE
            END IF
         END IF
C
         LWORD = 0
         DO 40 I = 1,MAXLEN
            IF ((FILENM(I:I).EQ.CHAR(0)).OR.(FILENM(I:I).EQ.' '))
     *        GO TO 50
            LWORD = LWORD + 1
   40    CONTINUE
   50    CONTINUE
      END IF
C
      CALL DDI_BCAST(205,'I',IEND,1,MASTER)
      IF ((.NOT.MASWRK).AND.(IEND.EQ.1)) CALL ABRT
C
      IF (MASWRK) THEN
         DO 100 I=1,MAXLEN
            CFILENM(I) = ICHAR(FILENM(I:I))
  100    CONTINUE
      END IF
C
      CALL DDI_BCAST(206,'I',CFILENM,MAXLEN,MASTER)
      CALL DDI_BCAST(207,'I',LWORD,1,MASTER)
C
C     MASTER CAN RETURN NOW.
C
      IF (MASWRK) THEN
         FILENM = DUMMY
         RETURN
      END IF
C
      DO 150 I=1,MAXLEN
         FILENM(I:I) = CHAR(CFILENM(I))
  150 CONTINUE
C
C     APPEND NODE NUMBER TO OPEN UNIQUE FILES.
C
      DO 175 I = 1,LWORD
         DUMMY(I:I) = FILENM(I:I)
  175 CONTINUE
C
      WRITE(UNIT=DUMMY(LWORD+1:LWORD+4),FMT='(1H.,I3.3)') ME
      DUMMY(LWORD+5:LWORD+5) = CHAR(0)
      FILENM = DUMMY
C
      RETURN
      END
C*MODULE IOLIB   *DECK PKREAD
      SUBROUTINE PKREAD(IS,XP,XK,IX,NX,MAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION XP(*),XK(*),IX(*)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
C
      IF (LABSIZ.EQ.1) THEN
         IF(NWDVAR.EQ.2) MAX2 = MAX
         IF(NWDVAR.EQ.1) MAX2 = (MAX+1)/2
      ELSE IF (LABSIZ.EQ.2) THEN
         IF(NWDVAR.EQ.2) MAX2 = MAX*2
         IF(NWDVAR.EQ.1) MAX2 = MAX
      ELSE
         IF(MASWRK) WRITE(6,*) 'PKREAD: CONFUSION WITH -LABSIZ-'
         CALL ABRT
      END IF
      CALL PKRD(IS,XP,XK,IX,NX, MAX, MAX2 )
      RETURN
      END
C*MODULE IOLIB   *DECK PKRD
      SUBROUTINE PKRD(IS,XP,XK,IX,NX,MAX,MAX2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION XP(MAX),XK(MAX),IX(MAX2)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IF (DSKWRK.OR.MASWRK) READ(IS,END=200,ERR=300) NX,IX,XP,XK
      RETURN
C
  200 CONTINUE
      WRITE(6,9010) ME,IS
 9010 FORMAT(1X,'PKRD: NODE',I4,
     *          ' ENCOUNTERED UNEXPECTED END OF FILE READING UNIT',I4)
      CALL ABRT
C
  300 CONTINUE
      WRITE(6,9020) ME,IS
 9020 FORMAT(1X,'PKRD: NODE',I4,
     *          ' ENCOUNTERED I/O ERROR READING UNIT',I4)
      CALL ABRT
C
      RETURN
      END
C*MODULE IOLIB   *DECK PREAD
      SUBROUTINE PREAD(IS,XX,IX,NX,MAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION XX(MAX),IX(*)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
C
      IF (LABSIZ.EQ.1) THEN
         IF(NWDVAR.EQ.2) MAX2 = MAX
         IF(NWDVAR.EQ.1) MAX2 = (MAX+1)/2
      ELSE IF (LABSIZ.EQ.2) THEN
         IF(NWDVAR.EQ.2) MAX2 = MAX*2
         IF(NWDVAR.EQ.1) MAX2 = MAX
      ELSE
         IF(MASWRK) WRITE(6,*) 'PREAD: CONFUSION WITH -LABSIZ-'
         CALL ABRT
      END IF
C
      CALL PRD(IS,XX,IX,NX, MAX, MAX2 )
      RETURN
      END
C*MODULE IOLIB   *DECK PRD
      SUBROUTINE PRD(IS,XX,IX,NX,MAX,MAX2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION XX(MAX),IX(MAX2)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IF (DSKWRK.OR.MASWRK) READ(IS,END=200,ERR=300) NX,IX,XX
      RETURN
C
  200 CONTINUE
      WRITE(6,9010) ME,IS
 9010 FORMAT(1X,'PRD: NODE',I4,
     *          ' ENCOUNTERED UNEXPECTED END OF FILE READING UNIT',I4)
      CALL ABRT
C
  300 CONTINUE
      WRITE(6,9020) ME,IS
 9020 FORMAT(1X,'PRD: NODE',I4,
     *          ' ENCOUNTERED I/O ERROR READING UNIT',I4)
      CALL ABRT
C
      RETURN
      END
C*MODULE IOLIB   *DECK PREADP
      SUBROUTINE PREADP(NFT,XX,IX,NXX,NINTMX,KAP,IFLG,JFLG,NPROC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION XX(NINTMX),IX(NINTMX),JFLG(0:NPROC-1)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /PAR   / ME,MASTER,NPROCX,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
C
C     ----- PARALLEL FORM OF -PREAD- ROUTINE -----
C     THIS ROUTINE READS A SINGLE RECORD, FROM WHICHEVER NODE WHOSE
C     TURN IS NEXT, AND BROADCASTS IT TO ALL NODES.  THIS MAKES A
C     FILE WHICH HAS BEEN DISTRIBUTED ACROSS NODES AVAILABLE IN ITS
C     ENTIRETY TO ALL NODES.
C
C     THIS ROUTINE READS IN A ROUND-ROBIN FASHION, WITH NODE -KAP-
C     READING THE 1ST RECORD FROM NODES 0,1,...,NPROC-1, THEN THE 2ND
C     RECORDS FROM EACH, ETC, ETC.  -JFLG- KEEPS TRACK OF END-OF-FILE
C     ON EACH NODE, WHEREAS -IFLG- KEEPS TRACK OF END-OF-FILE ON ALL
C     NODES, IFLG.EQ.0 ON EXIT MEANS ALL NODES HAVE PREVIOUSLY HIT
C     END OF FILE, AND THUS NO DATA RECORD IS RETURNED.
C
C
  100 CONTINUE
      KAP = KAP+1
      IF(KAP.EQ.NPROC) THEN
         IF(IFLG.EQ.0) RETURN
         KAP = 0
         IFLG= 0
      END IF
C
      IF(JFLG(KAP).GT.0) THEN
         IFLG=1
         IF(KAP.EQ.ME) CALL PREAD(NFT,XX,IX,NXX,NINTMX)
         CALL DDI_BCAST(1205,'I',NXX,1,KAP)
         NINT = ABS(NXX)
         IF (LABSIZ.EQ.1) THEN
            IF(NWDVAR.EQ.2) NINT2 = NINT
            IF(NWDVAR.EQ.1) NINT2 = (NINT+1)/2
         ELSE IF (LABSIZ.EQ.2) THEN
            IF(NWDVAR.EQ.2) NINT2 = NINT*2
            IF(NWDVAR.EQ.1) NINT2 = NINT
         ELSE
            IF(MASWRK) WRITE(6,*) 'PREADP: CONFUSION WITH -LABSIZ-'
            CALL ABRT
         END IF
         CALL DDI_BCAST(1210,'F',XX,NINT,KAP)
         CALL DDI_BCAST(1215,'I',IX,NINT2,KAP)
         JFLG(KAP) = NXX
         RETURN
      END IF
C
      GO TO 100
      END
C*MODULE IOLIB   *DECK PXREAD
      SUBROUTINE PXREAD(NFT,X,XX,MX,NX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION X(NX),XX(NX)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IF (DSKWRK.OR.MASWRK) READ(NFT,END=200,ERR=300) X,XX,MX
      RETURN
C
  200 CONTINUE
      WRITE(6,9010) ME,NFT
 9010 FORMAT(1X,'PXREAD: NODE',I4,
     *          ' ENCOUNTERED UNEXPECTED END OF FILE READING UNIT',I4)
      CALL ABRT
C
  300 CONTINUE
      WRITE(6,9020) ME,NFT
 9020 FORMAT(1X,'PXREAD: NODE',I4,
     *          ' ENCOUNTERED I/O ERROR READING UNIT',I4)
      CALL ABRT
C
      RETURN
      END
C*MODULE IOLIB   *DECK PUVIB
      SUBROUTINE PUVIB(IFCM,IW,RSTART,NCOORD,IVIB,IATOM,ICOORD,
     *                 E,EG,DIP)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=500, MXPT=100, MXFRG=50, MXFGPT=MXPT*MXFRG)
C
      DIMENSION EG(NCOORD), DIP(3), BLANK(1), VIBWRD(1)
C
      LOGICAL RSTART,GOPARR,DSKWRK,MASWRK,FGONLY
C
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA BLANK/8H        /, VIBWRD/8H $VIB   /
#else
      CHARACTER*8 :: BLANK_STR
      EQUIVALENCE (BLANK, BLANK_STR)
      CHARACTER*8 :: VIBWRD_STR
      EQUIVALENCE (VIBWRD, VIBWRD_STR)
      DATA BLANK_STR/"        "/, VIBWRD_STR/" $VIB   "/
#endif
C
C     ----- SAVE DATA FOR CURRENT VIBRATION FOR FORCE RESTARTS -----
C     THIS IS CRUCIAL DATA, SO IF POSSIBLE FLUSH THE BUFFER TO DISK.
C     AND FOR GOOD MEASURE, PUT A COPY IN THE PRINTOUT.
C
      FGONLY = NUM.EQ.0  .AND.  NFRG.GT.0
C
      IF(.NOT.MASWRK  .OR.  NPRTGO.LE.0) RETURN
C
      IF(IVIB.EQ.0) WRITE(IFCM,9000) VIBWRD
      WRITE(IFCM,9020) BLANK,IVIB,IATOM,ICOORD,E
C
      IF (.NOT. FGONLY) WRITE(IFCM,9040) EG
      IF(NFRG.GT.0) THEN
         DO IFR=1,NFRG
            WRITE(IFCM,9040) (DEFT(IFRC,IFR),IFRC=1,3)
            WRITE(IFCM,9040) (TORQ(IFRC,IFR),IFRC=1,3)
         ENDDO
      END IF
      WRITE(IFCM,9040) DIP
      CALL FLSHBF(IFCM)
C
      IF(RSTART) RETURN
      WRITE(IW,9100) VIBWRD
      WRITE(IW,9120) BLANK,IVIB,IATOM,ICOORD,E
      IF (.NOT. FGONLY) WRITE(IW,9140) EG
C
      IF(NFRG.GT.0) THEN
         DO IFR=1,NFRG
            WRITE(IW,9040) (DEFT(IFRC,IFR),IFRC=1,3)
            WRITE(IW,9040) (TORQ(IFRC,IFR),IFRC=1,3)
         ENDDO
      END IF
      WRITE(IW,9140) DIP
      RETURN
C
 9000 FORMAT(A8)
 9020 FORMAT(A8,' IVIB=',I4,' IATOM=',I4,' ICOORD=',I4,' E=',F20.10)
 9040 FORMAT(1P,5E16.9)
 9100 FORMAT(1X,A8)
 9120 FORMAT(1X,A8,' IVIB=',I4,' IATOM=',I4,' ICOORD=',I4,' E=',F20.10)
 9140 FORMAT(1X,1P,5E16.9)
      END
C*MODULE IOLIB   *DECK PKWRIT
      SUBROUTINE PKWRIT(IS,XP,XK,IX,NX,MAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION XP(*),XK(*),IX(*)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
C
      IF (LABSIZ.EQ.1) THEN
         IF(NWDVAR.EQ.2) MAX2 = MAX
         IF(NWDVAR.EQ.1) MAX2 = (MAX+1)/2
      ELSE IF (LABSIZ.EQ.2) THEN
         IF(NWDVAR.EQ.2) MAX2 = MAX*2
         IF(NWDVAR.EQ.1) MAX2 = MAX
      ELSE
         IF(MASWRK) WRITE(6,*) 'PKWRIT: CONFUSION WITH -LABSIZ-'
         CALL ABRT
      END IF
      CALL PKWRT(IS,XP,XK,IX,NX, MAX, MAX2 )
      RETURN
      END
C*MODULE IOLIB   *DECK PKWRT
      SUBROUTINE PKWRT(IS,XP,XK,IX,NX,MAX,MAX2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION XP(MAX),XK(MAX),IX(MAX2)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IF (DSKWRK.OR.MASWRK) WRITE(IS,ERR=300) NX,IX,XP,XK
      RETURN
C
  300 CONTINUE
      WRITE(6,9020) ME,IS
 9020 FORMAT(1X,'PKWRT: NODE',I4,
     *          ' ENCOUNTERED I/O ERROR READING UNIT',I4)
      CALL ABRT
C
      RETURN
      END
C*MODULE IOLIB   *DECK PWRIT
      SUBROUTINE PWRIT(IS,XX,IX,NX,MAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION XX(MAX),IX(*)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
C
      IF (LABSIZ.EQ.1) THEN
         IF(NWDVAR.EQ.2) MAX2 = MAX
         IF(NWDVAR.EQ.1) MAX2 = (MAX+1)/2
      ELSE IF (LABSIZ.EQ.2) THEN
         IF(NWDVAR.EQ.2) MAX2 = MAX*2
         IF(NWDVAR.EQ.1) MAX2 = MAX
      ELSE
         IF(MASWRK) WRITE(6,*) 'PWRIT: CONFUSION WITH -LABSIZ-'
         CALL ABRT
      END IF
C
      CALL PWRT(IS,XX,IX,NX, MAX, MAX2 )
      RETURN
      END
C*MODULE IOLIB   *DECK PWRT
      SUBROUTINE PWRT(IS,XX,IX,NX,MAX,MAX2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION XX(MAX),IX(MAX2)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IF (DSKWRK.OR.MASWRK) WRITE(IS,ERR=300) NX,IX,XX
      RETURN
C
  300 CONTINUE
      WRITE(6,9020) ME,IS
 9020 FORMAT(1X,'PWRT: NODE',I4,
     *          ' ENCOUNTERED I/O ERROR WRITING UNIT',I4)
      CALL ABRT
C
      RETURN
      END
C*MODULE IOLIB   *DECK PXWRIT
      SUBROUTINE PXWRIT(NFT,X,XX,MX,NX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION X(NX),XX(NX)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IF (DSKWRK.OR.MASWRK) WRITE (NFT,ERR=300) X,XX,MX
      RETURN
C
  300 CONTINUE
      WRITE(6,9020) ME,NFT
 9020 FORMAT(1X,'PXWRIT: NODE',I4,
     *          ' ENCOUNTERED I/O ERROR WRITING UNIT',I4)
      CALL ABRT
C
      RETURN
      END
C*MODULE IOLIB   *DECK RACLOS
      SUBROUTINE RACLOS(IRAF,FSTAT)
C
      CHARACTER*(*) FSTAT
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXUNIT=299)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /OPNNFT/ NFTOPN(MXUNIT)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- CLOSE FILE IRAF -----
C
      IF(IRAF.GT.MXUNIT) THEN
         WRITE(IW,900) IRAF,MXUNIT
         CALL ABRT
      END IF
      IF(NFTOPN(IRAF).EQ.0) RETURN
  900 FORMAT(1X,'RACLOS: ATTEMPT TO CLOSE FILE',I5,
     *          ' GREATER THAN MAXIMUM',I5)
C
      IF(MASWRK  .OR.  DSKWRK) CLOSE(UNIT=IRAF, STATUS=FSTAT)
      NFTOPN(IRAF) = 0
      RETURN
      END
C*MODULE IOLIB   *DECK RAOPEN
      SUBROUTINE RAOPEN(IRAF,IORA,LPHYS,NUMREC,LENREC,NPRINT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXUNIT=299)
C
      CHARACTER*6 FILENM
      CHARACTER*1 NULL
      CHARACTER*256 PATHNM
C
      DIMENSION IORA(NUMREC)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /OPNNFT/ NFTOPN(MXUNIT)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RAIOLN/ JRECLN(10),JRECST(10)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA CHECK/8HCHECK    /
#else
      CHARACTER*8 :: CHECK_STR
      EQUIVALENCE (CHECK, CHECK_STR)
      DATA CHECK_STR/"CHECK   " /
#endif
C
C     THIS ROUTINE, AND OTHERS IN THIS GROUP CONTROL THE RANDOM
C     ACCESS SORTFILE IRAF, WHICH IS USED FOR SORTING MANY THINGS,
C     SUCH AS ATOMIC INTEGRALS, TRANSFORMED INTEGRALS, MCSCF
C     HESSIAN MATRIX, 2-PARTICLE DENSITY, ETC.
C     EACH TIME A SORT IS DONE, THE DISK REQUIREMENTS CHANGE.
C     HENCE RAOPEN AND RACLOS BENEFIT MUCH FROM THE FORTRAN-77
C     OPEN AND CLOSE STATEMENTS. IN THE ABSENCE OF FORTRAN-77,
C     ONE MAKES FILE 20 LARGE ENOUGH FOR THE BIGGEST SORT.
C     IF ONE CANNOT TELL HOW BIG THIS IS, ONE OPENS A FIXED
C     AND VERY LARGE SORTFILE.
C
C     -NUMREC- LOGICAL RECORDS OF LENGTH -LENREC- ARE SPREAD OVER AS
C     MANY PHYSICAL RECORDS OF LENGTH -IRECLN- AS NEEDED, SO THAT
C     -MXREC- PHYSICAL RECORDS ARE REQUIRED.
C     IF -LPHYS- IS NONZERO, AND THE RECORD SIZE -LENREC- IS SMALLER
C     THAN THE DEFAULT PHYSICAL LENGTH, THE PHYSICAL LENGTH IS
C     TRIMMED TO JUST THE SIZE NEEDED.
C
      IF(IRAF.GT.MXUNIT) THEN
         WRITE(IW,900) IRAF,MXUNIT
         CALL ABRT
      END IF
      IF(NFTOPN(IRAF).EQ.1) RETURN
      NFTOPN(IRAF) = 1
  900 FORMAT(1X,'RAOPEN: ATTEMPT TO OPEN FILE',I5,
     *          ' GREATER THAN MAXIMUM',I5)
C
C     ----- SET THE PHYSICAL RECORD LENGTH -----
C
      IRECLN=NRASIZ(IRAF)
      IF(LPHYS.NE.0  .AND.  LENREC.LT.IRECLN) IRECLN=LENREC
C
C     ----- COUNT HOW MANY PHYSICAL RECORDS ARE NEEDED -----
C
      MXREC = (((LENREC-1)/IRECLN)+1)*NUMREC
      JRECST(IRAF/10)=1
      JRECLN(IRAF/10)=IRECLN
      IF(EXETYP.EQ.CHECK) RETURN
C
C     ----- OPEN THE RANDOM ACCESS FILE -----
C
C        BY CONVENTION, FILES ENDING IN 0'S ARE DIRECT ACCESS,
C        AT PRESENT ONLY FILE 20 AND 30 ARE USED.
C
      FILENM='      '
      IF(IRAF.EQ.20) FILENM = 'DASORT'
      IF(IRAF.EQ.30) FILENM = 'DAFL30'
      IF(FILENM.EQ.'      ') THEN
         IF(MASWRK) WRITE(IW,*) 'ERROR IN RAOPEN WITH UNIT NUMBER',IRAF
         CALL ABRT
      END IF
C
      IF(NPRINT.NE.-5  .AND.  MASWRK)
     *     WRITE(IW,9000) FILENM,NUMREC,LENREC,MXREC,IRECLN
C
      IF (MASWRK  .OR.  DSKWRK) THEN
C
*IBM  OPEN (UNIT=IRAF, FILE=FILENM, STATUS='UNKNOWN',
*IBM *      ACCESS='DIRECT', FORM='UNFORMATTED', RECL=8*IRECLN)
C
#if defined(SPEC_CPU)
      IF(MASWRK) CALL DUMMYGETENV(FILENM,PATHNM)
#else
      IF(MASWRK) CALL GETENV(FILENM,PATHNM)
#endif
      CALL PARENV(FILENM,PATHNM,IOUT)
      IF (IOUT.EQ.1) RETURN
      NULL = CHAR(0)
      DO 3 KOL=1,256
         IF(PATHNM(KOL:KOL).EQ.' '  .OR.
     *      PATHNM(KOL:KOL).EQ.NULL) GO TO 4
    3 CONTINUE
      KOL=257
    4 CONTINUE
      IF(KOL.EQ.1) THEN
         WRITE(IW,1) FILENM
         CALL ABRT
      END IF
      KOL=KOL-1
      OPEN (UNIT=IRAF, FILE=PATHNM(1:KOL), STATUS='UNKNOWN',
     *      ACCESS='DIRECT', FORM='UNFORMATTED',
     *      RECL=8*IRECLN)
    1 FORMAT(1X,'YOU MUST ASSIGN GENERIC NAME ',A,' WITH A SETENV.')
C
*VMS  OPEN (UNIT=IRAF, FILE=FILENM, STATUS='UNKNOWN',
*VMS *      ACCESS='DIRECT', FORM='UNFORMATTED', RECL=2*IRECLN)
C
      END IF
C
C      ----- INITIALIZE FOR EMPTY SORTFILE ----
C
      DO 100 I = 1,NUMREC
         IORA(I) = -1
  100 CONTINUE
      RETURN
C
 9000 FORMAT(1X,'OPENING FILE ',A6,' WITH',I8,' LOGICAL RECORDS OF',I8,
     *          ' WORDS'/1X,'WITH A MAXIMUM OF',I12,
     *          ' PHYSICAL RECORDS OF',I8,' WORDS')
      END
C*MODULE IOLIB   *DECK RAOPEN2
      SUBROUTINE RAOPEN2(IRAF,IORA,LPHYS,NUMREC,LENREC,LDAR,NPRINT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      CHARACTER*7 FILENM
      CHARACTER*1 NULL
      CHARACTER*256 PATHNM
C
      DIMENSION IORA(NUMREC)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RAIOLN/ JRECLN(10),JRECST(10)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA CHECK/8HCHECK    /
#else
      CHARACTER*8 :: CHECK_STR
      EQUIVALENCE (CHECK, CHECK_STR)
      DATA CHECK_STR/"CHECK   " /
#endif
C
C     THIS ROUTINE, AND OTHERS IN THIS GROUP CONTROL THE RANDOM
C     ACCESS SORTFILE IRAF, WHICH IS USED FOR SORTING MANY THINGS,
C     SUCH AS ATOMIC INTEGRALS, TRANSFORMED INTEGRALS, MCSCF
C     HESSIAN MATRIX, 2-PARTICLE DENSITY, ETC.
C     EACH TIME A SORT IS DONE, THE DISK REQUIREMENTS CHANGE.
C     HENCE RAOPEN AND RACLOS BENEFIT MUCH FROM THE FORTRAN-77
C     OPEN AND CLOSE STATEMENTS. IN THE ABSENCE OF FORTRAN-77,
C     ONE MAKES FILE 20 LARGE ENOUGH FOR THE BIGGEST SORT.
C     IF ONE CANNOT TELL HOW BIG THIS IS, ONE OPENS A FIXED
C     AND VERY LARGE SORTFILE.
C
C     DIFFERS FROM -RAOPEN- IN THAT THERE IS A FILE 40, AND
C     THE SIZE OF THE RECORDS IS A CALLING ARGUMENT -LDAR-.
C
C     -NUMREC- LOGICAL RECORDS OF LENGTH -LENREC- ARE SPREAD OVER AS
C     MANY PHYSICAL RECORDS OF LENGTH -IRECLN- AS NEEDED, SO THAT
C     -MXREC- PHYSICAL RECORDS ARE REQUIRED.
C     IF -LPHYS- IS NONZERO, AND THE RECORD SIZE -LENREC- IS SMALLER
C     THAN THE DEFAULT PHYSICAL LENGTH, THE PHYSICAL LENGTH IS
C     TRIMMED TO JUST THE SIZE NEEDED.
C
C     ----- SET THE PHYSICAL RECORD LENGTH -----
C
      IF(LDAR.EQ.0) THEN
         IRECLN=NRASIZ(IRAF)
      ELSE
         IRECLN=LDAR
      END IF
      IF(LPHYS.NE.0  .AND.  LENREC.LT.IRECLN) IRECLN=LENREC
C
C     ----- COUNT HOW MANY PHYSICAL RECORDS ARE NEEDED -----
C
      MXREC = (((LENREC-1)/IRECLN)+1)*NUMREC
      JRECST(IRAF/10)=1
      JRECLN(IRAF/10)=IRECLN
      IF(EXETYP.EQ.CHECK) RETURN
C
C        BY CONVENTION, FILES ENDING IN 0'S ARE DIRECT ACCESS,
C        AT PRESENT ONLY FILE 20, 30, AND 40 ARE USED.
C
      FILENM='      '
      NFILNM=6
      IF(IRAF.EQ.20) FILENM = 'DASORT'
      IF(IRAF.EQ.30) FILENM = 'DAFL30'
      IF(IRAF.EQ.40) FILENM = 'SOCCDAT'
      IF(IRAF.EQ.40) NFILNM = 7
      IF(FILENM(1:1).EQ.' ') THEN
         IF(MASWRK) WRITE(IW,*) 'ERROR IN RAOPEN2 WITH UNIT NUMBER',IRAF
         CALL ABRT
      END IF
C
      IF(NPRINT.NE.-5  .AND.  MASWRK)
     *     WRITE(IW,9000) FILENM(1:NFILNM),NUMREC,LENREC,MXREC,IRECLN
C
C     ----- OPEN THE RANDOM ACCESS FILE -----
C
      IF (MASWRK  .OR.  DSKWRK) THEN
C
*IBM  OPEN (UNIT=IRAF, FILE=FILENM(1:NFILNM), STATUS='UNKNOWN',
*IBM *      ACCESS='DIRECT', FORM='UNFORMATTED', RECL=8*IRECLN)
C
#if defined(SPEC_CPU)
      IF(MASWRK) CALL DUMMYGETENV(FILENM(1:NFILNM),PATHNM)
#else
      IF(MASWRK) CALL GETENV(FILENM(1:NFILNM),PATHNM)
#endif
      CALL PARENV(FILENM(1:NFILNM),PATHNM,IOUT)
      IF (IOUT.EQ.1) RETURN
      NULL = CHAR(0)
      DO 3 KOL=1,256
         IF(PATHNM(KOL:KOL).EQ.' '  .OR.
     *      PATHNM(KOL:KOL).EQ.NULL) GO TO 4
    3 CONTINUE
      KOL=257
    4 CONTINUE
      IF(KOL.EQ.1) THEN
         WRITE(IW,1) FILENM(1:NFILNM)
         CALL ABRT
      END IF
      KOL=KOL-1
      OPEN (UNIT=IRAF, FILE=PATHNM(1:KOL), STATUS='UNKNOWN',
     *      ACCESS='DIRECT', FORM='UNFORMATTED',
     *      RECL=8*IRECLN)
    1 FORMAT(1X,'YOU MUST ASSIGN GENERIC NAME ',A,' WITH A SETENV.')
C
*VMS  OPEN (UNIT=IRAF, FILE=FILENM(1:NFILNM), STATUS='UNKNOWN',
*VMS *      ACCESS='DIRECT', FORM='UNFORMATTED', RECL=2*IRECLN)
C
      END IF
C
C      ----- INITIALIZE FOR EMPTY SORTFILE ----
C
      DO 100 I = 1,NUMREC
         IORA(I) = -1
  100 CONTINUE
      RETURN
C
 9000 FORMAT(1X,'OPENING FILE ',A,' WITH',I8,' LOGICAL RECORDS OF',I8,
     *          ' WORDS'/1X,'WITH A MAXIMUM OF',I12,
     *          ' PHYSICAL RECORDS OF',I8,' WORDS')
      END
C*MODULE IOLIB   *DECK RARD
      SUBROUTINE RARD(V,LEN,IRAF,NS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION V(LEN)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- READ A PHYSICAL RECORD FROM IRAF -----
C
      IF(MASWRK  .OR.  DSKWRK) READ(UNIT=IRAF,REC=NS) V
C
      IF(GOPARR  .AND.  .NOT.DSKWRK) THEN
         CALL DDI_BCAST(225,'F',V,LEN,MASTER)
      END IF
      RETURN
      END
C*MODULE IOLIB   *DECK RAREAD
      SUBROUTINE RAREAD(IRAF,IORA,V,LEN,NREC,NAV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION V(*),IORA(*)
      COMMON /RAIOLN/ JRECLN(10),JRECST(10)
C
C      ----- READ A LOGICAL RECORD FROM IRAF -----
C
      IF(IRAF.LT.0) WRITE(6,*) 'BOGUS RAREAD, NAV=',NAV
C
      IRECLN=JRECLN(IRAF/10)
      N = IORA(NREC)
      IS = -IRECLN + 1
      NS = N
      LENT = LEN
C
  100 CONTINUE
         IS = IS + IRECLN
         IF = IS + LENT - 1
         IF ((IF-IS+1) .GT. IRECLN) IF = IS + IRECLN - 1
         NSP = NS
         LENW = IF - IS + 1
         CALL RARD(V(IS),LENW,IRAF,NSP)
         LENT = LENT - IRECLN
         NS = NS + 1
         N = NS
      IF (LENT .GE. 1) GO TO 100
      RETURN
      END
C*MODULE IOLIB   *DECK RASIZE
      SUBROUTINE RASIZE(LDAR)
C
C     THIS ROUTINE RETURNS THE LENGTH OF PHYSICAL RECORDS (IN UNITS OF
C     W.P. FLOATING POINT NOS) USED BY THE DIRECT ACCESS SORT FILE IRAF.
C     SELECT A ROUND NUMBER FOR LEN, A BIT SMALLER THAN THE PHYSICAL
C     RECORD LENGTH USED IN ROUTINE RAOPEN.  SEE ROUTINE RAOPEN.
C
*VMS  LDAR=2045
*IBM  LDAR=2930
      LDAR=2045
      RETURN
      END
C*MODULE IOLIB   *DECK NRASIZ
      INTEGER FUNCTION NRASIZ(IRAF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C     USED BY DIRECT ACCESS FILE OPENING ROUTINES
C
      IF(IRAF.EQ.10) THEN
*IBM      NRASIZ = 512
          NRASIZ = 1023
*VAX      NRASIZ = 512
      ELSE
*IBM      NRASIZ = 2934
          NRASIZ = 2048
*VAX      NRASIZ = 2046
C         PLEASE USE AN EVEN NUMBER
      ENDIF
      RETURN
      END
C*MODULE IOLIB   *DECK RAWRIT
      SUBROUTINE RAWRIT(IRAF,IORA,V,LEN,NREC,NAVM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION V(*),IORA(*)
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RAIOLN/ JRECLN(10),JRECST(10)
C
C     ------ WRITE A LOGICAL RECORD ON IRAF -----
C
      IF(IRAF.LT.0) WRITE(6,*) 'BOGUS RAWRIT, NAVM=',NAVM
C
      IRECST=JRECST(IRAF/10)
      IRECLN=JRECLN(IRAF/10)
      N = IORA(NREC)
      IF(N.LE.0) THEN
         IORA(NREC) = IRECST
         IRECST = IRECST + (LEN-1)/IRECLN + 1
         N = IORA(NREC)
      END IF
C
      JRECST(IRAF/10)=IRECST
      IF(GOPARR  .AND.  .NOT.(MASWRK.OR.DSKWRK)) RETURN
C
      IST = -IRECLN + 1
      NS = N
      LENT = LEN
  120 CONTINUE
         IST = IST + IRECLN
         IF = IST + LENT - 1
         IF ((IF-IST+1) .GT. IRECLN) IF = IST+IRECLN-1
         NSP = NS
         LENW = IF - IST + 1
         CALL RAWRT(V(IST),LENW,IRAF,NSP)
         LENT = LENT - IRECLN
         NS = NS + 1
         N = NS
      IF (LENT .GE. 1) GO TO 120
      RETURN
C
      END
C*MODULE IOLIB   *DECK RAWRITE
      SUBROUTINE RAWRITE(IRAF,IORA,V,LEN1,LEN,NREC,NPHYSOFF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION V(*),IORA(*)
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RAIOLN/ JRECLN(10),JRECST(10)
C
C     ------ WRITE A LOGICAL RECORD ON IRAF -----
C     THIS IS THE SAME AS RAWRIT EXCEPT IT ENFORCES THAT LEN1 WORDS
C     BE ALLOCATED ON IRAF FOR THIS RECORD EVEN IF ONE WRITES ONLY
C     LEN WORDS THIS TIME
C
C     NPHYSOFF SETS AN OFFSET IN PHYSICAL RECORDS
C     (IN ORDER TO WRITE A PARTIAL LOGICAL ERCORD)
C
      IRECST=JRECST(IRAF/10)
      IRECLN=JRECLN(IRAF/10)
      N = IORA(NREC)
      IF(N.LE.0) THEN
         IORA(NREC) = IRECST
         IRECST = IRECST + (LEN1-1)/IRECLN + 1
         N = IORA(NREC)
      END IF
C
      JRECST(IRAF/10)=IRECST
      IF(GOPARR  .AND.  .NOT.(MASWRK.OR.DSKWRK)) RETURN
C
      IST = -IRECLN + 1
      NS = N
      LENT = LEN
  120 CONTINUE
         IST = IST + IRECLN
         IF = IST + LENT - 1
         IF ((IF-IST+1) .GT. IRECLN) IF = IST+IRECLN-1
         NSP = NS
         LENW = IF - IST + 1
         CALL RAWRT(V(IST),LENW,IRAF,NSP+NPHYSOFF)
         LENT = LENT - IRECLN
         NS = NS + 1
         N = NS
      IF (LENT .GE. 1) GO TO 120
      RETURN
      END
C*MODULE IOLIB   *DECK RAWRT
      SUBROUTINE RAWRT(V,LEN,IRAF,NS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION V(LEN)
C
C     ----- WRITE A PHYSICAL RECORD ON IRAF -----
C
      WRITE (UNIT=IRAF, REC=NS) V
      RETURN
      END
C*MODULE IOLIB   *DECK SEQADV
      SUBROUTINE SEQADV(LUNIT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- ADVANCE ONE RECORD ON FILE LUNIT -----
C
      IF (DSKWRK.OR.MASWRK) READ (LUNIT)
      RETURN
      END
C*MODULE IOLIB   *DECK SEQCLO
      SUBROUTINE SEQCLO(IFILE,FSTAT)
C
      CHARACTER*(*) FSTAT
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      PARAMETER (MXUNIT=299)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /OPNNFT/ NFTOPN(MXUNIT)
C
C     ----- CLOSE THE SEQUENTIAL FILE IFILE -----
C     ----- FSTAT MAY BE 'KEEP' OR 'DELETE' -----
C
      IF(IFILE.GT.MXUNIT) THEN
         WRITE(IW,900) IFILE,MXUNIT
         CALL ABRT
      END IF
      IF(NFTOPN(IFILE).EQ.0) RETURN
C
      IF(DSKWRK.OR.MASWRK) CLOSE (UNIT=IFILE, STATUS=FSTAT)
      NFTOPN(IFILE) = 0
      RETURN
  900 FORMAT(1X,'SEQCLO: ATTEMPT TO CLOSE FILE',I5,
     *          ' GREATER THAN MAXIMUM',I5)
      END
C*MODULE IOLIB   *DECK SEQOPN
      SUBROUTINE SEQOPN(IUNIT,FNAME,FSTAT,RDONLY,FMT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      CHARACTER*(*) FNAME,FSTAT,FMT
      LOGICAL RDONLY,GOPARR,DSKWRK,MASWRK
      PARAMETER (MXUNIT=299)
C
      CHARACTER*256 FILENM
      CHARACTER*1 NULL
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /OPNNFT/ NFTOPN(MXUNIT)
C
C         OPEN SEQUENTIAL FILE -IUNIT- WITH GENERIC NAME -FNAME-
C         WITH STATUS -FSTAT-, AS EITHER READONLY/READWRITE, AND
C         FOR EITHER FORMATTED OR UNFORMATTED I/O. EXAMPLE:
C
C         CALL SEQOPN(IS,'AOINTS','UNKNOWN',.FALSE.,'UNFORMATTED')
C
C         THE REASON FOR LIMITING THE OPEN FILES TO 100 IS THAT
C         THE 'F2C' TRANSLATER HAS THE SAME LIMITAION IN IT.
C
      IF(IUNIT.EQ.5) THEN
         DO 100 I=1,MXUNIT
            NFTOPN(I)=0
  100    CONTINUE
         IF(.NOT.RDONLY) WRITE(6,*) 'CAUTION, INPUT FILE NOT READ ONLY'
      END IF
C
C         THIS IS FOR THE AIX XL FORTRAN VERSION 3, WHICH DOESN'T
C         SILENTLY IGNORE REQUESTS TO OPEN A FILE WHICH IS ALREADY OPEN
C
      IF(IUNIT.GT.MXUNIT) THEN
         WRITE(IW,900) IUNIT,MXUNIT
         CALL ABRT
      END IF
      IF(NFTOPN(IUNIT).EQ.1) RETURN
      NFTOPN(IUNIT) = 1
  900 FORMAT(1X,'SEQOPN: ATTEMPT TO OPEN FILE',I5,
     *          ' GREATER THAN MAXIMUM',I5)
C
*IBM  IF (MASWRK) THEN
*IBM  IF(FNAME.NE.'OUTPUT') THEN
*IBM     OPEN(UNIT=IUNIT, FILE=FNAME, STATUS=FSTAT,
*IBM *        ACCESS='SEQUENTIAL', FORM=FMT)
*IBM  END IF
*IBM  END IF
C
      FILENM=' '
#if defined(SPEC_CPU)
      IF (MASWRK) CALL DUMMYGETENV(FNAME,FILENM)
#else
      IF (MASWRK) CALL GETENV(FNAME,FILENM)
#endif
      CALL PARENV(FNAME,FILENM,IOUT)
      IF (IOUT.EQ.1) RETURN
      IF(FNAME.EQ.'OUTPUT') THEN
         IF(FILENM(1:1).NE.' '  .AND.  FILENM(1:6).NE.'OUTPUT') THEN
            OPEN(UNIT=IUNIT, FILE=FILENM, STATUS=FSTAT,
     *           ACCESS='SEQUENTIAL', FORM=FMT)
         END IF
      ELSE
         NULL = CHAR(0)
         DO 3 KOL=1,256
            IF(FILENM(KOL:KOL).EQ.' '  .OR.
     *         FILENM(KOL:KOL).EQ.NULL) GO TO 4
    3    CONTINUE
         KOL=257
    4    CONTINUE
         IF(KOL.EQ.1) THEN
            WRITE(IW,1) FNAME
            CALL ABRT
         END IF
         KOL=KOL-1
         OPEN(UNIT=IUNIT, FILE=FILENM(1:KOL), STATUS=FSTAT,
     *        ACCESS='SEQUENTIAL', FORM=FMT)
      END IF
    1 FORMAT(1X,'YOU MUST ASSIGN GENERIC NAME ',A,' WITH A SETENV.')
C
      IF (MASWRK) THEN
*VMS  IF(RDONLY) THEN
*VMS     OPEN(UNIT=IUNIT, FILE=FNAME, STATUS=FSTAT, READONLY,
*VMS *        ACCESS='SEQUENTIAL', FORM=FMT, SHARED)
*VMS  ELSE
*VMS     IF(FNAME.EQ.'OUTPUT') THEN
*VMS        OPEN(UNIT=IUNIT, FILE=FNAME, STATUS=FSTAT,
*VMS *           ACCESS='SEQUENTIAL', FORM=FMT, SHARED)
*VMS     ELSE IF(FNAME.EQ.'PUNCH'  .OR.  FNAME.EQ.'IRCDATA') THEN
*VMS        OPEN(UNIT=IUNIT, FILE=FNAME, STATUS=FSTAT,
*VMS *           ACCESS='SEQUENTIAL', FORM=FMT,
*VMS *           CARRIAGECONTROL='LIST', SHARED)
*VMS     ELSE
*VMS        OPEN(UNIT=IUNIT, FILE=FNAME, STATUS=FSTAT,
*VMS *           ACCESS='SEQUENTIAL', FORM=FMT)
*VMS     END IF
*VMS  END IF
      END IF
C
      RETURN
      END
C*MODULE IOLIB   *DECK SEQREW
      SUBROUTINE SEQREW(IFILE)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C   ----- REWIND FILE IFILE ----
C
      IF (DSKWRK.OR.MASWRK) REWIND (UNIT=IFILE, ERR=300)
  300 CONTINUE
      RETURN
      END
C*MODULE IOLIB   *DECK SQREAD
      SUBROUTINE SQREAD (LFILE,REGION,LENGTH)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION REGION(LENGTH)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IIS,IPK,IIDAF,NAV,IIODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     READ -LENGTH- FLOATING POINT WORDS INTO -REGION- FROM -LFILE-
C     NOTE THAT DUE TO ITS POSSIBLE RESET TO 0 BELOW, -LENGTH-
C     SHOULD BE A INTEGER VARIABLE, RATHER THAN AN INTEGER CONSTANT.
C
      IF (DSKWRK.OR.MASWRK) READ(LFILE, END=200, ERR=300) REGION
C
C         IF RUNNING IN PARALLEL, AND THE FILE EXISTS ONLY
C         ON THE MASTER NODE (DSKWRK=.FALSE.), THEN THE DATA
C         SHOULD BE BROADCAST FROM THE MASTER TO ALL OTHER NODES.
C
      IF (GOPARR.AND.(.NOT.DSKWRK)) THEN
         CALL DDI_BCAST(230,'F',REGION,LENGTH,MASTER)
      END IF
      RETURN
C
C                  END OF FILE
C        THIS IS HANDLED BY RETURNING ZERO LENGTH READ, SO THE CALLER
C        CAN DETERMINE IF THIS IS REALLY AN ERROR, OR WAS EXPECTED.
C
  200 CONTINUE
      LENGTH=0
      RETURN
C
C                  ERROR READING FILE, PULL THE PLUG ON THE JOB
C
  300 CONTINUE
      WRITE(IW,9000) LFILE,ME,LENGTH
      CALL ABRT
C
      RETURN
 9000 FORMAT(1X,'ERROR READING FILE',I4,' ON NODE',I5,' LENGTH=',I10)
      END
C*MODULE IOLIB   *DECK SQWRIT
      SUBROUTINE SQWRIT (LFILE,REGION,LENGTH)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION REGION(LENGTH)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     WRITE AN ARRAY REGION OF LENGTH LENGTH TO UNIT LFILE
C
      IF (DSKWRK.OR.MASWRK) WRITE(LFILE,ERR=300) REGION
C
      RETURN
C
  300 CONTINUE
      WRITE(6,9020) ME,LFILE
 9020 FORMAT(1X,'SQWRIT: NODE',I4,
     *          ' ENCOUNTERED I/O ERROR WRITING UNIT',I4)
      CALL ABRT
C
      RETURN
      END
C
C*MODULE IOLIB   *DECK CCOPEN
      SUBROUTINE CCOPEN(IUNIT,IRECLN,FNAME)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXUNIT=299)
C
      CHARACTER*256 FILENM
      CHARACTER*(*) FNAME
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /OPNNFT/ NFTOPN(MXUNIT)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C        ----- OPEN DIRECT ACCESS FILES USED BY CC PROGRAM -----
C
      IF(IUNIT.GT.MXUNIT) THEN
         WRITE(IW,900) IUNIT,MXUNIT
         CALL ABRT
      END IF
      IF(NFTOPN(IUNIT).EQ.1) RETURN
      NFTOPN(IUNIT) = 1
  900 FORMAT(1X,'CCOPEN: ATTEMPT TO OPEN FILE',I5,
     *          ' GREATER THAN MAXIMUM',I5)
C
      IF (MASWRK) THEN
C
*IBM  OPEN (UNIT=IUNIT, FILE=FNAME, STATUS='UNKNOWN',
*IBM *      ACCESS='DIRECT', FORM='UNFORMATTED', RECL=8*IRECLN)
C
#if defined(SPEC_CPU)
      CALL DUMMYGETENV(FNAME,FILENM)
#else
      CALL GETENV(FNAME,FILENM)
#endif
      OPEN (UNIT=IUNIT, FILE=FILENM, STATUS='UNKNOWN',
     *      ACCESS='DIRECT', FORM='UNFORMATTED',
     *      RECL=8*IRECLN)
C
*VMS  OPEN (UNIT=IUNIT, FILE=FNAME, STATUS='UNKNOWN',
*VMS *      ACCESS='DIRECT', FORM='UNFORMATTED', RECL=2*IRECLN)
C
      END IF
      RETURN
      END

C  9 DEC 03 - MWS - SYNCH COMMON BLOCK RUNOPT
C  3 SEP 03 - SPW - MIITER: ADD CIS ARGUMENT TO TWOEI CALL
C 12 DEC 02 - MWS - MIITER: SYNCH UP HSTAR ARGUMENTS
C 17 APR 02 - MWS - SYNCH UP FRGINF COMMON
C 26 MAR 02 - KRG - USE ABRT CALL
C  6 SEP 01 - MWS - ADD DUMMY ARGUMENTS TO NAMEIO CALL
C 25 JUN 01 - MWS - ALTER COMMON BLOCK SCFOPT
C 26 OCT 00 - MWS - INTRODUCE MXAO PARAMETER
C 11 JUN 00 - MWS - ALWAYS ALLOCATE HONDO INTEGRAL BUFFER
C 12 NOV 98 - MAF - MIITER: ALLOW FOR USE OF SPHERICAL HARMONICS
C 12 SEP 98 - MWS - MIITER: UPDATE CALLS TO RCNFLD, EFPCMP
C  1 OCT 97 - AF  - INCLUDE SCF-MI OPTION IN GAMESS
C
C      ****************************************************
C      *                     SCF-MI                       *
C      * SELF CONSISTENT FIELD FOR MOLECULAR INTERACTIONS *
C      ****************************************************
C               (DIRECT AND CONVENTIONAL)
C     ----- CLOSED SHELL SCF-MI CALCULATION -----
C      E. GIANINETTI, M. RAIMONDI, E. TORNAGHI
C      INT. J. QUANTUM CHEM. 60, 157 (1996)
C      IMPLEMENTED BY ANTONINO FAMULARI
C
C  4 OCT 96 CLEAN UNUSED VECTORS IN SCFMAIN
C 26 SEP 96 FM MEMORY BY GAMESS ROUTINE
C 25 SEP 96 PROBLEM WITH POINTERS: "RETURN" INSEAD OF "GOTO 400"
C  6 SEP 96 UPGRADE DI SCF-MI A NEW GAMESS
C  9 AUG 96 VERSION GRADIENT TEST
C 10 JUL 96 USE OF BLAS (DUMMIES) LIBRARY=2 (BLAS)
C
C*MODULE SCFMI   *DECK MIINP
      SUBROUTINE MIINP
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=500)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NAINF,NBINF,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /MIOPT / ALPHA,DTOL,MIFLAG,NA,NB,MA,MB,MSHIFT,ITER,IOPT
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,CITYP,DFTYPE,CCTYP,MPLEVL,MPCTYP
C
C     ----- SET UP NAMELIST SIMULATION FOR $SCFMI-----
C
      PARAMETER (NNAM=9)
      DIMENSION QNAM(NNAM), KQNAM(NNAM)
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA SCFMINP/8HSCFMI   /
#else
      CHARACTER*8 :: SCFMINP_STR
      EQUIVALENCE (SCFMINP, SCFMINP_STR)
      DATA SCFMINP_STR/"SCFMI   "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA QNAM/8HNA      ,8HNB      ,8HMA      ,8HMB      ,
     *          8HMSHIFT  ,8HITER    ,8HDTOL    ,8HIOPT    ,8HALPHA   /
#else
      CHARACTER*8 :: QNAM_STR(NNAM)
      EQUIVALENCE (QNAM, QNAM_STR)
      DATA QNAM_STR/"NA      ","NB      ","MA      ","MB      ",
     *          "MSHIFT  ","ITER    ","DTOL    ","IOPT    ","ALPHA   "/
#endif
      DATA KQNAM/1,1,1,1,1,1,3,1,3/
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA RNONE,RHF/8HNONE    ,8HRHF     /
#else
      CHARACTER*8 :: RHF_STR
      EQUIVALENCE (RHF, RHF_STR)
      CHARACTER*8 :: RNONE_STR
      EQUIVALENCE (RNONE, RNONE_STR)
      DATA RNONE_STR,RHF_STR/"NONE    ","RHF     "/
#endif
C
C        ---- READ POSSIBLE $SCFMI INPUT GROUP -----
C
      NA = 0
      NB = 0
      MA = 0
      MB = 0
      MSHIFT=0
      ITER=50
      DTOL=1.0D-10
      IOPT=0
      ALPHA=0.0D+00
C
      JRET=0
      CALL NAMEIO(IR,JRET,SCFMINP,NNAM,QNAM,KQNAM,
     *            NA,NB,MA,MB,MSHIFT,ITER,DTOL,IOPT,ALPHA,
     *     0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *     0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *     0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0)
C
C         IF NOT FOUND IN INPUT, WE ARE NOT DOING SCF-MI CALCULATION
C
      MIFLAG=0
      IF(JRET.EQ.1) RETURN
      MIFLAG=1
C
C         PRINT $SCFMI PARAMETERS
C
      WRITE(IW,6666)
C
      NERR=0
      IF(JRET.EQ.2) NERR=NERR+1
      IF(NA.LE.0  .OR.  NB.LE.0) THEN
         WRITE(IW,*) 'ERROR - NA AND NB MUST BE POSITIVE VALUES'
         NERR=NERR+1
      END IF
      IF(NA+NB  .NE.  NAINF) THEN
         WRITE(IW,*) 'ERROR - NA+NB MUST EQUAL NO. OCC. MO-S =',NAINF
         NERR=NERR+1
      END IF
      IF(MA.LT.NA  .OR.  MB.LT.NB) THEN
         WRITE(IW,*) 'ERROR - MA AND MB MUST EXCEED NA AND NB'
         NERR=NERR+1
      END IF
      IF(MA+MB  .NE.  NUM) THEN
         WRITE(IW,*) 'ERROR - MA+MB MUST EQUAL TOTAL NO. AO-S =',NUM
         NERR=NERR+1
      END IF
      IF(SCFTYP.NE.RHF) THEN
         WRITE(IW,*) 'ERROR - SCFMI WORKS ONLY WITH -RHF- WAVEFUNCTIONS'
         NERR=NERR+1
      END IF
      IF(MPLEVL.NE.0  .OR.  CITYP.NE.RNONE) THEN
         WRITE(IW,*) 'ERROR - SCFMI DOES NOT PERMIT CORRELATION'
         NERR=NERR+1
      END IF
      IF(NPROC.GT.1) THEN
         WRITE(IW,*) 'ERROR - SCFMI DOES NOT RUN IN PARALLEL'
         NERR=NERR+1
      END IF
C
      WRITE(IW,*) 'NA ==>',NA
      WRITE(IW,*) 'NB ==>',NB
      WRITE(IW,*) 'MA ==>',MA
      WRITE(IW,*) 'MB ==>',MB
      WRITE(IW,*) 'MSHIFT ==>',MSHIFT
      WRITE(IW,*) 'ITER ==>',ITER
      WRITE(IW,*) 'DTOL ==>',DTOL
      WRITE(IW,*) 'IOPT ==>',IOPT
      WRITE(IW,*) 'ALPHA ==>',ALPHA
C
      IF(NERR.GT.0) THEN
         WRITE(IW,*) 'ERROR IN $SCFMI INPUT, JOB IS TERMINATING.'
         CALL ABRT
      END IF
      RETURN
C
 6666 FORMAT(//1X,60('*')/1X,'SCF-MI - SCF FOR MOLECULAR',
     *            ' INTERACTIONS BY ANTONINO FAMULARI'/1X,60('*')/)
      END
C
C*MODULE SCFMI   *DECK SCFMI
      SUBROUTINE SCFMI
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      COMMON /ADDI  / I1,I2,I3,I4,I5,I6,I7,I8,I9,I10,I11,I12,I13,
     + I14,I15,I16,I17,I18,I19,I20,I21,I22,I23,I24,I25,I26,I27,I28,I29,
     + I30,I31,I32,I33,I34,I35,I36,I37,I38,I39,I40,I41,I42,I43,I44,I45,
     + I46,I47,I48,I49,I50,I51,I52,I53,I54,I55,I56,I57
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /MIOPT / ALPHA,DTOL,MIFLAG,NA,NB,MA,MB,MSHIFT,ITER,IOPT
C
      M=MA+MB
      N=NA+NB
      WRITE(IW,*) 'TOTAL NUMBER OF AOS',M
      WRITE(IW,*) 'TOTAL NUMBER OF DOUBLE OCCUPIED MOS',N
C
      MTR=M*(M+1)/2
      MMAS=MAX(MA,MB)
C
C     ----- SET POINTERS FOR PARTITIONING OF THE MEMORY -----
C
C READ THE LAST OCCUPIED POSITION IN X(1)
      CALL VALFM(LOADFM)
      IF(IOPT.GT.1) THEN
         WRITE(IW,*) 'START FIRST BLOCK --> NEED1'
         WRITE(IW,*) 'LOADFM -->',LOADFM
      END IF
C
      IDBL=1
      I1 = LOADFM + 1 + MSHIFT
C     IV(I1) ==> T
      I2 =I1  + N*M*IDBL + MSHIFT
C     IV(I2) ==> SAO
      I3 =I2  + M*M*IDBL + MSHIFT
C     IV(I3) ==> HAO
      I4 =I3  + MTR*IDBL + MSHIFT
C     IV(I4) ==> P
      I5 =I4  + MTR*IDBL + MSHIFT
      I6 =I5
      I7 =I6
      I8 =I7
      I9 =I8
C     IV(I9) ==> SOCC
      I10=I9  + N*N*IDBL + MSHIFT
C     IV(I10) ==> SWORK
      I11=I10 + MAX(M*M,N*N,N*100)*IDBL + MSHIFT
C     IV(I11) ==> TTOT
      I12=I11 + M*M*IDBL + MSHIFT
      I13=I12
C
      NEED1=I13-LOADFM-1
C
C GET THE FIRST BLOCK OF MEMORY NEED1
      CALL GETFM(NEED1)
      CALL GOTFM(NGOTMX)
      IF(IOPT.GT.1) THEN
         WRITE(IW,*) 'NEED1 --> ', NEED1
         WRITE(IW,*) 'NGOTMX --> ', NGOTMX
      END IF
      CALL VALFM(LOADFM)
      IF(IOPT.GT.1) THEN
         WRITE(IW,*) 'LOADFM --> ',LOADFM
      END IF
C......
C INITIALIZE EIGENVECTORS ON A AND B
C......
C     CALL MIINIT(X(I1),X(I11),MIO,NA,NB,MA,N,M)
C
C......
C MIITER
C......
C READ THE LAST OCCUPIED POSITION IN X(1)
      CALL VALFM(LOADFM)
      IF(IOPT.GT.1) THEN
         WRITE(IW,*) 'START SECON BLOCK --> NEED2'
         WRITE(IW,*) 'LOADFM --> ',LOADFM
      END IF
C
C
      I13=LOADFM+1
C
      I14=I13
      I15=I14
      I16=I15
      I17=I16
      I18=I17
      I19=I18
      I20=I19
      I21=I20
      I22=I21
C     IV(I22) ==> DPREV
      I23=I22 + MTR*IDBL + MSHIFT
C     IV(I23) ==> SOVA, SOVB AND GKEEP
      I24=I23 + MAX(NA*NA,NB*NB,MA*MA)*IDBL + MSHIFT
      I25=I24
      I26=I25
C     IV(I26) ==> TOTG
      I27=I26 + M*M*IDBL + MSHIFT
C     IV(I27) ==> ROOT
      I28=I27 + MAX(MMAS,N)*IDBL + MSHIFT
C     IV(I28) ==> RMAT
      I29=I28 + MMAS*M*IDBL + MSHIFT
C     IV(I29) ==> ZMAT
      I30=I29 + MMAS*MMAS*IDBL + MSHIFT
C     IV(I30) ==> GMATA
      I31=I30 + MA*MA*IDBL + MSHIFT
C     IV(I31) ==> SGA
      I32=I31 + MA*MA*IDBL + MSHIFT
C     IV(I32) ==> U
      I33=I32 + MMAS*(MMAS+2)*IDBL + MSHIFT
C     IV(I33) ==> GMATB
      I34=I33 + MB*MB*IDBL + MSHIFT
C     IV(I34) ==> SGB
      I35=I34 + MB*MB*IDBL + MSHIFT
C     IV(I35) ==> EIGEN
      I36=I35 + M*IDBL + MSHIFT
C     IV(I36) ==> EIGENWORK
      I37=I36 + M*IDBL + MSHIFT
C     IV(I37) ==> INDX
      I38=I37 + M*IDBL + MSHIFT
C     IV(I38) ==> TOTWORK
      I39=I38 + M*M*IDBL + MSHIFT
C     IV(I39) ==> FDUM
      I40=I39 + M*M*IDBL + MSHIFT
C     IV(I40) ==> FMO
      I41=I40 + N*N*IDBL + MSHIFT
C     IV(I41) ==> SMO
      I42=I41 + N*N*IDBL + MSHIFT
C     IV(I42) ==> EMO
      I43=I42 + N*IDBL + MSHIFT
C     IV(I43) ==> TMO
      I44=I43 + N*(N+2)*IDBL + MSHIFT
C     IV(I44) ==> TNEW
      I45=I44 + M*M*IDBL + MSHIFT
C     IV(I45) ==> DUM
      I46=I45 + MTR*IDBL + MSHIFT
C     IV(I46) ==> WORK
      I47=I46 + N*N*IDBL + MSHIFT
C     IV(I47) ==> SINV
      I48=I47 + N*N*IDBL + MSHIFT
C     IV(I48) ==> OVER
C     I49=I48 + M*M*IDBL + MSHIFT
      I49=I48 + MSHIFT
C
      NEED2=I49-LOADFM-1
C
C GET THE SECOND BLOCK OF MEMORY NEED2
      CALL GETFM(NEED2)
      CALL GOTFM(NGOTMX)
      IF(IOPT.GT.1) THEN
         WRITE(IW,*) 'NEED2 --> ', NEED2
         WRITE(IW,*) 'NGOTMX --> ', NGOTMX
      END IF
C
C WRITE ALL THE POINTERS OF MEMORY
      IF(IOPT.GT.1) THEN
         CALL MIPRNT(49)
      END IF
C
C
      CALL MIITER(X(I1),X(I2),X(I3),X(I4),X(I9),X(I10),
     + X(I26),X(I27),X(I28),X(I29),
     + X(I30),X(I31),X(I32),X(I33),X(I34),
     + X(I23),X(I23),X(I22),X(I11),X(I23),ERN,DTOL,
     + NA,NB,MA,MB,MMAS,ITER,N,M,MTR,IOPT,
     + X(I35),X(I36),X(I37),X(I38),X(I39),
     + X(I40),X(I41),X(I42),X(I43),X(I44),X(I45),X(I46),X(I47),
     + ALPHA)
C
C CLEAN THE BLOCKS OF MEMORY NEED1 AND NEED2
      CALL RETFM(NEED2)
      CALL RETFM(NEED1)
      RETURN
      END
C*MODULE SCFMI   *DECK MIINIT
      SUBROUTINE MIINIT(T,TTOT,NA,NB,MA,N,M)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION T(M,N),TTOT(M,M)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
C
      DATA ZERO/0.0D+00/,ICONT/1/
C
      SAVE ICONT
C
      IF(ICONT.GT.1) THEN
         CALL DAREAD(IDAF,IODA,TTOT,M*M,316,0)
      END IF
C.....
C REMOVE ANY SPURIOUS COMPONENTS
C.....
      DO 1300 I=1,MA
      DO 1300 J=MA+1,M
1300  TTOT(J,I)=ZERO
      DO 1400 I=MA+1,M
      DO 1400 J=1,MA
1400  TTOT(J,I)=ZERO
C.....
C BUILD OCCUPIED MOS MATRIX T
C.....
      DO 2100 IOCC=1,NA
      DO 2100 I=1,M
2100  T(I,IOCC)=TTOT(I,IOCC)
      DO 2200 JOCC=1,NB
      DO 2200 J=1,M
2200  T(J,NA+JOCC)=TTOT(J,MA+JOCC)
C
      ICONT=ICONT+1
C
      RETURN
      END
C
C
C
C...
C  VARIABLE NAMES CHANGED IN SUBROUTINE MIITER
C  TO AVOID OVERLAP WITH GAMESSUSA
C...
C ITER ... ITERSCFMI
C NA   ... NASCFMI
C NB   ... NBSCFMI
C II   ... IISCFMI
C IA   ... IASCFMI
C ZERO ... ZEROSCFMI
C HALF ... HALFSCFMI
C DDIFF ... DDIFFSCFMI
C IP    ... IPMI
C*MODULE SCFMI   *DECK MIITER
      SUBROUTINE MIITER(T,SAO,HAO,P,SOCC,SWORK,
     + TOTG,ROOT,RMAT,ZMAT,
     + GMATA,SGA,U,GMATB,SGB,
     + SOVA,SOVB,DPREV,TTOT,GKEEP,ERN,DTOL,
     + NASCFMI,NBSCFMI,MA,MB,MMAS,ITERSCFMI,N,M,MTR,IOPT,
     + EIGEN,EIGENWORK,INDX,TOTWORK,FDUM,FMO,SMO,EMO,TMO,TNEW,DUM,
     + WORK,SINV,ALPHA)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL PACK2E,OUT,SOME,DIRSCF,FDIFF,SCHWRZ
      LOGICAL DODIIS,DAMPH,EXTRAH,VSHIFT,RSTRCT,DEM
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW
      LOGICAL ABINIT,MINMEM,VTSCAL,VIROK,LVCLN,IZRFLS
      LOGICAL DOMBAS,SOSCF,FT15OP
C
      DOUBLE PRECISION MOROKM
C
      DIMENSION T(M,N),SAO(M,M),HAO(MTR),P(MTR),
     + SOCC(N,N),SWORK(M,*),TOTG(M*M),
     + GMATA(MA,MA),RMAT(MMAS,M),SGA(MA,MA),ZMAT(MMAS,MMAS),
     + ROOT(MMAS),U(MMAS,MMAS+2),GMATB(MB,MB),SGB(MB,MB),
     + SOVA(NASCFMI,NASCFMI),SOVB(NBSCFMI,NBSCFMI),DPREV(MTR),
     + TTOT(M,M),GKEEP(MA,MA)
C
      DIMENSION EIGEN(M),EIGENWORK(M),INDX(M),TOTWORK(M,M)
      DIMENSION FDUM(M,M),FMO(N,N)
      DIMENSION SMO(N,N)
      DIMENSION EMO(N),TMO(N,N+2)
      DIMENSION TNEW(M,M)
      DIMENSION DUM(MTR)
      DIMENSION WORK(N,N),SINV(N,N)
C
C ***** FROM GAMESS
C
      PARAMETER (MXSH=1000, MXGTOT=5000, MXGSH=30, MXG2=MXGSH*MXGSH,
     *           MXATM=500, MXFRG=50, MXAO=2047)
C
      COMMON /ACONV / RRSHFT,EXTTOL,DMPTOL,VSHTOL,IEXTIN
      COMMON /CONV  / DENTOL,EN,ETOT,EHF,EHF0,DIFF,ITER,ICALP,ICBET
      COMMON /DIISSO/ SOGTOL,ETHRSH,MAXDII,IRAF
      COMMON /DMPING/ SHIFTO,SHIFTV,DMPCUT
      COMMON /FMCOM / X(1)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG
      COMMON /FUNCT / ENERGY,EGRAD(3,MXATM)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INDDIP/ TMUX,TMUY,TMUZ,TMUXD,TMUYD,TMUZD,MINMEM
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTG76
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /N2ELCT/ N2EL
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH
      COMMON /VIRIAL/ SCALTE,SCALTT,GVIR,VTCONV,MAXVT,VTSCAL,VIROK,LVCLN
      COMMON /WFNOPT/ SCFTYP,CITYP,DFTYPE,CCTYP,MPLEVL,MPCTYP
      COMMON /ZRFPAR/ GZRF,FIND(3),GNUCF,EBORN,DIELEC,IZRF,ICALC
C
      PARAMETER (ZERO=0.0D+00, HALF=0.5D+00, TWO=2.0D+00)
C
      SAVE FT15OP
C
      DATA FT15OP/.FALSE./
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA DEBUG/8HDEBUG   /, DBUGME/8HRHFCL   /
#else
      CHARACTER*8 :: DEBUG_STR
      EQUIVALENCE (DEBUG, DEBUG_STR)
      CHARACTER*8 :: DBUGME_STR
      EQUIVALENCE (DBUGME, DBUGME_STR)
      DATA DEBUG_STR/"DEBUG   "/, DBUGME_STR/"RHFCL   "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA RHF/8HRHF     /
#else
      CHARACTER*8 :: RHF_STR
      EQUIVALENCE (RHF, RHF_STR)
      DATA RHF_STR/"RHF     "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA MOROKM/8HMOROKUMA/, OPTMZE/8HOPTIMIZE/
#else
      CHARACTER*8 :: MOROKM_STR
      EQUIVALENCE (MOROKM, MOROKM_STR)
      CHARACTER*8 :: OPTMZE_STR
      EQUIVALENCE (OPTMZE, OPTMZE_STR)
      DATA MOROKM_STR/"MOROKUMA"/, OPTMZE_STR/"OPTIMIZE"/
#endif
      DATA ZEROSCFMI/0.0D+00/,HALFSCFMI/0.5D+00/,IOUT/6/
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA NONE/4HNONE/
#else
      CHARACTER*4 :: NONE_STR
      EQUIVALENCE (NONE, NONE_STR)
      DATA NONE_STR/"NONE"/
#endif
C
C     ----- CLOSED SHELL HF-SCF CALCULATION -----
C     C.C.J.ROOTHAAN, REV.MOD.PHYS.  23,69-89(1951)
C
      ABINIT = MPCTYP.EQ.NONE
C
C         DIFFERENTIAL FOCK FORMATION IS NOT SUPPORTED
C
      IF(DIRSCF) FDIFF=.FALSE.
C
      IZRFLS = IZRF.NE.0
C
      OUT    = .FALSE.
      SOME   = .FALSE.
C     PRDENS = .FALSE.
      IF(MASWRK) THEN
        OUT    = NPRINT.EQ.5  .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME
        SOME   = NPRINT.NE.-5 .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME
C       PRDENS = NPRINT.GT. 8 .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME
      END IF
      IF(SOME) WRITE(IW,9000)
C
C     ----- START THE CLOCKS -----
C
      TIM0 = ZERO
      CALL TSECND(TIM0)
C
C     ----- SELECT CONVERGENCE METHOD(S) -----
C
      EXTRAH = MOD(MCONV,2)  .EQ. 1
      DAMPH  = MOD(MCONV,4)  .GE. 2
      VSHIFT = MOD(MCONV,8)  .GE. 4
      RSTRCT = MOD(MCONV,16) .GE. 8
      DODIIS = MOD(MCONV,32) .GE.16
      DEM    = MOD(MCONV,64) .GE.32
      SOSCF  = MOD(MCONV,128).GE.64
C
C     ----- SET POINTERS FOR PARTITIONING OF MEMORY -----
C
      IF (RUNTYP.EQ.MOROKM) THEN
         CALL STRHF(NUM,NA,NB,NE,NST,LL1,LL2,LL3,DOMBAS)
      ELSE
         NST = 1
         LL1 = NUM
         LL2 = (LL1*LL1+LL1)/2
         LL3 = LL1*LL1
         DOMBAS=.FALSE.
      END IF
C
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
C
      MAXIT2=(MAXIT*MAXIT+MAXIT)/2
      MAXIT3=MAXIT*MAXIT
C
      NSH2 = (NSHELL*NSHELL+NSHELL)/2
C
      CALL VALFM(LOADFM)
      CALL GOTFM(NGOTMX)
      IF(IOPT.GT.1) THEN
         WRITE(IW,*) 'BIFORE ALLOCATION'
         WRITE(IW,*) 'LOADFM',LOADFM
         WRITE(IW,*) 'NGOTMX',NGOTMX
      END IF
C
      LSCR  = LOADFM + 1
      LIWRK = LSCR   + L1*8
      LWRK  = LIWRK  + L1
      LWRK1 = LWRK   + L1
      LWRK2 = LWRK1  + LL3
      LWRK3 = LWRK2  + LL3
      LEIG  = LWRK3  + LL3
      LOCC  = LEIG   + LL1
      LFAO  = LOCC   + L1
      LD    = LFAO   + LL2
      LVEC  = LD     + LL2
      LAST  = LVEC   + LL3
C
C
      CALL BASCHK(LMAX)
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      MAXG = NANGM**4
C
      IF(ABINIT) THEN
         IF(DIRSCF) THEN
            LBUF  = LAST
            LIBUF = LAST
            LXINTS= LAST
            LGHOND= LXINTS + NSH2
            LDSH  = LGHOND + MAXG
            LDDIJ = LDSH   + NSH2
            LAST  = LDDIJ  + 16*MXG2
         ELSE
            LXINTS= LAST
            LGHOND= LAST
            LDSH  = LAST
            LDDIJ = LAST
            LBUF  = LAST
            LIBUF = LBUF   + NINTMX
            LAST  = LIBUF  + NINTMX
         END IF
         LTWOEI= LAST
         LPTOT2= LAST
      ELSE
         LXINTS= LAST
         LGHOND= LAST
         LDSH  = LAST
         LDDIJ = LAST
         LBUF  = LAST
         LIBUF = LAST
         LTWOEI= LAST
         LPTOT2= LTWOEI + N2EL
         LAST  = LPTOT2 + NAT*16
      END IF
C
      IF(DODIIS) THEN
         LADIIS = LAST
         LBDIIS = LADIIS + MAXIT3
         LPDIIS = LBDIIS + MAXIT2
         LXDIIS = LPDIIS + MAXIT
         LIODII = LXDIIS + MAXIT
         LAST   = LIODII + 2*MAXDII
      ELSE
         LADIIS = LAST
         LBDIIS = LAST
         LPDIIS = LAST
         LXDIIS = LAST
         LIODII = LAST
      END IF
C
      IF(DEM) THEN
         LWRK4 = LAST
         LWRK5 = LWRK4 + L3
         LAST  = LWRK5 + L3
      ELSE
         LWRK4 = LAST
         LWRK5 = LAST
      END IF
C
      IF (IZRFLS .OR. IEFP.EQ.1) THEN
         LXDINT = LAST
         LYDINT = LXDINT  + L2
         LZDINT = LYDINT  + L2
         LAST   = LZDINT  + L2
      ELSE
         LXDINT = LAST
         LYDINT = LAST
         LZDINT = LAST
      END IF
      IF((IZRFLS .OR. IEFP.EQ.1) .AND. (DIRSCF.AND.FDIFF)) THEN
         NDIPER = LAST
         LDIPER = NDIPER  + L2
         LAST   = LDIPER  + L2
      ELSE
         NDIPER = LAST
         LDIPER = LAST
      END IF
      IF(IEFP.EQ.1)THEN
         LEFLD  = LAST
         MADD   = LEFLD  + 3*NPTTPT
         LABFLD = MADD   + 3*NPTTPT
         LAST   = LABFLD + 3*NPTTPT
      ELSE
         LEFLD  = LAST
         MADD   = LAST
         LABFLD = LAST
      END IF
C
      NFT15=15
      NPR=(NUM-NA)*NA
      IF (SOSCF) THEN
         LGRAD  = LAST
         LHESS  = LGRAD  + NPR
         LPGRAD = LHESS  + NPR
         LDISPL = LPGRAD + NPR
         LAST   = LDISPL + NPR
      ELSE
         LGRAD  = LAST
         LHESS  = LAST
         LPGRAD = LAST
         LDISPL = LAST
      END IF
C
C        WE CAN REDUCE MEMORY NEED BY 2N**2 BY DOING MORE DAREADS,
C        TO OVERLAP -H1- AND -WRK1-, -Q- AND -WRK2-, -S- AND -WRK3-.
C
      NEED = LAST - LOADFM - 1
      NSAVE = 2*LL2 + LL3
      NEEDI = NEED + NSAVE
      IF(DEM .OR. VSHIFT .OR. (NEEDI.LT.NGOTMX)) THEN
         MINMEM = .FALSE.
         LH1   = LAST
         LQ    = LH1    + LL2
         LS    = LQ     + LL3
         LAST  = LS     + LL2
C
         NEED  = LAST -LOADFM -1
      ELSE
         MINMEM = .TRUE.
         IF(SOME) WRITE(IW,9005) NSAVE
         LH1 = LWRK1
         LQ  = LWRK2
         LS  = LWRK3
         WRITE(6,*)' ATTENTION!!! '
         WRITE(6,*)' NEEDI --> ',NEEDI
         WRITE(6,*)' NGOTMX --> ',NGOTMX
         WRITE(6,*)' MINMEM ->',MINMEM
         CALL ABRT
      END IF
C
C     ----- GET MEMORY -----
C
      CALL GETFM(NEED)
      CALL VALFM(LOADFM)
      CALL GOTFM(NGOTMX)
C
C     ----- INITIALIZE OCCUPATION NUMBERS -----
C
      CALL VCLR(X(LOCC),1,L1)
      DO 120 I = NST,NA+NST-1
         X(LOCC-1+I) = TWO
  120 CONTINUE
C
C     ----- INITIALIZE VARIABLES -----
C
      IF(MAXIT.LE.0) MAXIT = 30
C
      IF(DIRSCF) THEN
         DENTOL = TWO * CONVHF
         ENGTOL = 1.0D-08
C        DIITOL = 1.0D-06
      ELSE
         DENTOL = CONVHF
         ENGTOL = 1.0D-09
C        DIITOL = 1.0D-07
      END IF
      IF(RUNTYP.EQ.OPTMZE  .AND.  NEVALS.GT.0) THEN
         GRMS = DDOT(3*NAT,EGRAD,1,EGRAD,1)
         GRMS = SQRT(GRMS/(3*NAT))
                               CFACT =  1.0D+00
         IF(GRMS.GT.0.005D+00) CFACT =  5.0D+00
         IF(GRMS.GT.0.020D+00) CFACT = 20.0D+00
         IF(GRMS.GT.0.100D+00) CFACT = 50.0D+00
         DENTOL = CFACT*DENTOL
         ENGTOL = CFACT*ENGTOL
C        DIITOL = CFACT*ENGTOL
      END IF
C
      MPUNCH = NPUNCH
      EHF = ZERO
      ETOT= ZERO
      ICALP = 0
C     DAMP = ZERO
      IF (DMPCUT .LE. ZERO) DMPCUT = ZERO
      RRSHFT = ZERO
      DIFF = ZERO
C     IF(DAMPH .OR. VSHIFT) DAMP = ONE
C
      II = 0
      DO 140 I = 1,L1
         IA(I) = II
         II = II + I
  140 CONTINUE
C
C     ----- PRINT SCF OPTIONS -----
C
      IF(SOME) THEN
         WRITE(IW,9010) EN,MAXIT,MPUNCH,EXTRAH,DAMPH,
     *                  VSHIFT,RSTRCT,DODIIS,DEM,SOSCF,DENTOL
         IF(VTSCAL) WRITE(IW,9015) VTSCAL,MAXVT,VTCONV
         IF(SOSCF) WRITE(IW,9017) NPR,SOGTOL
         WRITE(IW,9020) NEED
      END IF
C CHANGE...
C     IF(EXETYP.EQ.CHECK) GO TO 500
C
C
C     ----- EXCHANGE INTEGRALS FOR DIRECT SCF THRESHOLD TESTS -----
C
      NINT=0
      NSCHWZ=0
      IF(DIRSCF.AND.ABINIT) THEN
         SCHWRZ = ISCHWZ.GT.0
         IF (MASWRK) WRITE(IW,9030) SCHWRZ,FDIFF
         IF(SCHWRZ) CALL EXCHNG(X(LXINTS),X(LGHOND),X(LDDIJ),
     *                          NSH2,MAXG,INTG76)
      ELSE
         SCHWRZ=.FALSE.
      END IF
C
C     ----- READ IN MOPAC 2-ELECTRON INTEGRALS -----
C
      IF(MPCTYP.NE.NONE  .AND.  N2EL.GT.0)
     *   CALL DAREAD(IDAF,IODA,X(LTWOEI),N2EL,53,0)
C
C     ----- READ BARE NUCLEUS HAMILTONIAN -----
C     ----- READ OVERLAP INTEGRALS -----
C     ----- READ INITIAL DENSITY MATRIX -----
C     ----- READ SYMMETRY ADAPTED Q MATRIX -----
C     L0 = NUMBER OF CANONICAL ORTHONORMAL VECTORS KEPT.
C
      IF(.NOT.MINMEM) THEN
         CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
         CALL DAREAD(IDAF,IODA,X(LS) ,LL2,12,0)
         CALL DAREAD(IDAF,IODA,X(LQ) ,LL3,45,0)
      END IF
      CALL DAREAD(IDAF,IODA,X(LD),LL2,16,0)
C
      IF(SOSCF) THEN
         CALL DAREAD(IDAF,IODA,X(LVEC),LL3,15,0)
         CALL DAREAD(IDAF,IODA,X(LEIG),LL1,17,0)
         SVDSKW = DSKWRK
         DSKWRK = .FALSE.
         IF(.NOT.FT15OP) THEN
            FT15OP = .TRUE.
            CALL SEQOPN(NFT15,'WORK15','UNKNOWN',.FALSE.,'UNFORMATTED')
         ELSE
            CALL SEQREW(NFT15)
         END IF
         DSKWRK = SVDSKW
      END IF
C
C     ----- PREVIOUS DENSITY IS ZERO, PREVIOUS FOCK MAT. IS HCORE -----
C
      IF(DIRSCF  .AND.  FDIFF) THEN
         IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
         CALL DAWRIT(IDAF,IODA,X(LH1),LL2,14,0)
         CALL VCLR(X(LWRK1),1,L2)
      END IF
C
C     ----- IF SCRF SAVE PRISTINE ONE ELEC. HAM. -----
C     -----    AND READ IN DIPOLE INTEGRALS      -----
C
      IF(IZRFLS) THEN
         CALL DAWRIT(IDAF,IODA,X(LH1),LL2,87,0)
         CALL DAREAD(IDAF,IODA,X(LXDINT),LL2,95,0)
         CALL DAREAD(IDAF,IODA,X(LYDINT),LL2,96,0)
         CALL DAREAD(IDAF,IODA,X(LZDINT),LL2,97,0)
      END IF
      IF(IEFP.EQ.1) CALL DAWRIT(IDAF,IODA,X(LH1),LL2,87,0)
C
C
C     ----- PRINT ITERATION HEADER -----
C
      IF (MASWRK) THEN
      IF(DAMPH  .OR.  VSHIFT) THEN
         IF(SOSCF) THEN
            IF(.NOT.DIRSCF) WRITE(IW,9040)
            IF(     DIRSCF) WRITE(IW,9050)
         ELSE
            IF(.NOT.DIRSCF) WRITE(IW,9045)
            IF(     DIRSCF) WRITE(IW,9055)
         END IF
      ELSE
         IF(SOSCF) THEN
            IF(.NOT.DIRSCF) WRITE(IW,9060)
            IF(     DIRSCF) WRITE(IW,9070)
         ELSE
            IF(.NOT.DIRSCF) WRITE(IW,9065)
            IF(     DIRSCF) WRITE(IW,9075)
         END IF
      END IF
      END IF
C
C  *****
C
C
C
C     SCF-MI GUESS ORBITALS
C
      CALL DAREAD(IDAF,IODA,TTOT,LL3,15,0)
C---  WRITE(IOUT,6300) 'X(LVEC) COEFFICIENTS'
C---  CALL PRSQL(TTOT,M,M,M)
      CALL MIINIT(T,TTOT,NASCFMI,NBSCFMI,MA,N,M)
C---  WRITE(IOUT,6300) 'INITIAL COEFFICIENTS'
C---  CALL PRSQL(T,N,M,M)
C
C COPY MATRIX H INTO HAO X(LH1)-->HAO
      CALL DCOPY(MTR,X(LH1),1,HAO,1)
C TRASFORMATION X(LS)-->SAO(M,M)
      CALL CPYTSQ(X(LS),SAO,M,1)
C COPY NUCLEAR ENERGY EN --> ERN
      ERN=EN
      WRITE(IW,*) 'NUCLEAR ENERGY',ERN
C
C...
C INIZIALIZE ENERGY VARIABLES
C..
      ENER=ZEROSCFMI
      ENEROLD=ZEROSCFMI
C
C...
C FLAG FOR CONVERGENCE OF SCF-MI
C..
      ICONVSCFMI=0
C
C...
C LEVEL SHIFT
C...
      IF (ALPHA.GT.ZEROSCFMI) THEN
        WRITE(IW,*)'LEVEL SHIFT IS ACTIVE!'
        WRITE(IW,*)'ALPHA -->',ALPHA
      END IF
C
C.....
C SCF ITERATIONS
C.....
      DO 3000 IT=1,ITERSCFMI
      CALL FLSHBF(IW)
      IF(IOPT.NE.0) THEN
         WRITE(IW,*)'START OF ITERATION'
         CALL TIMIT(1)
      END IF
      WRITE(IOUT,'(/,1X,A,4X,I3)') 'ITERATION NUMBER',IT
C
      CALL DAWRIT(IDAF,IODA,TTOT,M*M,316,0)
C....
C OVERLAP MATRIX BETWEEN OCCUPIED OR TOTAL MOS
C.....
      DO 3100 IMO=1,N
      DO 3100 IQ=1,M
      SWORK(IQ,IMO)=ZEROSCFMI
      DO 3100 K=1,M
3100  SWORK(IQ,IMO)=SWORK(IQ,IMO)+T(K,IMO)*SAO(K,IQ)
C
      DO 3200 JMO=1,N
      DO 3200 IMO=1,N
      SOCC(IMO,JMO)=ZEROSCFMI
      DO 3200 K=1,M
3200  SOCC(IMO,JMO)=SOCC(IMO,JMO)+SWORK(K,IMO)*T(K,JMO)
C.....
C TA W-1 TA DENSITY OF THE FRAGMENT A
C.....
      DO 3300 J=1,NASCFMI
      DO 3300 I=1,NASCFMI
3300  SOVA(I,J)=SOCC(I,J)
      CALL MXINV(SOVA,SWORK,ROOT,NASCFMI)
      DO 3400 IASCFMI=1,MA
      DO 3400 J=1,NASCFMI
      SWORK(J,IASCFMI)=ZEROSCFMI
      DO 3400 K=1,NASCFMI
3400  SWORK(J,IASCFMI)=SWORK(J,IASCFMI)+T(IASCFMI,K)*SOVA(K,J)
C
      DO 3500 JA=1,MA
      DO 3500 IASCFMI=1,MA
      GMATA(IASCFMI,JA)=ZEROSCFMI
      DO 3500 K=1,NASCFMI
3500  GMATA(IASCFMI,JA)=GMATA(IASCFMI,JA)+SWORK(K,IASCFMI)*T(JA,K)
C.....
C TB W-1 TB DENSITY OF THE FRAGMENT B
C.....
      DO 3600 J=1,NBSCFMI
      DO 3600 I=1,NBSCFMI
3600  SOVB(I,J)=SOCC(I+NASCFMI,J+NASCFMI)
      CALL MXINV(SOVB,SWORK,ROOT,NBSCFMI)
      DO 3700 IB=1,MB
      DO 3700 J=1,NBSCFMI
      SWORK(J,IB)=ZEROSCFMI
      DO 3700 K=1,NBSCFMI
3700  SWORK(J,IB)=SWORK(J,IB)+T(MA+IB,NASCFMI+K)*SOVB(K,J)
C
      DO 3800 JB=1,MB
      DO 3800 IB=1,MB
      GMATB(IB,JB)=ZEROSCFMI
      DO 3800 K=1,NBSCFMI
3800  GMATB(IB,JB)=GMATB(IB,JB)+SWORK(K,IB)*T(MA+JB,NASCFMI+K)
C.....
C BUILD SIGMA, DENSITY AND FOCK MATRIX
C.....
      CALL MISIGMA(SAO,SGA,SGB,GMATA,GMATB,SWORK,MA,MB)
      CALL MXINV(SOCC,SWORK,ROOT,N)
      DO 4400 IPMI=1,M
      DO 4400 JMO=1,N
      SWORK(JMO,IPMI)=ZEROSCFMI
      DO 4400 K=1,N
4400  SWORK(JMO,IPMI)=SWORK(JMO,IPMI)+SOCC(K,JMO)*T(IPMI,K)
C
C...
C DENSITY D IN VECTOR P(MTR)
C P-->X(LD)
C...
      IPUT=0
      DO IQ=1,M
         DO IPMI=1,IQ
            IPUT=IPUT+1
            P(IPUT)=ZEROSCFMI
            X(LD+IPUT-1)=ZEROSCFMI
            DO K=1,N
               P(IPUT)=P(IPUT)+T(IQ,K)*SWORK(K,IPMI)
            END DO
            X(LD+IPUT-1)=P(IPUT)*2.0D+00
            DUM(IPUT)=X(LD+IPUT-1)
         END DO
         P(IPUT)=P(IPUT)*HALFSCFMI
      END DO
C
C.....
C COMPUTE DIFFERENCE IN DENSITY MATRIX
C.....
      IF(IT.EQ.1) THEN
        CALL DCOPY(MTR,P,1,DPREV,1)
        GOTO 4999
      ENDIF
      DDIFFSCFMI=ZEROSCFMI
      DO 4700 I=1,MTR
4700  DDIFFSCFMI=DDIFFSCFMI+(P(I)-DPREV(I))**2
      DDIFFSCFMI=DDIFFSCFMI/MTR
      WRITE(IOUT,*) 'DENSITY MATRIX CONVERGENCE:',DDIFFSCFMI
      CALL DCOPY(MTR,P,1,DPREV,1)
C
      IF(DDIFFSCFMI.LE.DTOL) THEN
        WRITE(IOUT,*) 'FINAL ENERGY',ENER
        ETOT=ENER
        IF(IOPT.NE.0) THEN
           WRITE(IW,*)'END OF THE ITERATIONS'
           CALL TIMIT(1)
        END IF
C
        ICONVSCFMI=1
        GOTO 4999
      ENDIF
C
4999  WRITE(IW,*)'START FOCK OPERATOR CALCULATION'
      CALL TIMIT(1)
C
C **** GAMESS
C GAMESS CALCULATION OF  FOCK MATRIX
C                   X(LFAO)
C
C           ********************
C     ***** START RHF ITERATIONS *****
C           ********************
C
C     DO 300 ITER=1,MAXIT
      CALL TSECND(TITER0)
C
C     ----- CONSTRUCT SKELETON 2 ELECTRON FOCK MATRIX -----
C     FOR DIRECT SCF,
C     EITHER -LWRK1- IS THE CHANGE IN THE DENSITY, WITH THE CHANGE
C     TO THE FOCK MATRIX TO BE COMPUTED IN -LFAO-, OR ELSE
C     -LWRK1- IS THE CURRENT DENSITY, WITH ALL 2 E- TERMS IN -LFAO-.
C
      IF (ABINIT) THEN
         IF(DIRSCF) THEN
            IF(FDIFF) THEN
               CALL VSUB(X(LWRK1),1,X(LD),1,X(LWRK1),1,L2)
            ELSE
               CALL DCOPY(L2,X(LD),1,X(LWRK1),1)
            END IF
            DUMMY = 0.0D+00
            IF(SCHWRZ) CALL SHLDEN(RHF,X(LWRK1),DUMMY,DUMMY,X(LDSH),
     *                             IA,L1,L2,NSH2,1)
            CALL VCLR(X(LFAO),1,L2)
            CALL TWOEI(RHF,DIRSCF,.FALSE.,.FALSE.,.FALSE.,
     *                 INTG76,SCHWRZ,NINT,NSCHWZ,L1,L2,
     *                 DUMMY,DUMMY,IDUMMY,1,
     *                 X(LXINTS),NSH2,X(LGHOND),MAXG,X(LDDIJ),
     *                 IA,X(LWRK1),X(LFAO),DUMMY,DUMMY,X(LDSH),
     *                 DUMMY,DUMMY,1)
C
C   --- DIRSCF OFF DIAGONAL ELEMENTS ARE DOUBLE THE CORRECT VALUE ---
C
            CALL DSCAL(L2,HALF,X(LFAO),1)
            II=LFAO-1
            DO 210 I=1,L1
               II = II+I
               X(II) = X(II) + X(II)
  210       CONTINUE
         ELSE
            SVDSKW = DSKWRK
            DSKWRK  = .TRUE.
            CALL SEQREW(IS)
            CALL HSTAR(X(LD),X(LFAO),X(LBUF),X(LIBUF),
     *                 NINTMX,IA,NOPK,.FALSE.)
            DSKWRK  = SVDSKW
         END IF
C
C   --- SUM UP PARTIAL FOCK MATRICES ---
C
C        IF (GOPARR) THEN
C           CALL DGOP(1000,X(LFAO),L2,'+')
C           CALL IGOP(1001,NINT,1,'+')
C           CALL IGOP(1002,NSCHWZ,1,'+')
C        END IF
      ELSE
         CALL MPCG(X(LD),X(LPTOT2),X(LFAO),X(LWRK1),X(LWRK2),
     *             X(LTWOEI),L2,N2EL,NAT)
      END IF
C
      IF(OUT) THEN
         WRITE(IW,*) '*** START OF DEBUG OUTPUT FOR ITERATION',ITER
         WRITE(IW,*) 'SKELETON FOCK MATRIX'
         CALL PRTRIL(X(LFAO),L1)
      END IF
C
C     ----- SYMMETRIZE SKELETON FOCK MATRIX -----
C     SCRATCH AREA AT LWRK1 IS USED AS A SYMMETRIC MATRIX
C
      CALL SYMH(X(LFAO),X(LWRK1),IA)
      IF(OUT) THEN
         WRITE(IW,*) 'SYMMETRIZED FOCK OPERATOR'
         CALL PRTRIL(X(LFAO),L1)
      END IF
C
C    -- IF SCRF GET PRISTINE ONE ELEC. HAM., CALC. INDUCED DIPOLES, --
C                   ----- ADD PERTURBATION. -----
C
      IF(IZRFLS) THEN
         CALL DAREAD(IDAF,IODA,X(LH1),LL2,87,0)
         IF(DIRSCF .AND. FDIFF) THEN
            CALL RCNFLD(X(LH1),X(LFAO),DUMMY,X(LD),X(NDIPER),
     *                  X(LDIPER),X(LXDINT),X(LYDINT),X(LZDINT),L2,L1,0)
         ELSE
            CALL RCNFLD(X(LH1),DUMMY,DUMMY,X(LD),DUMMY,
     *                  DUMMY,X(LXDINT),X(LYDINT),X(LZDINT),L2,L1,0)
         END IF
      END IF
C
C    -- IF FRAG GET PRISTINE ONE ELEC. HAM., CALC. INDUCED DIPOLES, --
C                   ----- ADD PERTURBATION. -----
C
      IF(IEFP.EQ.1) THEN
         CALL DAREAD(IDAF,IODA,X(LH1),LL2,87,0)
         IF(DIRSCF .AND. FDIFF) THEN
            CALL EFPCMP(X(LH1),X(LFAO),DUMMY,X(LD),X(NDIPER),
     *                  X(LDIPER),X(LXDINT),X(LYDINT),X(LZDINT),
     *                  X(LEFLD),X(MADD),X(LABFLD),L2,L1,0)
         ELSE
            CALL EFPCMP(X(LH1),DUMMY,DUMMY,X(LD),DUMMY,DUMMY,
     *                  X(LXDINT),X(LYDINT),X(LZDINT),X(LEFLD),
     *                  X(MADD),X(LABFLD),L2,L1,0)
         END IF
      END IF
C
C     ----- COMPLETE THE FOCK MATRIX -----
C     WE EITHER ADD THE FOCK OPERATOR OF THE PREVIOUS ITERATION TO
C     THE CHANGE IN THE FOCK MATRIX, OR WE ADD THE ONE ELECTRON
C     HAMILTONIAN TO THE FULLY COMPUTED TWO ELECTRON OPERATOR.
C
      IF(ABINIT  .AND.  DIRSCF  .AND.  FDIFF) THEN
         CALL DAREAD(IDAF,IODA,X(LWRK1),LL2,14,0)
         CALL VADD(X(LFAO),1,X(LWRK1),1,X(LFAO),1,L2)
         IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
      ELSE
         IF(DOMBAS) CALL CTMOTR(X(LWRK1),X(LFAO),X(LWRK2),X(LSCR),LL1)
         IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
         CALL VADD(X(LFAO),1,X(LH1),1,X(LFAO),1,L2)
      END IF
      CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,14,0)
C
C
C
C     ----- DEBUG PRINT OF ENERGY, FOCK MATRIX, AND LAGRANGIAN -----
C     -FV- AND -EIJ- AT LWRK1 AND LWRK2 ARE SQUARE MATRICES
C
      IF(OUT) THEN
C        WRITE(IW,9080) EHF1,EHF2,EHF
         WRITE(IW,*) 'TOTAL FOCK OPERATOR'
         CALL PRTRIL(X(LFAO),L1)
      END IF
C     NPRINT=5
      IF(NPRINT.EQ.5 .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME)
     *    CALL DAREAD(IDAF,IODA,X(LVEC),LL3,15,0)
      IF(OUT) THEN
         CALL MAKFV(X(LFAO),X(LVEC),X(LWRK1),X(LWRK),IA,1,NA,L1,L1)
         CALL MAKEIJ(X(LVEC),X(LWRK1),X(LWRK2),X(LWRK),L0,L0,L1,L0,L1)
         WRITE(IW,*) 'LAGRANGE MULTIPLIER MATRIX'
         CALL PRSQ(X(LWRK2),NA,L0,L1)
      END IF
C
C  ****
C
C
C IF CONVERGED COPY X(LFAO) --> TOTG
      IF(ICONVSCFMI.EQ.1) THEN
          GO TO 3999
      END IF
C
C COPY X(LFAO) --> TOTG
      CALL DCOPY(MTR,X(LFAO),1,TOTG,1)
C
      WRITE(IW,*)'END OF FOCK OPERATOR CALCULATION'
      CALL TIMIT(1)
C...
C COMPUTE THE ENERGY
C...
      ENER=ZEROSCFMI
      DO 5100 I=1,MTR
5100  ENER=ENER+(TOTG(I)+HAO(I))*P(I)
      ENER=ERN+ENER+ENER
C
      IF(IT.EQ.1) THEN
        WRITE(IOUT,*) 'INITIAL ENERGY',ENER
      ELSE
        WRITE(IOUT,*) 'ENERGY',ENER
        WRITE(IOUT,*) 'ENERGY DIFFERENCE',ENER-ENEROLD
      ENDIF
C
C     EDIFFOUT=ENER-ENEROLD
      ENEROLD=ENER
C.....
C BUILD AND SOLVE GENERALIZED EIGENVALUE PROBLEMS
C.....
C     X(LFAO) --> TOTG (M X M)
      CALL CPYTSQ(X(LFAO),TOTG,M,1)
      CALL DCOPY(MA*MA,GMATA,1,GKEEP,1)
      CALL MIGSOLVE(SAO,SWORK,TOTG,GMATA,GMATB,RMAT,SGA,ZMAT,
     + ROOT,U,MA,TTOT,1,MA,MB,M,IOPT,EIGEN,ALPHA,TOTWORK)
      CALL MIGSOLVE(SAO,SWORK,TOTG,GKEEP,GMATB,RMAT,SGB,ZMAT,
     + ROOT,U,MB,TTOT,2,MA,MB,M,IOPT,EIGEN,ALPHA,TOTWORK)
C
      CALL MISCHMIDT(SAO,TTOT,MA,MB)
C
      DO 9700 IOCC=1,NASCFMI
      DO 9700 I=1,MA
9700  T(I,IOCC)=TTOT(I,IOCC)
      DO 9800 JOCC=1,NBSCFMI
      DO 9800 J=MA+1,M
9800  T(J,NASCFMI+JOCC)=TTOT(J,MA+JOCC)
C
      IF(IOPT.GT.0) THEN
        WRITE(IOUT,6300) 'UPDATED COEFFICIENTS'
        CALL PREV(TTOT,EIGEN,M,M,M)
      ENDIF
C
3000  CONTINUE
C
      WRITE(IOUT,*)
      WRITE(IOUT,*) 'TERMINATE N. ITERAZIONI CONSENTITE =',ITERSCFMI
 3999 CONTINUE
      IF(SOME) THEN
         WRITE(IOUT,6300) 'CONVERGED SCF-MI COEFFICIENTS'
         CALL PREV(TTOT,EIGEN,M,M,M)
      END IF
C...
C SAVE OF CONVERGED SCFMI MOS (COEF.CONV)
C...
      CALL DAWRIT(IDAF,IODA,TTOT,M*M,316,0)
C...
C POSSIBLE CALCULATION AND PRINTING OF OVERLAP
C BETWEEN SCF-MI MOS SWORK(M,M)
C...
      IF(IOPT.GT.0) THEN
        WRITE(IW,*)'OVERLAP SCF-MI ORBITLAS'
        CALL MIOVR(TTOT,SAO,SWORK,M)
      ENDIF
C
C...
C  START OF SOME TRASFORMATIONS FOR GRADIENT...
C...
C
C...
C BUILD INDX
C...
      CALL MIINDX (M,EIGEN,INDX)
C
C...
C ORDERING OF EIGENVALUES AND EIGENVECTORS
C...
      CALL MIORD(TTOT,TOTWORK,EIGEN,EIGENWORK,INDX,M)
C
C...
C FROM LAST FOCK (FAO) BUILD FMO
C...
C     X(LFAO) --> FDUM (M X M)
      CALL CPYTSQ(X(LFAO),FDUM,M,1)
      DO I=1,N
         DO J=1,N
            FMO(I,J)=ZEROSCFMI
            DO L=1,M
               DO IK=1,M
                   FMO(I,J)=FMO(I,J)+TTOT(L,I)*TTOT(IK,J)*FDUM(L,IK)
               END DO
            END DO
          END DO
       END DO
C
C...
C TRANSORMATION SAO -> SMO
C...
      DO I=1,N
         DO J=1,N
            SMO(I,J)=ZEROSCFMI
            DO L=1,M
               DO IK=1,M
                   SMO(I,J)=SMO(I,J)+TTOT(L,I)*TTOT(IK,J)*SAO(L,IK)
               END DO
            END DO
          END DO
       END DO
C
C...
C **NOTE**: SCFMI ORBITALS ARE NOW ORDERED  WITH RESPECT
C           TO THEIR EIGENVALUES
C .....
C
C
C
C
C...
C DIAGONALIZATION OF FMO TMO =  SMO TMO EMO
C...
      CALL MISOLVE(FMO,SMO,EMO,WORK,SINV,TMO,N,IOPT,TOTWORK)
C
C...
C SAVE FINAL EIGENVALUES INTO EIGEN(I)
C...
      DO II=1,N
          EIGEN(II)=EMO(II)
      END DO
C
C
C...
C BUILD NEW MOS (ORTHONORMAL IN THE OCCUPIED PART)
C...
      CALL MINWMO (TTOT,TNEW,TMO,M,N)
      IF(IOPT.GT.0) THEN
        WRITE(IW,*)'OVERLAP SCF-MI ORTHONORMALIZED ORBITALS'
        CALL MIOVR(TNEW,SAO,SWORK,M)
      ENDIF
C
C
C
C     ----- SAVE MO-S + DENSITY + ORBITAL ENERGIES -----
C
      NDAF = 15
C     CALL SCFSAV(X(LVEC),X(LD),X(LEIG),NDAF,LL1,LL2,LL3)
      CALL SCFSAV(TNEW,DUM,EIGEN,NDAF,LL1,LL2,LL3)
C
C...
C CLEAN THE MEMORY USED IN ITERATE
C..
      CALL RETFM(NEED)
C
      CALL VALFM(LOADFM)
      CALL GOTFM(NGOTMX)
      IF(IOPT.GT.1) THEN
         WRITE(IW,*)'AFTER CLEANING'
         WRITE(IW,*)'LOADFM',LOADFM
         WRITE(IW,*)'NGOTMX',NGOTMX
      END IF
C
C
      RETURN
6300  FORMAT(/,1X,'========>',1X,A)
C
 9000 FORMAT(/10X,19("-")/10X,"RHF SCF CALCULATION"/10X,19("-"))
 9005 FORMAT(/1X,'OVERLAPPING STORAGE FOR H,S,Q MATRICES,',
     *        1X,'TO SAVE',I10,' WORDS.'/1X,'ADDING THIS AMOUNT',
     *        1X,'MAY IMPROVE EFFICIENCY SOMEWHAT.')
 9010 FORMAT(/5X,'NUCLEAR ENERGY = ',F20.10/
     *       5X,'MAXIT =',I5,5X,'NPUNCH=',I5/
     *       5X,'EXTRAP=',L1,'  DAMP=',L1,'  SHIFT=',L1,
     *          '  RSTRCT=',L1,'  DIIS=',L1,'  DEM=',L1,'  SOSCF=',L1/
     *       5X,'DENSITY CONV=',1P,E10.2)
 9015 FORMAT(5X,'VTSCAL=',L1,'  MAXVT=',I3,'  VTCONV=',F12.8)
 9017 FORMAT(5X,'SOSCF WILL OPTIMIZE',I8,' ORBITAL ROTATIONS, SOGTOL=',
     *          F8.3)
 9020 FORMAT(5X,'MEMORY REQUIRED FOR RHF STEP=',I10,' WORDS.')
 9030 FORMAT(/1X,'DIRECT SCF CALCULATION, SCHWRZ=',L1,'   FDIFF=',L1)
 9040 FORMAT(/' ITER EX DEM  TOTAL ENERGY      E CHANGE  DENSITY ',
     *        'CHANGE     ORB. GRAD      VIR. SHIFT       DAMPING')
 9050 FORMAT(/110X,'NONZERO    BLOCKS'/
     *        ' ITER EX DEM  TOTAL ENERGY      E CHANGE  DENSITY ',
     *        'CHANGE     ORB. GRAD      VIR. SHIFT       DAMPING',
     *        '        INTEGRALS   SKIPPED')
 9045 FORMAT(/' ITER EX DEM  TOTAL ENERGY      E CHANGE  DENSITY ',
     *        'CHANGE    DIIS ERROR      VIR. SHIFT       DAMPING')
 9055 FORMAT(/110X,'NONZERO    BLOCKS'/
     *        ' ITER EX DEM  TOTAL ENERGY      E CHANGE  DENSITY ',
     *        'CHANGE    DIIS ERROR      VIR. SHIFT       DAMPING',
     *        '        INTEGRALS   SKIPPED')
 9060 FORMAT(/' ITER EX DEM  TOTAL ENERGY      E CHANGE  DENSITY ',
     *        'CHANGE     ORB. GRAD')
 9070 FORMAT(/78X,'NONZERO    BLOCKS'/
     *        ' ITER EX DEM  TOTAL ENERGY      E CHANGE  DENSITY ',
     *        'CHANGE     ORB. GRAD      INTEGRALS   SKIPPED')
 9065 FORMAT(/' ITER EX DEM  TOTAL ENERGY      E CHANGE  DENSITY ',
     *        'CHANGE    DIIS ERROR')
 9075 FORMAT(/78X,'NONZERO    BLOCKS'/
     *        ' ITER EX DEM  TOTAL ENERGY      E CHANGE  DENSITY ',
     *        'CHANGE    DIIS ERROR      INTEGRALS   SKIPPED')
      END
C
C*MODULE SCFMI   *DECK MIGSOLVE
      SUBROUTINE MIGSOLVE(SAO,WORK,TOTG,GMATA,GMATB,RMAT,SMAT,ZMAT,
     + ROOT,U,NDIM,TTOT,IMON,MA,MB,M,IOPT,EIGEN,ALPHA,WORK2)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION SAO(M,M),WORK(M,M),TOTG(M,M),
     + GMATA(MA,MA),GMATB(MB,MB),
     + RMAT(NDIM,M),SMAT(NDIM,NDIM),ZMAT(NDIM,NDIM),
     + ROOT(NDIM),U(NDIM,NDIM+2),TTOT(M,M),EIGEN(M),WORK2(M,M)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
C
      DATA ZERO/0.0D+00/,ONE/1.0D+00/
      IF(IOPT.GT.1) THEN
         WRITE(IW,*)'SOLVE SECULAR PROBLEM'
         CALL TIMIT(1)
      END IF
      CALL VCLR(RMAT,1,NDIM*M)
C.....
      IF(IMON.EQ.1) THEN
C.....
C BUILD R (MA,M)  MATRIX  : [ 1A | -SAB DBB ]
C.....
        DO 1100 IA=1,MA
1100    RMAT(IA,IA)=ONE
        DO 1200 JB=1,MB
        DO 1200 IA=1,MA
        DO 1200 IB=1,MB
1200    RMAT(IA,MA+JB) = RMAT(IA,MA+JB) - SAO(MA+IB,IA)*GMATB(IB,JB)
C.....
C BUILD G'AA (MA,MA)  MATRIX
C.....
        DO 1300 I=1,M
        DO 1300 IA=1,MA
        WORK(IA,I)=ZERO
        DO 1300 K=1,M
1300    WORK(IA,I)=WORK(IA,I)+RMAT(IA,K)*TOTG(K,I)
C
        DO 1400 JA=1,MA
        DO 1400 IA=1,MA
        GMATA(IA,JA)=ZERO
        DO 1400 K=1,M
1400    GMATA(IA,JA)=GMATA(IA,JA)+WORK(IA,K)*RMAT(JA,K)
C
C...
C LEVEL SHIFT
C...
        IF (ALPHA.GT.ZERO) THEN
          DO JJ=1,MA
             DO II=1,MA
                U(II,JJ)=TTOT(II,JJ)
             END DO
          END DO
          IF(IOPT.GT.1) THEN
             WRITE(IW,*)'ALPHA-->', ALPHA
             WRITE(IW,*)'TA'
             CALL PRSQ(U,MA,MA,MA)
             WRITE(IW,*)'GMATA PRIMA DEL LEVEL SHIFT'
             CALL PRSQ(GMATA,MA,MA,MA)
          END IF
C
          CALL MILVLSHFT(GMATA,SMAT,U,MA,ALPHA,WORK,
     +                    ZMAT,WORK2)
          IF(IOPT.GT.1) THEN
             WRITE(IW,*)'GMATA AFTER LEVEL SHIFT'
             CALL PRSQ(GMATA,MA,MA,MA)
          END IF
C
        END IF
C
        CALL MISOLVE(GMATA,SMAT,ROOT,WORK,ZMAT,U,MA,IOPT,WORK2)
C
        DO 9500 I=1,MA
        DO 9500 K=1,MA
9500    TTOT(K,I)=U(K,I)
C
C..
C SAVE MA EIGENVALUES IN EIGEN(M)
C...
        DO II=1,MA
           EIGEN(II)=ROOT(II)
        END DO
C
      ELSE
C.....
C BUILD R (MB,M)  MATRIX  : [ -SBA DAA | 1B ]
C.....
        DO 2100 IB=1,MB
2100    RMAT(IB,MA+IB)=ONE
        DO 2200 JA=1,MA
        DO 2200 IB=1,MB
        DO 2200 IA=1,MA
2200    RMAT(IB,JA) = RMAT(IB,JA) - SAO(IA,MA+IB)*GMATA(IA,JA)
C.....
C BUILD G'BB (MB,MB)  MATRIX
C.....
        DO 2300 I=1,M
        DO 2300 IB=1,MB
        WORK(IB,I)=ZERO
        DO 2300 K=1,M
2300    WORK(IB,I)=WORK(IB,I)+RMAT(IB,K)*TOTG(K,I)
C
        DO 2400 JB=1,MB
        DO 2400 IB=1,MB
        GMATB(IB,JB)=ZERO
        DO 2400 K=1,M
2400    GMATB(IB,JB)=GMATB(IB,JB)+WORK(IB,K)*RMAT(JB,K)
C
C
C...
C LEVEL SHIFT
C...
        IF (ALPHA.GT.ZERO) THEN
          DO JJ=1,MB
             DO II=1,MB
                U(II,JJ)=TTOT(II+MA,JJ+MA)
             END DO
          END DO
          IF(IOPT.GT.1) THEN
             WRITE(IW,*)'ALPHA-->', ALPHA
             WRITE(IW,*)'TB'
             CALL PRSQ(U,MB,MB,MB)
             WRITE(IW,*)'GMATB PRIMA DEL LEVEL SHIFT'
             CALL PRSQ(GMATB,MB,MB,MB)
          END IF
C
          CALL MILVLSHFT(GMATB,SMAT,U,MB,ALPHA,WORK,
     +                    ZMAT,WORK2)
          IF(IOPT.GT.1) THEN
             WRITE(IW,*)'GMATB AFTER LEVEL SHIFT'
             CALL PRSQ(GMATB,MB,MB,MB)
          END IF
C
        END IF
C
C
        CALL MISOLVE(GMATB,SMAT,ROOT,WORK,ZMAT,U,MB,IOPT,WORK2)
C
        DO 9600 I=1,MB
        DO 9600 K=1,MB
9600    TTOT(MA+K,MA+I)=U(K,I)
C
C...
C SAVE MB EIGENVALUES IN EIGEN(M)
C...
        DO II=1,MB
           EIGEN(MA+II)=ROOT(II)
        END DO
C
      ENDIF
      RETURN
      END
C
C
C*MODULE SCFMI   *DECK MISCHMIDT
      SUBROUTINE MISCHMIDT(SAO,TTOT,MA,MB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION SAO(MA+MB,MA+MB),TTOT(MA+MB,MA+MB)
C
      DATA ZERO/0.0D+00/,ONE/1.0D+00/
C
      M=MA+MB
C
C GRAM-SCHMIDT ORTHOGONALIZATION FOR SYSTEM A
C
      DO 1100 K=1,MA
C
      DO 1200 L=1,K-1
      PROJ=ZERO
      DO 1300 I=1,MA
      TERMI=ZERO
      DO 1400 J=1,MA
1400  TERMI=TERMI+TTOT(J,L)*SAO(J,I)
1300  PROJ=PROJ+TTOT(I,K)*TERMI
      DO 1500 I=1,MA
1500  TTOT(I,K)=TTOT(I,K)-PROJ*TTOT(I,L)
1200  CONTINUE
C
      SUM=ZERO
      DO 1600 J=1,MA
      TERMJ=ZERO
      DO 1700 I=1,MA
1700  TERMJ=TERMJ+TTOT(I,K)*SAO(I,J)
1600  SUM=SUM+TTOT(J,K)*TERMJ
      SUM=ONE/SQRT(SUM)
      DO 1800 I=1,MA
1800  TTOT(I,K)=TTOT(I,K)*SUM
C
1100  CONTINUE
C
C GRAM-SCHMIDT ORTHOGONALIZATION FOR SYSTEM B
      DO 2100 K=MA+1,M
C
      DO 2200 L=MA+1,K-1
      PROJ=ZERO
      DO 2300 J=MA+1,M
      TERMJ=ZERO
      DO 2400 I=MA+1,M
2400  TERMJ=TERMJ+TTOT(I,K)*SAO(I,J)
2300  PROJ=PROJ+TTOT(J,L)*TERMJ
      DO 2500 I=MA+1,M
2500  TTOT(I,K)=TTOT(I,K)-PROJ*TTOT(I,L)
2200  CONTINUE
C
      SUM=ZERO
      DO 2600 J=MA+1,M
      TERMJ=ZERO
      DO 2700 I=MA+1,M
2700  TERMJ=TERMJ+TTOT(I,K)*SAO(I,J)
2600  SUM=SUM+TTOT(J,K)*TERMJ
      SUM=ONE/SQRT(SUM)
      DO 2800 I=MA+1,M
2800  TTOT(I,K)=TTOT(I,K)*SUM
C
2100  CONTINUE
C
      RETURN
      END
C
C*MODULE SCFMI   *DECK MISIGMA
      SUBROUTINE MISIGMA(SAO,SGA,SGB,GMATA,GMATB,SWORK,MA,MB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION SAO(MA+MB,MA+MB),SGA(MA,MA),SGB(MB,MB),
     *          GMATA(MA,MA),GMATB(MB,MB),SWORK(MA+MB,MA+MB)
C
      DATA ZERO/0.0D+00/
C.....
C BUILD SIGMA A  MATRIX
C.....
      DO 1100 IA=1,MA
      DO 1100 JB=1,MB
      SWORK(JB,IA)=ZERO
      DO 1100 K=1,MB
1100  SWORK(JB,IA)=SWORK(JB,IA)+SAO(K+MA,IA)*GMATB(K,JB)
C
      DO 1200 JA=1,MA
      DO 1200 IA=1,MA
      SGA(IA,JA)=SAO(IA,JA)
      DO 1200 K=1,MB
1200  SGA(IA,JA)=SGA(IA,JA)-SWORK(K,IA)*SAO(K+MA,JA)
C.....
C BUILD SIGMA B  MATRIX
C.....
      DO 2100 IB=1,MB
      DO 2100 JA=1,MA
      SWORK(JA,IB)=ZERO
      DO 2100 K=1,MA
2100  SWORK(JA,IB)=SWORK(JA,IB)+SAO(K,IB+MA)*GMATA(K,JA)
C
      DO 2200 JB=1,MB
      DO 2200 IB=1,MB
      SGB(IB,JB)=SAO(IB+MA,JB+MA)
      DO 2200 K=1,MA
2200  SGB(IB,JB)=SGB(IB,JB)-SWORK(K,IB)*SAO(K,JB+MA)
      RETURN
      END
C
C*MODULE SCFMI   *DECK MISOLVE
      SUBROUTINE MISOLVE(G,S,ROOT,WORK,SINV,U,NTSP,IOPT,WORK2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION ROOT(NTSP),WORK(NTSP*NTSP),SINV(NTSP,NTSP),
     *          G(NTSP,NTSP),S(NTSP,NTSP),U(NTSP,NTSP+2),
     *          WORK2(NTSP*NTSP)
C
      DATA ZERO/0.0D+00/,ONE/1.0D+00/
C
      CALL MXEIG(S,ROOT,U,WORK,NTSP,WORK2)
      IF(IOPT.GT.1) WRITE(6,6100) NTSP
      DO 15 I=1,NTSP
15    ROOT(I)=ONE/SQRT(ROOT(I))
C
C
C GENERATE S(-1/2)
      DO 2200 L=1,NTSP
      DO 2200 K=1,NTSP
      SINV(K,L)=ZERO
      DO 2200 IRUN=1,NTSP
2200  SINV(K,L)=SINV(K,L) + U(K,IRUN)*U(L,IRUN)*ROOT(IRUN)
C
C GENERATE S(-1/2) * H * S(-1/2)
      CALL MRARBR(SINV,NTSP,NTSP,NTSP,G,NTSP,NTSP,U,NTSP)
      CALL MRARBR(U,NTSP,NTSP,NTSP,SINV,NTSP,NTSP,G,NTSP)
      CALL MXEIG(G,ROOT,U,WORK,NTSP,WORK2)
      CALL DCOPY(NTSP*NTSP,U,1,G,1)
      CALL MRARBR(SINV,NTSP,NTSP,NTSP,G,NTSP,NTSP,U,NTSP)
      IF(IOPT.GT.1) WRITE(6,'(4G20.12)') ROOT
      RETURN
6100  FORMAT(1X,'ORDER OF THE MATRIX',I5,/,' EIGENVALUES OF H-E*S')
      END
C
C...
C PRINT THE POINTERS OF X(1)
C..
C*MODULE SCFMI   *DECK MIPRNT
      SUBROUTINE MIPRNT(NUMIND)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      COMMON /ADDI  / IDUM(57)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
C
      WRITE(IW,*)'POINTERS OF SCF-MI MEMORY'
      ICOUNT=NUMIND/5
      IF(MOD(NUMIND,5).NE.0) THEN
         ICOUNT=ICOUNT+1
      END IF
      DO II=0,ICOUNT-1
         IPUNT=5*II
         WRITE(6,7000)IDUM(IPUNT+1),IDUM(IPUNT+2),IDUM(IPUNT+3)
     1               ,IDUM(IPUNT+4),IDUM(IPUNT+5)
      END DO
      RETURN
C
7000  FORMAT(2X,I15,2X,I15,2X,I15,2X,I15,2X,I15)
      END
C*MODULE SCFMI   *DECK MIINDX
      SUBROUTINE MIINDX(N,ARRIN,INDX)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION ARRIN(N),INDX(N)
C
      DO  J=1,N
         INDX(J)=J
      END DO
      IF(N.EQ.1) RETURN
      L=N/2+1
      IR=N
 10   CONTINUE
          IF (L.GT.1) THEN
              L=L-1
              INDXT=INDX(L)
              Q=ARRIN(INDXT)
          ELSE
              INDXT=INDX(IR)
              Q=ARRIN(INDXT)
              INDX(IR)=INDX(1)
              IR=IR-1
              IF (IR.EQ.1) THEN
                 INDX(1)=INDXT
                 RETURN
              END IF
          END IF
          I=L
          J=L+L
 20       IF (J.LE.IR) THEN
              IF(J.LT.IR) THEN
                 IF (ARRIN(INDX(J)).LT.ARRIN(INDX(J+1))) J=J+1
              END IF
              IF (Q.LT.ARRIN(INDX(J))) THEN
                  INDX(I)=INDX(J)
                  I=J
                  J=J+J
              ELSE
                  J=IR+1
              END IF
          GO TO 20
          END IF
          INDX(I)=INDXT
      GO TO 10
      END
C
C
C
C
C.....
C ORDERING OF VECTOGENVECTORS WITH RESPECT TO THE EIGENVALUES
C.....
C*MODULE SCFMI   *DECK MIORD
      SUBROUTINE MIORD(TTOT,TWORK,EIGEN,EIGENWORK,INDX,M)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION TTOT(M,M),TWORK(M,M),EIGEN(M),EIGENWORK(M),INDX(M)
C
      DO I=1,M
         EIGENWORK(I)=EIGEN(I)
      END DO
C
      DO I=1,M
         JINDX=INDX(I)
         EIGEN(I)= EIGENWORK(JINDX)
      END DO
C
      DO J=1,M
         DO I=1,M
            TWORK(I,J)=TTOT(I,J)
         END DO
      END DO
C
C
      DO J=1,M
         JINDX=INDX(J)
         DO I=1,M
            TTOT(I,J)=TWORK(I,JINDX)
         END DO
      END DO
C
      RETURN
      END
C
C
C
C*MODULE SCFMI   *DECK MINWMO
      SUBROUTINE MINWMO (T,TNEW,AUTOV,M,N)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION T(M,M),TNEW(M,M),AUTOV(N,N)
C
      ZERO=0.0D+00
C
      DO J=1,N
         DO I=1,M
            TNEW(I,J)=ZERO
         END DO
      END DO
C
      DO J=N+1,M
         DO I=1,M
            TNEW(I,J)=T(I,J)
         END DO
      END DO
C
      DO IK=1,N
          DO L=1,N
             DO I=1,M
                 TNEW(I,IK)=TNEW(I,IK)+AUTOV(L,IK)*T(I,L)
             END DO
           END DO
       END DO
C
      RETURN
      END
C
C
C
C*MODULE SCFMI   *DECK MIOVR
      SUBROUTINE MIOVR(T,SAO,SMO,M)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION  SAO(M,M),T(M,M)
      DIMENSION  SMO(M,M)
C
      ZERO=0.0D+00
C
      DO I=1,M
         DO J=1,M
            SMO(I,J)=ZERO
            DO L=1,M
               DO K=1,M
                   SMO(I,J)=SMO(I,J)+T(L,I)*T(K,J)*SAO(L,K)
               END DO
            END DO
          END DO
       END DO
C
C     PTINT THE OVERLAP
      CALL PRSQ(SMO,M,M,M)
C
C
      RETURN
      END
C
C
C
C
C*MODULE SCFMI   *DECK MILVLSHFT
      SUBROUTINE MILVLSHFT(GMATA,SMAT,TI,NDIM,ALPHA,WORK,TS,ST)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION GMATA(NDIM,NDIM),SMAT(NDIM,NDIM),TI(NDIM,NDIM),
     *          TS(NDIM,NDIM),ST(NDIM,NDIM),WORK(NDIM,NDIM)
C...
C LEVEL SHIFT
C...
C
C...  S X T
      CALL MRARBR(SMAT,NDIM,NDIM,NDIM,TI,NDIM,NDIM,ST,NDIM)
C...  TT X S
      CALL TRPOSE(ST,TS,NDIM,NDIM,0)
C...  S T * TT S
      CALL MRARBR(ST,NDIM,NDIM,NDIM,TS,NDIM,NDIM,WORK,NDIM)
C...  S - (S T * TT S)
      CALL VSUB(WORK,1,SMAT,1,WORK,1,NDIM*NDIM)
C...  ALPHA * [S - (S T * TT S)]
C     CALL PRSQ(WORK,NDIM,NDIM,NDIM)
      DO J=1,NDIM
         DO I=1,NDIM
         WORK(I,J)=WORK(I,J)*ALPHA
      END DO
      END DO
C     F = F + ALPHA * S'
      CALL VADD(GMATA,1,WORK,1,GMATA,1,NDIM*NDIM)
      RETURN
      END
C*MODULE SCFMI   *DECK MXEIG
      SUBROUTINE MXEIG(FULL, VAL, VEX, WORK, NDIM, VFULL)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION VFULL(NDIM*(NDIM+1)/2),FULL(NDIM*NDIM),VAL(NDIM),
     *          VEX(NDIM,NDIM),WORK(NDIM*NDIM)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /MIOPT / ALPHA,DTOL,MIFLAG,NA,NB,MA,MB,MSHIFT,ITER,IOPT
C
C     MATRIX FULL (NDIMXNDIM) BECOMES TRIANGULAR IN
C     VFULL(NDIM*(NDIM+1)/2)
C
      CALL CPYSQT(FULL,VFULL,NDIM,1)
C
C     FULL EIGENVALUES (VAL) AND EIGENVECTORS (VEX)
C
      CALL GLDIAG(NDIM,NDIM,NDIM,VFULL,WORK,VAL,VEX,
     *            IGERR,WORK(8*NDIM+1))
      IF(IGERR.NE.0) THEN
        WRITE(IW,*) ' NO CONVERGENCE OF GLDIAG IN MXEIG'
        CALL ABRT
      ENDIF
C
      IF(IOPT.GT.1) WRITE(6,*) ' MATRIX DIAGONALIZED (GLDIAG)'
C
      RETURN
      END
C*MODULE SCFMI   *DECK MXINV
      SUBROUTINE MXINV(FULL, FWORK, WORKV, NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION FULL(NDIM,NDIM), FWORK(NDIM,*), WORKV(NDIM)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /MIOPT / ALPHA,DTOL,MIFLAG,NA,NB,MA,MB,MSHIFT,ITER,IOPT
C
C          DRIVER FOR MATRIX INVERSION VIA LINPACK ROUTINES
C
      CALL DGEFA(FULL,NDIM,NDIM,FWORK,INFO)
      IF(INFO.EQ.0) THEN
         JOB=1
         CALL DGEDI(FULL,NDIM,NDIM,FWORK,WORKV,FWORK(1,2),JOB)
      ELSE
         WRITE(IW,*) ' SINGULAR MATRIX IN MXINV'
         CALL ABRT
      ENDIF
      IF(IOPT.GT.1) WRITE(6,*) ' MATRIX INVERTED (DGEDI)'
      RETURN
      END

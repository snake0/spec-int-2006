C  9 DEC 03 - MWS - SYNCH COMMON BLOCK RUNOPT
C 26 MAR 03 - MWS - WRITE SCREEN PARAMETERS TO -IP-, NOT -IPIRC-
C 14 JAN 03 - MWS - FIX BUG READING DMA FILES
C 12 DEC 02 - MWS - ALLOW IFTTYP/IFTFIX INPUT SELECTION
C  7 AUG 02 - MWS - NEW MODULE FOR SCREENING TERM FOR CHARGE PENETRATION
C
C*MODULE CHGPEN  *DECK CGPX
      SUBROUTINE CGPX
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=500)
C
      COMMON /CGPPAR/ XGRID,CHISQ,THRSH,RMIN1,RMAX1,RMIN2,RMAX2,
     *                ISCCHG,MAXITS,ICFIX,IERRF,NTRACE,NV,NF,
     *                IFTTYP(2),IFTFIX(2)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA CHECK/8HCHECK   /
#else
      CHARACTER*8 :: CHECK_STR
      EQUIVALENCE (CHECK, CHECK_STR)
      DATA CHECK_STR/"CHECK   "/
#endif
C
C              ---- CHARGE PENETRATION SCREENING ----
C          M.A.FREITAG, M.S.GORDON, J.H.JENSEN, W.H.STEVENS
C                 J.CHEM.PHYS. 112, 7300-7306(2000)
C     THE CLASSICAL ELECTROSTATIC POTENTIAL DUE TO MULTIPOLES IS
C     SCREENED BY A DAMPING TERM SUCH THAT IT PRODUCES A BETTER
C     FIT TO THE QUANTUM MECHANICAL ELECTROSTATIC POTENTIAL.
C
      TOBOHR = 0.52917715D+00
      IPIRC=4
C
      IF(GOPARR) THEN
         IF(MASWRK) WRITE(IW,*) 'SORRY, SCREENING FIT IS SERIAL ONLY'
         RETURN
      END IF
C
C         --- READ INPUT CONTROLLING GENERATION OF THIS FIT ---
C     IF THERE IS NO SUCH INPUT THE USER MUST WANT TO SKIP THIS TERM.
C         CO = ATOM COORDINATES FOR GRID EXPANSION
C         RMIN = INNER RADIUS AT EACH ATOM
C         RMAX = OUTER RADIUS AT EACH ATOM
C     ESTIMATE THE NUMBER OF MULTIPOLE EXPANSION POINTS AS BEING
C     AT EVERY ATOM AND AT EVERY ATOM-PAIR CENTER
C
      MXEFC = (NAT*NAT+NAT)/2
C
      CALL VALFM(LOADFM)
      LCO    = LOADFM + 1
      LVDWR  = LCO    + NAT*3
      LRMIN  = LVDWR  + NAT
      LRMAX  = LRMIN  + NAT
      LEFNAM = LRMAX  + NAT
      LEFPOS = LEFNAM + MXEFC
      LEFC   = LEFPOS + MXEFC*3
      LEFD   = LEFC   + MXEFC
      LEFQ   = LEFD   + MXEFC*3
      LEFO   = LEFQ   + MXEFC*6
      LISETA = LEFO   + MXEFC*10
      LIFRZ  = LISETA + MXEFC*5
      LALP   = LIFRZ  + MXEFC*5
      LCOEF  = LALP   + MXEFC*5
      LIEQ   = LCOEF  + MXEFC*5
      LINUM  = LIEQ   + MXEFC
      LAST   = LINUM  + MXEFC
      NEEDV  = LAST - LOADFM - 1
      CALL GETFM(NEEDV)
C
      NATM = NAT
      CALL CGPINP(JRET,IPIRC,X(LCO),X(LVDWR),
     *            X(LEFNAM),X(LEFPOS),X(LEFC),X(LEFD),X(LEFQ),X(LEFO),
     *            X(LISETA),X(LINUM),X(LCOEF),X(LALP),X(LIFRZ),X(LIEQ),
     *            NATM,MXEFC,NEFC)
      IF(JRET.NE.0) GO TO 850
C
      L1 = NUM
      L2 = (L1*L1+L1)/2
C
      NFIT  = 0
C
  100 CONTINUE
      NFIT = NFIT+1
C
C        SELECT EXPONENTIAL/GAUSSIAN
C        TO GET THE EXPONENT VALUES SETTLED DOWN, THE FIRST FIT IS
C        ALWAYS BE REQUIRED TO HAVE LINEAR COEFFICIENTS.
C
      IERRF = IFTTYP(NFIT)
      ICFIX = 1
      IF(IERRF.NE.0  .AND.  IERRF.NE.2) GO TO 820
C
      IF(MASWRK) THEN
         IF(IERRF.EQ.0) WRITE(IW,75)
         IF(IERRF.EQ.2) WRITE(IW,74)
         IF(IFTFIX(NFIT).NE.1) WRITE(IW,76)
      END IF
      IF(IERRF.EQ.0) THEN
         RMIN = RMIN1/TOBOHR
         RMAX = RMAX1/TOBOHR
      ELSE
         RMIN = RMIN2/TOBOHR
         RMAX = RMAX2/TOBOHR
      END IF
      DO I=1,NAT
         X(LRMIN+I-1) = RMIN*X(LVDWR+I-1)
         X(LRMAX+I-1) = RMAX*X(LVDWR+I-1)
      ENDDO
C
C        THIS CALL JUST COUNTS HOW MANY GRID POINTS THERE WILL BE
C
      CALL CGPGRD(0,1,KOUNT2,DUMMY,DUMMY,DUMMY,X(LEFNAM),
     *            X(LCO),X(LRMIN),X(LRMAX),NATM)
      KOUNT = KOUNT2
C
      CALL VALFM(LOADFM)
      LDEN   = LOADFM + 1
      LBETA  = LDEN   + L2
      LAST1  = LBETA  + L2
C
C        X,Y,Z = GRID COORDINATES
C        QUANT = AB INITIO ELECTROSTATIC POTENTIAL ON GRID
C        CLASS = UNSCREENED MULTIPOLAR ELECTROSTATIC POTENTIAL ON GRID
C        DIFF  = QUANT - CLASS
C        FITTD = SCREENED MULTIPOLAR ELECTROSTATIC POTENTIAL
C        RAW   = UNSCREENED MULTIPOLAR POTENTIAL (VESTIGE OF ISSCHG=1)
C
      LX     = LBETA
      LY     = LX     + KOUNT
      LZ     = LY     + KOUNT
      LQUANT = LZ     + KOUNT
      LCLASS = LQUANT + KOUNT
      LDIFF  = LCLASS + KOUNT
      LFITTD = LDIFF  + KOUNT
      LRAW   = LFITTD + KOUNT
      LAST   = LRAW   + KOUNT
C
C         THESE ARRAYS ARE USED FOR THE FITTING PROCEDURES
C
      NVX = NV
      NEFC5 = NEFC*5
C
      LINDX1 = LAST
      LINDX2 = LINDX1 + NVX
      LIPVT  = LINDX2 + NVX
      LXQ    = LIPVT  + NVX
      LBQ    = LXQ    + NVX*NVX
      LVQ    = LBQ    + NVX
      LCHI   = LVQ    + NVX
      LZZZ   = LCHI   + NEFC5
      LZBAR  = LZZZ   + NEFC5*NEFC5
      LZSTAR = LZBAR  + NEFC5
      LXVAL  = LZSTAR + NEFC5
      LXMAX  = LXVAL  + NEFC5
      LXMIN  = LXMAX  + NEFC5
      LDELTX = LXMIN  + NEFC5
      LDELMN = LDELTX + NEFC5
      LMASK  = LDELMN + NEFC5
      LAST2  = LMASK  + NEFC5
C
C         WORK STORAGE FOR INTEGRATION CAN OVERLAP MOST OF THE ABOVE
C
      LG     = LCLASS
      LAST3  = LG + 225*1000
C
      LAST = MAX(LAST1,LAST2,LAST3)
      NEED = LAST-LOADFM-1
      IF(MASWRK) WRITE(IW,9000) NEED
      CALL GETFM(NEED)
      IF(EXETYP.EQ.CHECK) GO TO 800
C
C        LOAD TOTAL DENSITY MATRIX FIRST
C
      CALL DENDD1(X(LDEN),X(LBETA),L2)
C
C     ----- SET UP THE GRID ON WHICH THE FITTING IS DONE -----
C
      CALL CGPGRD(1,KOUNT,KOUNT2,X(LX),X(LY),X(LZ),X(LEFNAM),
     *            X(LCO),X(LRMIN),X(LRMAX),NATM)
      IF(MASWRK) WRITE(IW,9010) KOUNT
      CALL FLSHBF(IW)
C
C     ----- COMPUTE QUANTUM ELECTROSTATIC POTENTIAL ON THE GRID -----
C
      CALL TSECND(TIM0)
      CALL CGPQUA(X(LQUANT),X(LX),X(LY),X(LZ),KOUNT,X(LDEN),L2,X(LG))
      CALL TSECND(TIM1)
      TQUANT = TIM1-TIM0
      TIM0 = TIM1
      IF(MASWRK) WRITE(IW,9020)
      CALL FLSHBF(IW)
C
C     ----- COMPUTE CLASSICAL ELECTROSTATIC POTENTIAL ON THE GRID -----
C
      CALL CGPCLS(X(LCLASS),X(LX),X(LY),X(LZ),KOUNT,
     *            X(LEFPOS),X(LEFC),X(LEFD),X(LEFQ),X(LEFO),NEFC)
      CALL TSECND(TIM1)
      TCLASS = TIM1-TIM0
      TIM0 = TIM1
      IF(MASWRK) WRITE(IW,9030) TQUANT,TCLASS
      CALL FLSHBF(IW)
C
C         FORM DIFFERENCE POTENTIAL = QUANTUM - CLASSICAL
C
      CALL VSUB(X(LCLASS),1,X(LQUANT),1,X(LDIFF),1,KOUNT)
C
C     ---- OPTIMIZE SCREENING EXPONENTS -----
C     STEPIT CALLED TWICE BECAUSE IT SOMETIMES TERMINATES PREMATURELY
C     ON SURFACE INFLECTIONS OR FLAT SPOTS.
C
      IF(NV.NE.0) THEN
         IF(MASWRK) WRITE(IW,9040)
         CALL STEPIT(1,X(LINDX1),X(LINDX2),X(LIPVT),X(LXQ),X(LBQ),
     *               X(LVQ),X(LCHI),X(LZZZ),X(LZBAR),X(LZSTAR),
     *               X(LX),X(LY),X(LZ),X(LQUANT),X(LDIFF),X(LRAW),
     *               X(LFITTD),X(LEFPOS),X(LEFC),X(LEFD),X(LEFQ),
     *               X(LEFO),X(LISETA),X(LINUM),X(LCOEF),X(LALP),
     *               X(LIFRZ),X(LIEQ),X(LXVAL),X(LXMAX),X(LXMIN),
     *               X(LDELTX),X(LDELMN),X(LMASK),
     *               KOUNT,NVX,NEFC,NEFC5,NFIT)
         CALL TSECND(TIM1)
         TFIT = TIM1-TIM0
         TIM0 = TIM1
         IF(MASWRK) WRITE(IW,9050) TFIT
         CALL FLSHBF(IW)
         ICFIX = IFTFIX(NFIT)
         CALL STEPIT(2,X(LINDX1),X(LINDX2),X(LIPVT),X(LXQ),X(LBQ),
     *               X(LVQ),X(LCHI),X(LZZZ),X(LZBAR),X(LZSTAR),
     *               X(LX),X(LY),X(LZ),X(LQUANT),X(LDIFF),X(LRAW),
     *               X(LFITTD),X(LEFPOS),X(LEFC),X(LEFD),X(LEFQ),
     *               X(LEFO),X(LISETA),X(LINUM),X(LCOEF),X(LALP),
     *               X(LIFRZ),X(LIEQ),X(LXVAL),X(LXMAX),X(LXMIN),
     *               X(LDELTX),X(LDELMN),X(LMASK),
     *               KOUNT,NVX,NEFC,NEFC5,NFIT)
         CALL TSECND(TIM1)
         TFIT = TIM1-TIM0
         TIM0 = TIM1
         IF(MASWRK) WRITE(IW,9060) TFIT
      END IF
C
C     --- GENERATE THE FINAL FITTED POTENTIAL, PRINT/PUNCH SUMMARY ---
C
      CALL CGPFIT(X(LX),X(LY),X(LZ),X(LRAW),X(LFITTD),KOUNT,
     *            X(LEFPOS),X(LEFC),X(LEFD),X(LEFQ),X(LEFO),
     *            X(LINUM),X(LCOEF),X(LALP),NEFC)
C
      IF(IERRF.EQ.0) WRITE(IP,11)
      IF(IERRF.EQ.2) WRITE(IP,12)
      CALL CGPPRT(X(LX),X(LY),X(LZ),X(LQUANT),X(LFITTD),X(LRAW),
     *            X(LEFNAM),X(LEFPOS),X(LINUM),X(LCOEF),X(LALP),
     *            KOUNT,NEFC)
                     WRITE(IP,31)
      IF(IERRF.EQ.2) WRITE(IP,32)
C
  800 CONTINUE
      CALL RETFM(NEED)
C
C         NOW GO BACK AND DO THE SECOND FIT
C
      IF(NFIT.LE.2) GO TO 100
C
C         OMNIA EXEUNT
C
  820 CONTINUE
      IF(MASWRK) THEN
         WRITE(IW,9200)
         CALL TIMIT(1)
      END IF
C
  850 CONTINUE
      CALL RETFM(NEEDV)
      RETURN
C
   74 FORMAT(/' *** SINGLE EXPONENTIAL USED AS DAMPING FUNCTION ***')
   75 FORMAT(/' *** SINGLE GAUSSIAN USED AS DAMPING FUNCTION ***')
   76 FORMAT(/1X,'INITIAL FIT WILL RESTRICT LINEAR COEFS TO UNITY,'/
     *        1X,'THIS RESTRICTION WILL BE REMOVED IN THE SECOND FIT.')
   11 FORMAT('SCREEN')
   12 FORMAT('SCREEN2')
   31 FORMAT('STOP')
   32 FORMAT(' $END')
 9000 FORMAT(1X,'MULTIPOLE DAMPING COMPUTATION REQUIRES',I10,' WORDS.')
 9010 FORMAT(/1X,'----- THE ELECTROSTATIC POTENTIAL GRID CONTAINS',I9,
     *          ' POINTS -----')
 9020 FORMAT(1X,'----- THE QUANTUM POTENTIAL HAS BEEN GENERATED',
     *          ' ON THE GRID -----')
 9030 FORMAT(1X,'----- THE UNSCREENED CLASSICAL POTENTIAL GRID HAS',
     *          ' BEEN GENERATED -----'/
     *       1X,'ELECTROSTATIC POTENTIAL CPU TIME: QUANTUM=',F8.1,
     *          ', CLASSICAL=',F8.2)
 9040 FORMAT(/1X,'FITTING SCREENED MULTIPOLE CLASSICAL POTENTIAL',
     *          ' TO THE QUANTUM POTENTIAL...')
 9050 FORMAT(1X,'INITIAL FIT REQUIRED',F8.1,' SECONDS'//
     *       1X,'REPEATING FIT TO BE SURE TRUE BEST FIT IS FOUND...')
 9060 FORMAT(1X,'REFITTING REQUIRED',F8.1,' SECONDS')
 9200 FORMAT(1X,'..... DONE WITH CHARGE PENETRATION SCREENING .....')
      END
C*MODULE CHGPEN  *DECK CGPINP
      SUBROUTINE CGPINP(JRET,IPIRC,CO,VDWRAD,EFNAM,EFPOS,EFC,EFD,
     *                  EFQ,EFO,ISETA,INUM,COEF,ALP,IFRZ,IEQ,
     *                  NATM,MXEFC,NEFC)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      CHARACTER*8 STR8
      CHARACTER*8  COEFS(0:1)
      CHARACTER*11 TYPES(0:3)
C
      DIMENSION CO(3,NATM),VDWRAD(NATM),
     *          EFNAM(MXEFC),EFPOS(3,MXEFC),EFC(MXEFC),
     *          EFD(3,MXEFC),EFQ(6,MXEFC),EFO(10,MXEFC),
     *          ISETA(5,MXEFC),INUM(MXEFC),COEF(5,MXEFC),
     *          ALP(5,MXEFC),IFRZ(5,MXEFC),IEQ(MXEFC)
      DIMENSION RVDW(86)
C
      PARAMETER (MXATM=500)
C
      COMMON /CGPPAR/ XGRID,CHISQ,THRSH,RMIN1,RMAX1,RMIN2,RMAX2,
     *                ISCCHG,MAXITS,ICFIX,IERRF,NTRACE,NV,NF,
     *                IFTTYP(2),IFTFIX(2)
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFIRST(MXATM,6),
     *                KLAST(MXATM,6),LMAX(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     DATA VALUES IN /CGPPAR/ ARE AS FOLLOWS:
C         ISCCHG = 1 IF ONLY CHARGES ARE TO BE SCREENED.
C                    THIS WAS SOMETHING WE TRIED AWHILE BACK.
C         THRSH  = CONTROLS PRINTING OF LARGE ERRORS BETWEEN AB INITIO
C                  AND SCREENED MULTIPOLES ON THE GRID
C         MAXITS = NON-ZERO CONTROLS THE NUMBER OF MAXIMUM SIMPLEX
C                  STEPS IN THE "STEPIT" ROUTINE.
C         ICFIX  = 1 TO FREEZE THE LINEAR COEFFICIENTS AT 1.0.
C                  IF SCREEN=[ 1.0 - A*EXP(-B*R**2) ], THEN SCREEN
C                  DOESN'T = 0.0 AT THE ORIGIN UNLESS A=1.0.  THIS
C                  IS RARELY USED FOR EXPONENTIALS, BUT IS THE
C                  TRADITIONAL CHOICE FOR GAUSSIANS.  IT MAY BE
C                  VERY SENSIBLE TO FIX GAUSSIAN COEFS TO UNITY,
C                  HOWEVER, ESPECIALLY IF ANY OF THE LINEAR COEFS
C                  GO TO NEGATIVE NUMBERS.
C                  THIS ISN'T OPERATIVE FOR ERROR FUNCTION SCREENING.
C         IERRF  = 0 FOR GAUSSIAN FUNCTION SCREENING
C                = 1 FOR ERROR FUNCTION SCREENING
C                = 2 FOR EXPONENTIAL SCREENING
C                = 3 SEE CODE FOR THE FORMULA
C         IFTTYP AND IFTFIX STORE THE IERRF/ICFIX DATA FOR THE TWO FITS.
C         NEFC   = NUMBER OF SCREENED MULTIPOLE CENTERS
C
C     FOR THE READING OF $DAMP NAMELIST
C
      PARAMETER (NNAM=11)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA DAMP/8HDAMP    /
#else
      CHARACTER*8 :: DAMP_STR
      EQUIVALENCE (DAMP, DAMP_STR)
      DATA DAMP_STR/"DAMP    "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA QNAM/8HXGRID   ,8HVDWRAD  ,8HISCCHG  ,8HTHRSH   ,8HMAXIT   ,
     *          8HRMIN1   ,8HRMAX1   ,8HRMIN2   ,8HRMAX2   ,8HIFTTYP  ,
     *          8HIFTFIX  /
#else
      CHARACTER*8 :: QNAM_STR(NNAM)
      EQUIVALENCE (QNAM, QNAM_STR)
      DATA QNAM_STR/"XGRID   ","VDWRAD  ","ISCCHG  ","THRSH   ",
     * "MAXIT   ",
     *          "RMIN1   ","RMAX1   ","RMIN2   ","RMAX2   ","IFTTYP  ",
     *          "IFTFIX  "/
#endif
      DATA KQNAM/3,-3,1,3,1,   3,3,3,3,21,  21/
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA BLANK/8H        /
#else
      CHARACTER*8 :: BLANK_STR
      EQUIVALENCE (BLANK, BLANK_STR)
      DATA BLANK_STR/"        "/
#endif
C
      DATA ZERO,THREE,FIVE/0.0D+00,3.0D+00,5.0D+00/
      DATA TYPES/'   GAUSSIAN', 'ERROR FUNCT', 'EXPONENTIAL',
     *           '  SEE CODE'/
      DATA COEFS/'VARIABLE','   FIXED'/
C
C       VAN DER WAALS RADII TAKEN FROM "THE ELEMENTS", 2ND EDITION,
C       JOHN EMSLEY, CLARENDON PRESS, OXFORD, 1991.  UNKNOWN VALUES
C       ARE SIMPLY SET TO ZERO, RATHER THAN TRYING TO GUESS THEM.
C
      DATA (RVDW(II),II=1,18)/1.20D+00,1.22D+00,
     *      0.00D+00,0.00D+00,2.08D+00,1.85D+00,
     *      1.54D+00,1.40D+00,1.35D+00,1.60D+00,
     *      2.31D+00,0.00D+00,2.05D+00,2.00D+00,
     *      1.90D+00,1.85D+00,1.81D+00,1.91D+00/
      DATA (RVDW(II),II=19,36)/2.31D+00,13*0.0D+00,
     *      2.00D+00,2.00D+00,1.95D+00,1.98D+00/
      DATA (RVDW(II),II=37,54)/2.44D+00,13*0.0D+00,
     *      2.20D+00,2.20D+00,2.15D+00,0.00D+00/
      DATA (RVDW(II),II=55,86)/2.62D+00,27*0.0D+00,2.40D+00,3*0.0D+00/
C
C       MAIN DRIVER TO FIT THE CHARGE PENETRATION SCREENING
C
      KQNAM(2) = 10*NATM+3
C
C SET DEFAULT VALUES
C
      NTRACE=0
      ISCCHG=0
C
      XGRID=0.5D+00
      THRSH=4.0D+00
      MAXITS=10000
      RMIN1=0.67D+00
      RMAX1=3.00D+00
      RMIN2=0.67D+00
      RMAX2=3.00D+00
      DO I=1,NAT
         IZNUC = INT(ZAN(I) + IZCORE(I))
         VDWRAD(I) = RVDW(IZNUC)
      ENDDO
C
C        FIRST PASS IS AN EXPONENTIAL FIT, FOR EFP2 SCREENING.
C        SECOND PASS IS A GAUSSIAN FIT, FOR THE ORIGINAL EFP1 SCREENING.
C
C        THE GAUSSIAN FIT WILL BE USED FOR AB INITIO-FRAGMENT SCREENING,
C        SEE EQUATION (4) OF J.PHYS.CHEM. 105, 293-307(2001), WHILE
C        THE EXPONENTIAL FIT WILL BE USED FOR FRAGMENT-FRAGMENT CHARGE
C        PENETRATION SCREENING, SEE EQUATION (28).  NOTE THAT THESE
C        HAVE A SINGLE TERM, AND (28) LACKS A LINEAR COEFFICIENT.
C
      IFTTYP(1)=2
      IFTTYP(2)=0
      IFTFIX(1)=1
      IFTFIX(2)=0
C
      DO 40 J=1,MXATM
         DO 5 I=1,5
            ISETA(I,J)=0
            COEF(I,J)=ZERO
            ALP(I,J)=ZERO
            IFRZ(I,J)=0
    5    CONTINUE
         EFNAM(J)=BLANK
         EFC(J)=ZERO
         DO I=1,3
            EFPOS(I,J)=ZERO
            EFD(I,J)=ZERO
         ENDDO
         DO I=1,10
            EFO(I,J)=ZERO
         ENDDO
         DO I=1,6
            EFQ(I,J)=ZERO
         ENDDO
40    CONTINUE
C
      CALL ERRT
C
C        ISCCHG IS NOT A DOCUMENTED OPTION
C
      JRET = 0
      CALL NAMEIO(IR,JRET,DAMP,NNAM,QNAM,KQNAM,
     *            XGRID,VDWRAD,ISCCHG,THRSH,MAXITS,RMIN1,RMAX1,
     *            RMIN2,RMAX2,IFTTYP,IFTFIX,
     *            0,0,0,
     *            0,0,0,0,0,  0,0,0,0,0,
     *            0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *            0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0)
      IF(JRET.EQ.1) THEN
         IF(MASWRK) WRITE(IW,905)
         RETURN
      END IF
      IF(JRET.EQ.2) THEN
         IF(MASWRK) WRITE(IW,900)
         CALL ABRT
      END IF
C
      IF(MASWRK) THEN
         WRITE(IW,70)
         WRITE(IW,77) THRSH,MAXITS,XGRID
         WRITE(IW,78) (VDWRAD(III),III=1,NAT)
         WRITE(IW,79) RMIN1,RMAX1,RMIN2,RMAX2
         WRITE(IW,80) TYPES(IFTTYP(1)),COEFS(IFTFIX(1))
         IF(IFTTYP(2).GE.0)
     *   WRITE(IW,81) TYPES(IFTTYP(2)),COEFS(IFTFIX(2))
         IF(ISCCHG.EQ.1) WRITE(IW,85)
      END IF
C
C        WE MUST HAVE RADII FOR ALL ATOMS OR WE CAN'T CONTINUE
C
      NERR=0
      DO I=1,NAT
         IF(VDWRAD(I).LE.ZERO) THEN
            NERR=NERR+1
            IF(MASWRK) WRITE(IW,*) 'NO VDW RADIUS FOR ATOM',I
         END IF
      ENDDO
      IF(NERR.GT.0) THEN
         IF(MASWRK) WRITE(IW,*) 'PLEASE SUPPLY MISSING VDWRAD INPUT'
         CALL ABRT
      END IF
C
C     ----- READ IN DMA MULTIPOLE INFORMATION PREVIOUSLY COMPUTED -----
C
      IEOF  = 0
      IERR  = 0
      STR8  = '        '
      KSIZE = -8
      CALL OPNCRD(IPIRC,-IW)
      CALL SEQREW(IPIRC)
C
   86 CONTINUE
      CALL RDCARD('CGP CTR1',IEOF)
      IF(IEOF.NE.0) GO TO 1000
      CALL GSTRNG(STR8,KSIZE)
      IF(STR8.NE.'RUNTYP  ') GO TO 86
C
C---- SKIP THREE LINES
C
      CALL RDCARD('SKIPPING',IEOF)
      CALL RDCARD('SKIPPING',IEOF)
      CALL RDCARD('SKIPPING',IEOF)
C
C---- GET DMA EXPANSION CENTERS
C
      IF(MASWRK) WRITE(IW,105)
      NEFC = 0
  110 CONTINUE
      CALL RDCARD('CGP CTR2',IEOF)
      CALL GSTRNG(STR8,KSIZE)
      IF(STR8.EQ.'STOP    ') GO TO 140
      NEFC=NEFC+1
      IF(NEFC.GT.MXEFC) THEN
         IF(MASWRK) WRITE(IW,120) MXEFC
         CALL ABRT
      END IF
      READ(UNIT=STR8,FMT='(A8)') EFNAM(NEFC)
      EFPOS(1,NEFC) = RFIND('X CENTER',IERR)
      EFPOS(2,NEFC) = RFIND('Y CENTER',IERR)
      EFPOS(3,NEFC) = RFIND('Z CENTER',IERR)
      IF(MASWRK) WRITE(IW,370) EFNAM(NEFC),(EFPOS(J,NEFC),J=1,3)
      GO TO 110
C
C---- GET CHARGES (ASSUME THEY ARE IN THE INPUT FILE)
C
  140 CONTINUE
      CALL RDCARD('SKIPPING',IEOF)
      IF(MASWRK) WRITE(IW,145)
      DO IEFC=1,NEFC
         CALL RDCARD('CGP CHRG',IEOF)
         CALL GSTRNG(STR8,KSIZE)
         EFC(IEFC) = RFIND('AT. CHG.',IERR)
         IF(MASWRK) WRITE(IW,370) STR8,EFC(IEFC)
      ENDDO
C
C---- GET DIPOLES (DON'T ASSUME THEY ARE IN THE INPUT FILE)
C
      CALL SEQREW(IPIRC)
  160 CONTINUE
      CALL RDCARD('CGP DIP1',IEOF)
      IF(IEOF.NE.0) THEN
         IF(MASWRK) WRITE(IW,170)
         GO TO 200
      END IF
      CALL GSTRNG(STR8,KSIZE)
      IF(STR8.NE.'DIPOLES') GO TO 160
C
      IF(MASWRK) WRITE(IW,180)
      DO 190 IEFC=1,NEFC
         CALL RDCARD('CGP DIP2',IEOF)
         CALL GSTRNG(STR8,KSIZE)
         DO I=1,3
            EFD(I,IEFC) = RFIND('DIPOLE  ',IERR)
         ENDDO
         IF(MASWRK) WRITE(IW,370) STR8,(EFD(J,IEFC),J=1,3)
  190 CONTINUE
C
C---- GET QUADRUPOLES (DON'T ASSUME THEY ARE IN THE INPUT FILE)
C
  200 CONTINUE
      CALL SEQREW(IPIRC)
  210 CONTINUE
      CALL RDCARD('CGP QUA1',IEOF)
      IF(IEOF.NE.0) THEN
         IF(MASWRK) WRITE(IW,220)
         GO TO 300
      END IF
      CALL GSTRNG(STR8,KSIZE)
      IF(STR8.NE.'QUADRUPO') GO TO 210
C
      IF(MASWRK) WRITE(IW,230)
      DO 290 IEFC=1,NEFC
         CALL RDCARD('CGP QUA2',IEOF)
         CALL GSTRNG(STR8,KSIZE)
         DO I=1,4
            EFQ(I,IEFC) = RFIND('QUADRPLE',IERR)
         ENDDO
         CALL RDCARD('CGP QUA3',IEOF)
         DO I=5,6
            EFQ(I,IEFC) = RFIND('QUADRPLE',IERR)
         ENDDO
         IF(MASWRK) WRITE(IW,370) STR8,(EFQ(J,IEFC),J=1,6)
290   CONTINUE
C
C---- CONVERT QUADRUPOLES
C
      DO 260 NEFX=1,NEFC
         XX=EFQ(1,NEFX)
         YY=EFQ(2,NEFX)
         ZZ=EFQ(3,NEFX)
         XY=EFQ(4,NEFX)
         XZ=EFQ(5,NEFX)
         YZ=EFQ(6,NEFX)
         DUM=XX+YY+ZZ
         EFQ(1,NEFX)=THREE*XX-DUM
         EFQ(2,NEFX)=THREE*YY-DUM
         EFQ(3,NEFX)=THREE*ZZ-DUM
         EFQ(4,NEFX)=THREE*XY
         EFQ(5,NEFX)=THREE*XZ
         EFQ(6,NEFX)=THREE*YZ
  260 CONTINUE
C
C---- GET OCTUPOLES (DON'T ASSUME THEY ARE IN THE INPUT FILE)
C
  300 CONTINUE
      CALL SEQREW(IPIRC)
  310 CONTINUE
      CALL RDCARD('CGP OCT1',IEOF)
      IF(IEOF.NE.0) THEN
         IF(MASWRK) WRITE(IW,320)
         GO TO 400
      END IF
      CALL GSTRNG(STR8,KSIZE)
      IF(STR8.NE.'OCTUPOLE') GO TO 310
C
      IF(MASWRK) WRITE(IW,330)
      DO 350 IEFC=1,NEFC
         CALL RDCARD('CGP OCT2',IEOF)
         CALL GSTRNG(STR8,KSIZE)
         DO K=1,4
            EFO(K,IEFC) = RFIND('OCTUPOLE',IERR)
         ENDDO
         CALL RDCARD('CGP OCT3',IEOF)
         DO K=5,8
            EFO(K,IEFC) = RFIND('OCTUPOLE',IERR)
         ENDDO
         DO K=9,10
            EFO(K,IEFC) = RFIND('OCTUPOLE',IERR)
         ENDDO
         IF(MASWRK) WRITE(IW,380) STR8,(EFO(K,IEFC),K=1,10)
  350 CONTINUE
C
C---- CONVERT OCTUPOLES
C
      DO 390 NEFX=1,NEFC
         XXX=EFO(1,NEFX)
         YYY=EFO(2,NEFX)
         ZZZ=EFO(3,NEFX)
         XXY=EFO(4,NEFX)
         XXZ=EFO(5,NEFX)
         XYY=EFO(6,NEFX)
         YYZ=EFO(7,NEFX)
         XZZ=EFO(8,NEFX)
         YZZ=EFO(9,NEFX)
         XYZ=EFO(10,NEFX)
         DUMX=XXX+XYY+XZZ
         DUMY=XXY+YYY+YZZ
         DUMZ=XXZ+YYZ+ZZZ
         EFO(1,NEFX)=FIVE*XXX-THREE*DUMX
         EFO(2,NEFX)=FIVE*YYY-THREE*DUMY
         EFO(3,NEFX)=FIVE*ZZZ-THREE*DUMZ
         EFO(4,NEFX)=FIVE*XXY-DUMY
         EFO(5,NEFX)=FIVE*XXZ-DUMZ
         EFO(6,NEFX)=FIVE*XYY-DUMX
         EFO(7,NEFX)=FIVE*YYZ-DUMZ
         EFO(8,NEFX)=FIVE*XZZ-DUMX
         EFO(9,NEFX)=FIVE*YZZ-DUMY
         EFO(10,NEFX)=FIVE*XYZ
  390 CONTINUE
C
C         WE ARE NOW DONE READING MULTIPOLE DATA,
C         RETURN INPUT SCANNER TO NORMAL CARD INPUT FILE.
C
  400 CONTINUE
      CALL SEQREW(IPIRC)
      CALL OPNCRD(IR,-IW)
C
C---------------------------------------------------
C READ IN INITIAL GUESS SCREENING DATA IN $DAMPGS
C---------------------------------------------------
C
      CALL SEQREW(IR)
      CALL FNDGRP(IR,' $DAMPGS',IEOF)
      IF(IEOF.NE.0) THEN
         IF(MASWRK) WRITE(IW,505)
         CALL ABRT
      END IF
C
      IF(MASWRK) WRITE(IW,435)
C
C  KEEP TRACK OF THE NUMBER OF VARIABLE EXPONENTS AND COEFFICIENTS
C  NALP COUNTS THE NUMBER OF VARIABLE EXPONENTS
      NALP=0
C LOOP OVER MULTIPOLE EXPANSION POINTS
      DO 470 IEFC=1,NEFC
C READ A LINE OF INPUT
         CALL RDCARD('DAMPGS 1',IEOF)
C FIRST VALUE IS A LABEL
         CALL GSTRNG(STR8,KSIZE)
         READ(UNIT=STR8,FMT='(A8)') EFNAM(IEFC)
C IF THE NEXT INPUT IS ANYTHING OTHER THAN 'EQ', THEN THE CURRENT
C EXPANSION CENTER IS INDEPENDENT (NOT EQUAL TO A PREVIOUSLY
C INPUT CENTER.  THE STRING SCANNER WILL RETURN NON-ZERO IF AND
C ONLY IF THE NEXT CHARACTERS ON THE LINE ARE DELIMITED BY QUOTES.
         LENGTH = 0
         CALL GSTRNG(STR8,LENGTH)
         IF(LENGTH.EQ.0) THEN
            CALL REREAD
            IEQ(IEFC) = IEFC
C INUM = THE NUMBER OF TERMS IN THE SCREENING FUNCTION ON THIS CENTER
C        THIS IS USUALLY ONE, BUT WE WANTED MORE FLEXIBILITY AND
C        ALLOWED FOR A MULTITERM EXPANSION OF THE SCREENING.
            INUM(IEFC) = IFIND('INUM    ',IERR)
C READ THE TERMS DEFINING THE SCREENING FUCNTION
C    COEF = THE LINEAR COEFFICIENT
C    ALP  = THE EXPONENT
C    IFRZ = 1 IF THE EXPONENT IS TO BE FROZEN IN THE OPTIMIZATION
            DO 437 J=1,INUM(IEFC)
               CALL RDCARD('DAMPGS 2',IEOF)
               COEF(J,IEFC) = RFIND('COEF    ',IERR)
               ALP(J,IEFC)  = RFIND('ALP     ',IERR)
               IFRZ(J,IEFC) = IFIND('IFRZ    ',IERR)
C
C ISETA WAS DEFINED SO THAT ONLY THE "ACTIVE" EXPONENTS ARE PASSED
C TO STEPIT.  ISETA MAPS THE CURRENT EXPONENT TO THE NEXT ACTIVE
C EXPONENT.  THERE ARE "NALP" ACTIVE EXPONENTS.
C
               ISETA(J,IEFC)=0
               IF(IFRZ(J,IEFC).EQ.0)THEN
                  NALP=NALP+1
                  ISETA(J,IEFC)=NALP
               END IF
  437       CONTINUE
            IF(MASWRK) WRITE(IW,440) EFNAM(IEFC),
     *         (COEF(J,IEFC),ALP(J,IEFC),IFRZ(J,IEFC),J=1,INUM(IEFC))
         ELSE
C
C COME HERE IF THE SECOND VALUE ON THE INPUT LINE IS "=".
C THIS MEANS WE ARE GOING TO EQUIVALENCE THE CURRENT SCREENING
C FUNCTION TO A FUNCTION THAT HAS ALREADY BEEN INPUT.
C THE ARRAY "IEQ" IS USED TO KEEP TRACK OF EQUIVALENCED SCREENING
C FUNCTIONS.
C
            CALL GSTRNG(STR8,KSIZE)
            READ(UNIT=STR8,FMT='(A8)') WORD
            IEQ(IEFC)=-1
            DO J=1,IEFC-1
               IF(WORD.EQ.EFNAM(J)) IEQ(IEFC)=J
            ENDDO
            IF(IEQ(IEFC).EQ.-1) THEN
               IF(MASWRK) WRITE(IW,9002) WORD,IEFC
               CALL ABRT
            END IF
            INUM(IEFC)=INUM(IEQ(IEFC))
            DO J=1,INUM(IEFC)
               ALP(J,IEFC)  = ALP(J,IEQ(IEFC))
               COEF(J,IEFC) = COEF(J,IEQ(IEFC))
               IFRZ(J,IEFC) = IFRZ(J,IEQ(IEFC))
               ISETA(J,IEFC)= ISETA(J,IEQ(IEFC))
            ENDDO
            IF(MASWRK) WRITE(IW,455) EFNAM(IEFC),EFNAM(IEQ(IEFC))
         END IF
  470 CONTINUE
C
      NV=NALP
C
C     GET CENTERS OF CONCENTRIC SPHERES FROM ATOMIC CENTERS
C     TO USE AS EXPANSION POINTS FOR DEFINING THE ACTIVE VOLUME.
C        XGRID = THE UNIFORM GRID SPACING IN BOHR
C
      DO I=1,NAT
        DO J=1,3
          CO(J,I)=C(J,I)
        ENDDO
      ENDDO
C
      RETURN
C
 1000 CONTINUE
      IF(MASWRK) WRITE(IW,1010)
      CALL ABRT
      RETURN
C
  900 FORMAT(1X,'ERROR IN $DAMP NAMELIST INPUT - STOP')
  905 FORMAT(/1X,'NO $DAMP INPUT GROUP WAS FOUND,',
     *           ' THEREFORE RUNTYP=MAKEFP IS'/
     *       1X,'SKIPPING THE CHARGE PENETRATION SCREENING FIT.'/)
   70 FORMAT(/'     ---------------------------------------',
     *       /'     EFFECTIVE POTENTIAL SCREENING PARAMETER',
     *       /'              OPTIMIZATION PROGRAM',
     *       /'     ---------------------------------------',
     *      //'               WALTER J. STEVENS',
     *       /'                     NIST        ',
     *       /'                APRIL    1998')
   77 FORMAT(/1X,'THE $DAMP INPUT DATA FOR THIS RUN IS:'/
     *        1X,'THRSH  = ',F5.1/
     *        1X,'MAXIT  = ',I5/
     *        1X,'XGRID  = ',F10.6)
   78 FORMAT(1X,'VDWRAD=',5F12.6,:,(/8X,5F12.6))
   79 FORMAT(1X,'   GAUSSIAN FIT RMIN1,RMAX1=',2F12.6/
     *       1X,'EXPONENTIAL FIT RMIN2,RMAX2=',2F12.6)
   80 FORMAT(1X,'INITIAL FIT WILL USE ',A11,' FORM WITH ',A8,
     *          ' LINEAR COEFICIENTS')
   81 FORMAT(1X,' SECOND FIT WILL USE ',A11,' FORM WITH ',A8,
     *          ' LINEAR COEFICIENTS')
   85 FORMAT(/1X,'************************************************',
     *       /1X,'    NOTE:  ONLY THE CHARGES ARE SCREENED !!',
     *       /1X,'************************************************')
  105 FORMAT(/1X,'THE CLASSICAL MULTIPOLE EXPANSION TO BE SCREENED IS'//
     *        1X,'CENTERS OF THE DISTRIBUTED MULTIPOLE EXPANSION,',
     *           ' X,Y,Z')
  120 FORMAT(/1X,'***** TOO MANY EFC POINTS USED *****',
     *         '      MAXIMUM = ',I3/)
  145 FORMAT(/1X,'CHARGES             Q')
  170 FORMAT(/1X,'NO DIPOLES FOUND')
  180 FORMAT(/1X,'DIPOLES             X         Y         Z')
  220 FORMAT(/1X,'NO QUADRUPOLES FOUND')
  230 FORMAT(/1X,'QUADRUPOLES        XX        YY        ZZ        XY',
     *           '        XZ        YZ')
  320 FORMAT(/1X,'NO OCTUPOLES FOUND')
  330 FORMAT(/1X,'OCTUPOLES')
  370 FORMAT(5X,A8,6F10.5)
  380 FORMAT(5X,A8,5F10.5/13X,5F10.5)
  435 FORMAT(/1X,'INITIAL VALUES OF SCREENING PARAMETERS ARE:'/
     *        1X,'NAME        COEF       EXP     FREEZE')
  440 FORMAT(1X,A8,2F10.5,I6,:,(/1X,2F10.5,I6))
  455 FORMAT(1X,A8,' = ',A8)
  505 FORMAT(/1X,'NO $DAMPGS CHARGE PENETATION DAMPING GUESS',
     *           ' INPUT FOUND, PLEASE GIVE THIS.')
 1010 FORMAT(///'NO GAMESS DMA INPUT FOUND')
 9002 FORMAT(1X,'*** ERROR ***'/1X,'EQUIVALENT POINT NAME ',A8,
     *          ' FOR NEXT SCREENING POINT',I5/
     *          1X,'WAS NOT DEFINED EARLIER IN $DAMPGS')
      END
C
C*MODULE CHGPEN  *DECK CGPQUA
      SUBROUTINE CGPQUA(POT,CCX,CCY,CCZ,KOUNT,DAO,L2,G)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL NORM,DOUBLE,IANDJ
C
      DIMENSION POT(KOUNT),CCX(KOUNT),CCY(KOUNT),CCZ(KOUNT),
     *          DAO(L2),G(225,1000)
      DIMENSION XIN(250),YIN(250),ZIN(250),
     *          DIJ(225),FIJ(225),IJX(225),IJY(225),IJZ(225),
     *          IX(35),IY(35),IZ(35),JX(35),JY(35),JZ(35)
C
      PARAMETER (MXGTOT=5000, MXSH=1000, MXATM=500)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /ROOT  / XX,U(9),W(9),NROOTS
      COMMON /XYZSTV/ XINT,YINT,ZINT,T,X0,Y0,Z0,XI,YI,ZI,XJ,YJ,ZJ,NI,NJ,
     *                CX,CY,CZ
C
      DATA ZERO,ONE,TWO/0.0D+00,1.0D+00,2.0D+00/
      DATA PI212 /1.1283791670955D+00/
      DATA SQRT3 /1.73205080756888D+00/
      DATA SQRT5 /2.23606797749979D+00/
      DATA SQRT7 /2.64575131106459D+00/
C
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,
     1          3, 0, 0, 2, 2, 1, 0, 1, 0, 1,
     2          4, 0, 0, 3, 3, 1, 0, 1, 0, 2,
     3          2, 0, 2, 1, 1/
      DATA IX / 1, 6, 1, 1,11, 1, 1, 6, 6, 1,
     1         16, 1, 1,11,11, 6, 1, 6, 1, 6,
     2         21, 1, 1,16,16, 6, 1, 6, 1,11,
     3         11, 1,11, 6, 6/
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,
     1          0, 3, 0, 1, 0, 2, 2, 0, 1, 1,
     2          0, 4, 0, 1, 0, 3, 3, 0, 1, 2,
     3          0, 2, 1, 2, 1/
      DATA IY / 1, 1, 6, 1, 1,11, 1, 6, 1, 6,
     1          1,16, 1, 6, 1,11,11, 1, 6, 6,
     2          1,21, 1, 6, 1,16,16, 1, 6,11,
     3          1,11, 6,11, 6/
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,
     1          0, 0, 3, 0, 1, 0, 1, 2, 2, 1,
     2          0, 0, 4, 0, 1, 0, 1, 3, 3, 0,
     3          2, 2, 1, 1, 2/
      DATA IZ / 1, 1, 1, 6, 1, 1,11, 1, 6, 6,
     1          1, 1,16, 1, 6, 1, 6,11,11, 6,
     2          1, 1,21, 1, 6, 1, 6,16,16, 1,
     3         11,11, 6, 6,11/
C
      ICMIN=1
      ICMAX=1000
      IF(ICMAX.GT.KOUNT) ICMAX=KOUNT
      DO IC=1,KOUNT
         POT(IC)=ZERO
      ENDDO
C
C---- PROGRAM LOOPS BACK TO HERE IN ORDER TO CALCULATE ELECTROSTATIC
C---- POTENTIAL ON GRID POINTS IN BLOCKS OF 1000 POINTS.
C
    1 CONTINUE
      NUMIC=ICMAX-ICMIN+1
      NORM=.TRUE.
C
C     ----- I SHELL
C
      DO 9000 II=1,NSHELL
      I=KATOM(II)
      XI=C(1,I)
      YI=C(2,I)
      ZI=C(3,I)
      I1=KSTART(II)
      I2=I1+KNG(II)-1
      LIT=KTYPE(II)
      MINI=KMIN(II)
      MAXI=KMAX(II)
      LOCI=KLOC(II)-MINI
C
C     ----- J SHELL
C
      DO 8000 JJ=1,II
      J=KATOM(JJ)
      XJ=C(1,J)
      YJ=C(2,J)
      ZJ=C(3,J)
      J1=KSTART(JJ)
      J2=J1+KNG(JJ)-1
      LJT=KTYPE(JJ)
      MINJ=KMIN(JJ)
      MAXJ=KMAX(JJ)
      LOCJ=KLOC(JJ)-MINJ
      NROOTS=(LIT+LJT-2)/2+1
      RR=(XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
      IANDJ=II.EQ.JJ
C
C     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS
C
      IJ=0
      MAX=MAXJ
      DO 50 I=MINI,MAXI
      NX=IX(I)
      NY=IY(I)
      NZ=IZ(I)
      IF(IANDJ) MAX=I
      DO 50 J=MINJ,MAX
      IJ=IJ+1
      IJX(IJ)=NX+JX(J)
      IJY(IJ)=NY+JY(J)
      IJZ(IJ)=NZ+JZ(J)
   50 CONTINUE
      DO 65 IC=1,NUMIC
      DO 60 I=1,IJ
      G(I,IC)=ZERO
   60 CONTINUE
   65 CONTINUE
C
C     ----- I PRIMITIVE
C
      JGMAX=J2
      DO 7000 IG=I1,I2
      AI=EX(IG)
      ARRI=AI*RR
      AXI=AI*XI
      AYI=AI*YI
      AZI=AI*ZI
      CSI=CS(IG)
      CPI=CP(IG)
      CDI=CD(IG)
      CFI=CF(IG)
      CGI=CG(IG)
C
C     ----- J PRIMITIVE
C
      IF(IANDJ) JGMAX=IG
      DO 6000 JG=J1,JGMAX
      AJ=EX(JG)
      AA=AI+AJ
      AA1=ONE/AA
      DUM=AJ*ARRI*AA1
C     IF(DUM.GT.TOL) GO TO 6000
      FAC=EXP(-DUM)
      CSJ=CS(JG)
      CPJ=CP(JG)
      CDJ=CD(JG)
      CFJ=CF(JG)
      CGJ=CG(JG)
      AX=(AXI+AJ*XJ)*AA1
      AY=(AYI+AJ*YJ)*AA1
      AZ=(AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
      DOUBLE=IANDJ.AND.IG.NE.JG
      MAX=MAXJ
      NN=0
      DO 310 I=MINI,MAXI
      GO TO ( 70, 80,180,180, 90,180,180,100,180,180,
     1       110,180,180,120,180,180,180,180,180,130,
     2       140,180,180,150,180,180,180,180,180,160,
     3       180,180,170,180,180),I
   70 DUM1=CSI*FAC
      GO TO 180
   80 DUM1=CPI*FAC
      GO TO 180
   90 DUM1=CDI*FAC
      GO TO 180
  100 IF(NORM) DUM1=DUM1*SQRT3
      GO TO 180
  110 DUM1=CFI*FAC
      GO TO 180
  120 IF(NORM) DUM1=DUM1*SQRT5
      GO TO 180
  130 IF(NORM) DUM1=DUM1*SQRT3
      GO TO 180
  140 DUM1=CGI*FAC
      GO TO 180
  150 IF(NORM) DUM1=DUM1*SQRT7
      GO TO 180
  160 IF(NORM) DUM1=DUM1*SQRT5/SQRT3
      GO TO 180
  170 IF(NORM) DUM1=DUM1*SQRT3
  180 IF(IANDJ) MAX=I
      DO 310 J=MINJ,MAX
      GO TO (190,200,300,300,210,300,300,220,300,300,
     1       230,300,300,240,300,300,300,300,300,250,
     2       260,300,300,270,300,300,300,300,300,280,
     3       300,300,290,300,300),J
  190 DUM2=DUM1*CSJ
      IF(.NOT.DOUBLE) GO TO 300
      IF(I.GT.1) GO TO 195
      DUM2=DUM2+DUM2
      GO TO 300
  195 DUM2=DUM2+CSI*CPJ*FAC
      GO TO 300
  200 DUM2=DUM1*CPJ
      IF(DOUBLE) DUM2=DUM2+DUM2
      GO TO 300
  210 DUM2=DUM1*CDJ
      IF(DOUBLE) DUM2=DUM2+DUM2
      GO TO 300
  220 IF(NORM) DUM2=DUM2*SQRT3
      GO TO 300
  230 DUM2=DUM1*CFJ
      IF(DOUBLE) DUM2=DUM2+DUM2
      GO TO 300
  240 IF(NORM) DUM2=DUM2*SQRT5
      GO TO 300
  250 IF(NORM) DUM2=DUM2*SQRT3
      GO TO 300
  260 DUM2=DUM1*CGJ
      IF(DOUBLE) DUM2=DUM2+DUM2
      GO TO 300
  270 IF(NORM) DUM2=DUM2*SQRT7
      GO TO 300
  280 IF(NORM) DUM2=DUM2*SQRT5/SQRT3
      GO TO 300
  290 IF(NORM) DUM2=DUM2*SQRT3
  300 NN=NN+1
  310 DIJ(NN)=DUM2
C
C     ----- NUCLEAR ATTRACTION
C
      DUM=PI212*AA1
      DO 400 I=1,IJ
  400 FIJ(I)=DIJ(I)*DUM
      AAX=AA*AX
      AAY=AA*AY
      AAZ=AA*AZ
      ICX=0
      DO 450 IC=ICMIN,ICMAX
      ICX=ICX+1
      CX=CCX(IC)
      CY=CCY(IC)
      CZ=CCZ(IC)
      XX=AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
C
      IF (NROOTS.LE.3) CALL RT123
      IF (NROOTS.EQ.4) CALL ROOT4
      IF (NROOTS.EQ.5) CALL ROOT5
C
      MM=0
      DO 420 K=1,NROOTS
      UU=AA*U(K)
C     WW=W(K)*ZNUC
      WW=W(K)
      TT=ONE/(AA+UU)
      T= SQRT(TT)
      X0=(AAX+UU*CX)*TT
      Y0=(AAY+UU*CY)*TT
      Z0=(AAZ+UU*CZ)*TT
      IN=-5+MM
      DO 410 I=1,LIT
      IN=IN+5
      NI=I
      DO 410 J=1,LJT
      JN=IN+J
      NJ=J
      CALL STVXYZ
      XIN(JN)=XINT
      YIN(JN)=YINT
      ZIN(JN)=ZINT*WW
  410 CONTINUE
  420 MM=MM+25
      DO 440 I=1,IJ
      NX=IJX(I)
      NY=IJY(I)
      NZ=IJZ(I)
      DUM=ZERO
      MM=0
      DO 430 K=1,NROOTS
      NXM=NX+MM
      NYM=NY+MM
      NZM=NZ+MM
      DUM=DUM+XIN(NXM)*YIN(NYM)*ZIN(NZM)
  430 MM=MM+25
  440 G(I,ICX)=G(I,ICX)+DUM*FIJ(I)
  450 CONTINUE
C
C           END OF PRIMITIVE LOOPS
C
6000  CONTINUE
7000  CONTINUE
      ICX=0
      DO 7600 IC=ICMIN,ICMAX
         ICX=ICX+1
         MAX=MAXJ
         NN=0
         DO 7500 I=MINI,MAXI
            LI=LOCI+I
            IN=(LI*(LI-1))/2
            IF(IANDJ) MAX=I
            FACT=TWO
            DO 7400 J=MINJ,MAX
               LJ=LOCJ+J
               JN=LJ+IN
               NN=NN+1
               IF(IANDJ.AND.I.EQ.J) FACT=ONE
               POT(IC)=POT(IC)-G(NN,ICX)*DAO(JN)*FACT
               FACT=TWO
 7400       CONTINUE
 7500    CONTINUE
 7600 CONTINUE
C         END OF SHELL LOOPS
 8000 CONTINUE
 9000 CONTINUE
      IF(ICMAX.EQ.KOUNT) RETURN
      ICMIN=ICMIN+1000
      ICMAX=ICMAX+1000
      IF(ICMAX.GT.KOUNT) ICMAX=KOUNT
      GO TO 1
      END
C
C*MODULE CHGPEN  *ECK STVXYZ
      SUBROUTINE STVXYZ
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /XYZSTV/ XINT,YINT,ZINT,T,X0,Y0,Z0,XI,YI,ZI,XJ,YJ,ZJ,NI,NJ,
     *                CX,CY,CZ
      COMMON /HERMIT/ H1,H2(2),H3(3),H4(4),H5(5),H6(6),H7(7)
      COMMON /WERMIT/ W1,W2(2),W3(3),W4(4),W5(5),W6(6),W7(7)
C
      DIMENSION H(28),W(28),MIN(7),MAX(7)
C
      EQUIVALENCE (H(1),H1),(W(1),W1)
C
      DATA MIN /1,2,4, 7,11,16,22/
      DATA MAX /1,3,6,10,15,21,28/
      DATA ZERO /0.0D+00/
C
C     ----- GAUSS-HERMITE QUADRATURE USING MINIMUM POINT FORMULA -----
C
      XINT=ZERO
      YINT=ZERO
      ZINT=ZERO
      NPTS=(NI+NJ-2)/2+1
      IMIN=MIN(NPTS)
      IMAX=MAX(NPTS)
      DO 13 I=IMIN,IMAX
      DUM=W(I)
      PX=DUM
      PY=DUM
      PZ=DUM
      DUM=H(I)*T
      PTX=DUM+X0
      PTY=DUM+Y0
      PTZ=DUM+Z0
      AX=PTX-XI
      AY=PTY-YI
      AZ=PTZ-ZI
      BX=PTX-XJ
      BY=PTY-YJ
      BZ=PTZ-ZJ
      GO TO (5,4,3,2,1),NI
    1 PX=PX*AX
      PY=PY*AY
      PZ=PZ*AZ
    2 PX=PX*AX
      PY=PY*AY
      PZ=PZ*AZ
    3 PX=PX*AX
      PY=PY*AY
      PZ=PZ*AZ
    4 PX=PX*AX
      PY=PY*AY
      PZ=PZ*AZ
    5 GO TO (12,11,10,9,8,7,6),NJ
    6 PX=PX*BX
      PY=PY*BY
      PZ=PZ*BZ
    7 PX=PX*BX
      PY=PY*BY
      PZ=PZ*BZ
    8 PX=PX*BX
      PY=PY*BY
      PZ=PZ*BZ
    9 PX=PX*BX
      PY=PY*BY
      PZ=PZ*BZ
   10 PX=PX*BX
      PY=PY*BY
      PZ=PZ*BZ
   11 PX=PX*BX
      PY=PY*BY
      PZ=PZ*BZ
   12 CONTINUE
      XINT=XINT+PX
      YINT=YINT+PY
      ZINT=ZINT+PZ
   13 CONTINUE
      RETURN
      END
C*MODULE CHGPEN  *DECK CGPCLS
      SUBROUTINE CGPCLS(CLASS,X,Y,Z,KOUNT,EFPOS,EFC,EFD,EFQ,EFO,NEFC)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION CLASS(KOUNT),X(KOUNT),Y(KOUNT),Z(KOUNT),EFPOS(3,NEFC),
     *          EFC(NEFC),EFD(3,NEFC),EFQ(6,NEFC),EFO(10,NEFC)
C
      PARAMETER (ZERO=0.0D+00)
C
C     THE CLASSICAL POTENTIAL IS CALCUALATED USING THE MULTIPOLES
C
      DO 350 K=1,KOUNT
         VAL=ZERO
         DO IEFC=1,NEFC
            VAL=VAL
     *         +CGPMUL(K,IEFC,X,Y,Z,KOUNT,EFPOS,EFC,EFD,EFQ,EFO,NEFC)
         ENDDO
         CLASS(K)=VAL
  350 CONTINUE
      RETURN
      END
C*MODULE CHGPEN  *DECK CGPMUL
      DOUBLE PRECISION FUNCTION CGPMUL(K,IPT,X,Y,Z,KOUNT,
     *                                 EFPOS,EFC,EFD,EFQ,EFO,NEFC)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION X(KOUNT),Y(KOUNT),Z(KOUNT),EFPOS(3,NEFC),
     *          EFC(NEFC),EFD(3,NEFC),EFQ(6,NEFC),EFO(10,NEFC)
C
      DATA PT5/0.5D+00/
      DATA ZERO,TWO/0.0D+00,2.0D+00/
      DATA THREE,FIVE,SIX/3.0D+00,5.0D+00,6.0D+00/
C
C       GENERATE ELECTROSTATIC POTENTIAL FOR THE DMA EXPANSION
C
      VAL=ZERO
      XI=X(K)-EFPOS(1,IPT)
      YI=Y(K)-EFPOS(2,IPT)
      ZI=Z(K)-EFPOS(3,IPT)
      RR=XI*XI+YI*YI+ZI*ZI
      R1=SQRT(RR)
      R3=R1*RR
      R5=RR*RR*R1
      R7=RR*R5
C
      VALO=EFC(IPT)/R1
      VAL=VAL+VALO
C
      TERM=ZERO
      TERM=TERM+EFD(1,IPT)*XI
      TERM=TERM+EFD(2,IPT)*YI
      TERM=TERM+EFD(3,IPT)*ZI
      VALO=TERM/R3
      VAL=VAL+VALO
C
      XX=EFQ(1,IPT)
      YY=EFQ(2,IPT)
      ZZ=EFQ(3,IPT)
      XY=EFQ(4,IPT)
      XZ=EFQ(5,IPT)
      YZ=EFQ(6,IPT)
      XXI=XI*XI
      YYI=YI*YI
      ZZI=ZI*ZI
      XYI=XI*YI
      XZI=XI*ZI
      YZI=YI*ZI
      TERM=ZERO
      TERM=TERM+XX*(THREE*XXI-RR)
      TERM=TERM+YY*(THREE*YYI-RR)
      TERM=TERM+ZZ*(THREE*ZZI-RR)
      TERM=TERM+XY*THREE*XYI*TWO
      TERM=TERM+XZ*THREE*XZI*TWO
      TERM=TERM+YZ*THREE*YZI*TWO
      VALO=PT5*TERM/(THREE*R5)
      VAL=VAL+VALO
C
      XXX=EFO(1,IPT)
      YYY=EFO(2,IPT)
      ZZZ=EFO(3,IPT)
      XXY=EFO(4,IPT)
      XXZ=EFO(5,IPT)
      XYY=EFO(6,IPT)
      YYZ=EFO(7,IPT)
      XZZ=EFO(8,IPT)
      YZZ=EFO(9,IPT)
      XYZ=EFO(10,IPT)
      XXXI=XI*XI*XI
      YYYI=YI*YI*YI
      ZZZI=ZI*ZI*ZI
      XXYI=XI*XI*YI
      XXZI=XI*XI*ZI
      XYYI=XI*YI*YI
      YYZI=YI*YI*ZI
      XZZI=XI*ZI*ZI
      YZZI=YI*ZI*ZI
      XYZI=XI*YI*ZI
      RRXI=RR*XI
      RRYI=RR*YI
      RRZI=RR*ZI
      TERM=ZERO
      TERM=TERM+XXX*(FIVE*XXXI-THREE*RRXI)
      TERM=TERM+YYY*(FIVE*YYYI-THREE*RRYI)
      TERM=TERM+ZZZ*(FIVE*ZZZI-THREE*RRZI)
      TERM=TERM+XXY*(FIVE*XXYI-RRYI)*THREE
      TERM=TERM+XXZ*(FIVE*XXZI-RRZI)*THREE
      TERM=TERM+XYY*(FIVE*XYYI-RRXI)*THREE
      TERM=TERM+YYZ*(FIVE*YYZI-RRZI)*THREE
      TERM=TERM+XZZ*(FIVE*XZZI-RRXI)*THREE
      TERM=TERM+YZZ*(FIVE*YZZI-RRYI)*THREE
      TERM=TERM+XYZ*(FIVE*XYZI)*SIX
      VALO=PT5*TERM/(FIVE*R7)
      VAL=VAL+VALO
      CGPMUL=VAL
      RETURN
      END
C
C*MODULE CHGPEN  *DECK CGPFIT
      SUBROUTINE CGPFIT(X,Y,Z,RAW,FITTED,KOUNT,
     *                  EFPOS,EFC,EFD,EFQ,EFO,INUM,COEF,ALP,NEFC)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION X(KOUNT),Y(KOUNT),Z(KOUNT),RAW(KOUNT),FITTED(KOUNT),
     *          EFPOS(3,NEFC),EFC(NEFC),EFD(3,NEFC),EFQ(6,NEFC),
     *          EFO(10,NEFC),INUM(NEFC),COEF(5,NEFC),ALP(5,NEFC)
C
      COMMON /CGPPAR/ XGRID,CHISQ,THRSH,RMIN1,RMAX1,RMIN2,RMAX2,
     *                ISCCHG,MAXITS,ICFIX,IERRF,NTRACE,NV,NF,
     *                IFTTYP(2),IFTFIX(2)
C
      DATA PT5/0.5D+00/
      DATA ZERO,ONE,TWO/0.0D+00,1.0D+00,2.0D+00/
      DATA THREE,FIVE,SIX/3.0D+00,5.0D+00,6.0D+00/
C
C LOOP OVER ALL GRID POINTS
C
      DO 420 K=1,KOUNT
      VAL=ZERO
      RAWVAL=ZERO
C
C LOOP OVER ALL MULTIPOLE POINTS
C
      DO 410 IPT=1,NEFC
      XI=X(K)-EFPOS(1,IPT)
      YI=Y(K)-EFPOS(2,IPT)
      ZI=Z(K)-EFPOS(3,IPT)
      RR=XI*XI+YI*YI+ZI*ZI
      R1=SQRT(RR)
      R3=R1*RR
      R5=RR*RR*R1
      R7=RR*R5
C
      XDAMP=ZERO
C LOOP OVER ALL TERMS IN DAMPING FUNCTION
      DO 405 J=1,INUM(IPT)
      IF(ALP(J,IPT).EQ.ZERO) GO TO 405
C
C COMPUTE PROPER DAMPING FUNCTION
C
      ALPRR=ALP(J,IPT)*RR
      IF(IERRF.EQ.0) XDAMP=XDAMP+COEF(J,IPT)*EXP(-ALPRR)
      IF(IERRF.EQ.1) XDAMP=XDAMP+COEF(J,IPT)*ERRF(SQRT(ALPRR))
      IF(IERRF.EQ.2) XDAMP=XDAMP+COEF(J,IPT)*EXP(-ALP(J,IPT)*SQRT(RR))
      IF(IERRF.EQ.3) XDAMP=XDAMP+COEF(J,IPT)*EXP(-TWO*ALP(J,IPT)
     *                       *SQRT(RR))*(ONE+ALP(J,IPT)*SQRT(RR))
405   CONTINUE
      IF(IERRF.EQ.0) XDAMP=ONE-XDAMP
      IF(IERRF.EQ.2) XDAMP=ONE-XDAMP
      IF(IERRF.EQ.3) XDAMP=ONE-XDAMP
C
C CALCULATE THE MULTIPOLAR ELECTROSTATIC POTENTIAL
C
      VALO=EFC(IPT)/R1
      VAL=VAL+VALO*XDAMP
      RAWVAL=RAWVAL+VALO
C
      IF(ISCCHG.EQ.1)XDAMP=ONE
      TERM=ZERO
      TERM=TERM+EFD(1,IPT)*XI
      TERM=TERM+EFD(2,IPT)*YI
      TERM=TERM+EFD(3,IPT)*ZI
      VALO=TERM/R3
      VAL=VAL+VALO*XDAMP
      RAWVAL=RAWVAL+VALO
C
      XX=EFQ(1,IPT)
      YY=EFQ(2,IPT)
      ZZ=EFQ(3,IPT)
      XY=EFQ(4,IPT)
      XZ=EFQ(5,IPT)
      YZ=EFQ(6,IPT)
      XXI=XI*XI
      YYI=YI*YI
      ZZI=ZI*ZI
      XYI=XI*YI
      XZI=XI*ZI
      YZI=YI*ZI
      TERM=ZERO
      TERM=TERM+XX*(THREE*XXI-RR)
      TERM=TERM+YY*(THREE*YYI-RR)
      TERM=TERM+ZZ*(THREE*ZZI-RR)
      TERM=TERM+XY*THREE*XYI*TWO
      TERM=TERM+XZ*THREE*XZI*TWO
      TERM=TERM+YZ*THREE*YZI*TWO
      VALO=PT5*TERM/(THREE*R5)
      VAL=VAL+VALO*XDAMP
      RAWVAL=RAWVAL+VALO
C
      XXX=EFO(1,IPT)
      YYY=EFO(2,IPT)
      ZZZ=EFO(3,IPT)
      XXY=EFO(4,IPT)
      XXZ=EFO(5,IPT)
      XYY=EFO(6,IPT)
      YYZ=EFO(7,IPT)
      XZZ=EFO(8,IPT)
      YZZ=EFO(9,IPT)
      XYZ=EFO(10,IPT)
      XXXI=XI*XI*XI
      YYYI=YI*YI*YI
      ZZZI=ZI*ZI*ZI
      XXYI=XI*XI*YI
      XXZI=XI*XI*ZI
      XYYI=XI*YI*YI
      YYZI=YI*YI*ZI
      XZZI=XI*ZI*ZI
      YZZI=YI*ZI*ZI
      XYZI=XI*YI*ZI
      RRXI=RR*XI
      RRYI=RR*YI
      RRZI=RR*ZI
      TERM=ZERO
      TERM=TERM+XXX*(FIVE*XXXI-THREE*RRXI)
      TERM=TERM+YYY*(FIVE*YYYI-THREE*RRYI)
      TERM=TERM+ZZZ*(FIVE*ZZZI-THREE*RRZI)
      TERM=TERM+XXY*(FIVE*XXYI-RRYI)*THREE
      TERM=TERM+XXZ*(FIVE*XXZI-RRZI)*THREE
      TERM=TERM+XYY*(FIVE*XYYI-RRXI)*THREE
      TERM=TERM+YYZ*(FIVE*YYZI-RRZI)*THREE
      TERM=TERM+XZZ*(FIVE*XZZI-RRXI)*THREE
      TERM=TERM+YZZ*(FIVE*YZZI-RRYI)*THREE
      TERM=TERM+XYZ*(FIVE*XYZI)*SIX
      VALO=PT5*TERM/(FIVE*R7)
C APPLY DAMPING
      VAL=VAL+VALO*XDAMP
      RAWVAL=RAWVAL+VALO
410   CONTINUE
      FITTED(K)=VAL
      RAW(K)=RAWVAL
C--      IF(MOD(K,1000).EQ.0) WRITE(6,415) K,FITTED(K)
C--  415 FORMAT(1X,'CGPFIT:',I8,F12.5)
420   CONTINUE
      RETURN
      END
C
C*MODULE CHGPEN  *DECK CGPGRD
      SUBROUTINE CGPGRD(MODE,KOUNT,KOUNT2,X,Y,Z,EFNAM,CO,RMIN,RMAX,NATM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION X(KOUNT),Y(KOUNT),Z(KOUNT),EFNAM(NATM),
     *          CO(3,NATM),RMIN(NATM),RMAX(NATM)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /CGPPAR/ XGRID,CHISQ,THRSH,RMIN1,RMAX1,RMIN2,RMAX2,
     *                ISCCHG,MAXITS,ICFIX,IERRF,NTRACE,NV,NF,
     *                IFTTYP(2),IFTFIX(2)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C        LAY DOWN A CARTESIAN GRID SPANNING THE MOLECULE'S
C        PARALLELOPIPED, AND THEN SAVE ONLY THOSE POINTS
C        OUTSIDE AN INNER RADIUS AND INSIDE AN OUTER RADIUS
C
      KOUNT2=0
      IF(MASWRK  .AND.  MODE.EQ.0) THEN
         WRITE(IW,9010) XGRID
         DO J=1,NATM
            WRITE(IW,9020) EFNAM(J),(CO(I,J),I=1,3),RMIN(J),RMAX(J)
         ENDDO
      END IF
C
C---- FIND THE EDGES OF THE PARALLELOPIPED CONTAINING ALL OUTER SPHERES
C
      XMN=-RMAX(1)+CO(1,1)
      YMN=-RMAX(1)+CO(2,1)
      ZMN=-RMAX(1)+CO(3,1)
      XMX= RMAX(1)+CO(1,1)
      YMX= RMAX(1)+CO(2,1)
      ZMX= RMAX(1)+CO(3,1)
      DO 20 IPT=2,NATM
        TST=-RMAX(IPT)+CO(1,IPT)
        IF(TST.LT.XMN)XMN=TST
        TST=-RMAX(IPT)+CO(2,IPT)
        IF(TST.LT.YMN)YMN=TST
        TST=-RMAX(IPT)+CO(3,IPT)
        IF(TST.LT.ZMN)ZMN=TST
        TST= RMAX(IPT)+CO(1,IPT)
        IF(TST.GT.XMX)XMX=TST
        TST= RMAX(IPT)+CO(2,IPT)
        IF(TST.GT.YMX)YMX=TST
        TST= RMAX(IPT)+CO(3,IPT)
        IF(TST.GT.ZMX)ZMX=TST
20    CONTINUE
      XSPAN=XMX-XMN
      YSPAN=YMX-YMN
      ZSPAN=ZMX-ZMN
C
C----- GET THE NUMBER OF POINTS CORRESPONDING TO THE REQUESTED
C      GRID DENSITY
C
      NPTX=INT(XSPAN/XGRID)
      NPTY=INT(YSPAN/XGRID)
      NPTZ=INT(ZSPAN/XGRID)
      DELX=XSPAN/NPTX
      DELY=YSPAN/NPTY
      DELZ=ZSPAN/NPTZ
C
      DO 100 IX=0,NPTX
      XX=XMN + IX*DELX
      DO 100 IY=0,NPTY
      YY=YMN + IY*DELY
      DO 100 IZ=0,NPTZ
      ZZ=ZMN + IZ*DELZ
C
C  IF THE POINT IS INSIDE OF AN INNER SPHERE, REJECT IT.
C  IF THE POINT IS INSIDE OF ANY OUTER SPHERE, KEEP IT.
C
      INSIDE=0
      DO 40 JPT=1,NATM
         XJ=XX-CO(1,JPT)
         YJ=YY-CO(2,JPT)
         ZJ=ZZ-CO(3,JPT)
         RJ=SQRT(XJ*XJ+YJ*YJ+ZJ*ZJ)
         IF(RJ.LT.RMIN(JPT)) GO TO 100
         IF(RJ.LT.RMAX(JPT)) INSIDE=1
40    CONTINUE
      IF(INSIDE.EQ.0) GO TO 100
C
      KOUNT2=KOUNT2+1
      IF(MODE.GT.0) THEN
         X(KOUNT2)=XX
         Y(KOUNT2)=YY
         Z(KOUNT2)=ZZ
      END IF
  100 CONTINUE
C
      RETURN
 9010 FORMAT(/1X,'GRID SPACING REQUESTED = ',F6.2,' BOHR'/
     *        1X,'----- EXPANSION POINTS FOR ACTIVE VOLUMES -----'/
     *        19X,'X',11X,'Y',11X,'Z',9X,'RMIN',8X,'RMAX')
 9020 FORMAT(1X,A8,1X,5(2X,F10.4))
      END
C
C*MODULE CHGPEN  *DECK CGPINV
      SUBROUTINE CGPINV(A,N,B,NMAX,M,DET,INDEX1,INDEX2,IPIVOT,PIVOT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION INDEX1(NMAX),INDEX2(NMAX),IPIVOT(NMAX),A(NMAX*NMAX),
     *          B(NMAX)
C
      EQUIVALENCE (IROW,JROW),(ICOLUM,JCOLUM),(AMAX,T,SWAP),(NL1,NROW)
C
C   SOLUTION OF MATRIX EQUATION AX=B  OBTAIN A(-1) & X
C     A     FIRST ADDRESS OF A  -  A(-1) UPON RETURN
C               A IS DESTROYED DURING SOLUTION
C     N     ORDER OF A AT THIS ENTRANCE
C     B     VECTORS B   -  LOCATION OF X UPON RETURN
C               B IS DESTROYED DURING SOLUTION
C     NMAX  EXTERNAL DIMENSION OF A
C     M     NUMBER OF COLUMN VECTORS IN B
C     DET   COMPUTED VALUE OF THE DETERMINANT OF A
C     INDEX1, INDEX2, & IPIVOT   INTEGER WORK ARRAYS NMAX IN LENGTH
C     PIVOT ON WORD WORK SPACE
C
C     INITIALIZATION
C
      DET = 1.0D+00
      DO 20 J=1,N
   20 IPIVOT(J)=0
      DO 550 I=1,N
C
C     SEARCH FOR PIVOT ELEMENT
C
      AMAX = 0.0D+00
      DO 105 J=1,N
      IF (IPIVOT(J)-1) 60,105,60
   60 DO 100 K=1,N
      IF (IPIVOT(K)-1) 71,100,740
   71 LL=(K-1)*NMAX+J
      IF ( ABS(AMAX)- ABS(A(LL))) 85,100,100
   85 IROW=J
      ICOLUM=K
      AMAX=A (LL)
  100 CONTINUE
  105 CONTINUE
      IF (AMAX) 110,111,110
  111 DET=0.0D+00
      RETURN
  110 IPIVOT(ICOLUM)=IPIVOT(ICOLUM)+1
C
C     INTERCHANGE ROWS TO PUT ELEMENT ON DIAGONAL
C
      IF (IROW-ICOLUM) 140,260,140
  140 DET=-DET
      DO 200 L=1,N
      JCON=(L-1)*NMAX
      NROW=JCON+IROW
      NCOL=JCON+ICOLUM
      SWAP=A(NROW)
      A(NROW)=A(NCOL)
  200 A(NCOL)=SWAP
      IF (M) 260,260,210
  210 DO 250 L=1,M
      JCON=(L-1)*NMAX
      NROW=JCON+IROW
      NCOL=JCON+ICOLUM
      SWAP=B(NROW)
      B(NROW)=B(NCOL)
  250 B(NCOL)=SWAP
  260 INDEX1(I)=IROW
      INDEX2(I)=ICOLUM
      LL=(ICOLUM-1)*NMAX+ICOLUM
      PIVOT=A(LL)
      DET=DET*PIVOT
C
C     DIVIDE PIVOT ROW BY PIVOT ELEMENT
C
      A(LL)=1.0D+00
      DO 350 L=1,N
      NCOL=(L-1)*NMAX+ICOLUM
  350 A(NCOL)=A(NCOL)/PIVOT
      IF(M) 371,371,360
  360 DO 370 L=1,M
      NCOL=(L-1)*NMAX+ICOLUM
  370 B(NCOL)=B(NCOL)/PIVOT
C
C     REDUCE NON-PIVOT ROWS
C
  371 JCON=(ICOLUM-1)*NMAX
      DO 550 L1=1,N
      IF (L1-ICOLUM) 391,550,391
  391 LL=JCON+L1
      T=A(LL)
      A(LL)=0.0D+00
      DO 450 L=1,N
      NCON=(L-1)*NMAX
      NL1=NCON+L1
      NCOL=NCON+ICOLUM
  450 A(NL1)=A(NL1)-A(NCOL)*T
      IF (M) 550,550,460
  460 DO 500 L=1,M
      NCON=(L-1)*NMAX
      NL1=NCON+L1
      NCOL=NCON+ICOLUM
  500 B(NL1)=B(NL1)-B(NCOL)*T
  550 CONTINUE
C
C     INTERCHANGE COLUMNS
C
      DO 710 I=1,N
      L=N+1-I
      IF (INDEX1(L)-INDEX2(L)) 630,710,630
  630 JROW=INDEX1(L)
      JCOLUM=INDEX2(L)
      JCON=(JROW-1)*NMAX
      NCON=(JCOLUM-1)*NMAX
      DO 705 K=1,N
      NROW=JCON+K
      NCOL=NCON+K
      SWAP=A(NROW)
      A(NROW)=A(NCOL)
      A(NCOL)=SWAP
  705 CONTINUE
  710 CONTINUE
  740 RETURN
      END
C
C*MODULE CHGPEN  *DECK STEPIT
      SUBROUTINE STEPIT(NCALL,INDEX1,INDEX2,IPIVOT,XQ,BQ,VQ,
     *                  CHI,ZZZ,ZBAR,ZSTAR,X,Y,Z,QUANT,DIFF,RAW,FITTED,
     *                  EFPOS,EFC,EFD,EFQ,EFO,ISETA,INUM,COEF,ALP,
     *                  IFRZ,IEQ,XVAL,XMAX,XMIN,DELTAX,DELMIN,MASK,
     *                  KOUNT,NVX,NEFC,NEFC5,NFIT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION INDEX1(NVX),INDEX2(NVX),IPIVOT(NVX),XQ(NVX,NVX),
     *          BQ(NVX),VQ(NVX),CHI(NEFC5),ZZZ(NEFC5,NEFC5),ZBAR(NEFC5),
     *          ZSTAR(NEFC5),X(KOUNT),Y(KOUNT),Z(KOUNT),QUANT(KOUNT),
     *          DIFF(KOUNT),RAW(KOUNT),FITTED(KOUNT),EFPOS(3,NEFC),
     *          EFC(NEFC),EFD(3,NEFC),EFQ(6,NEFC),EFO(10,NEFC),
     *          ISETA(5,NEFC),INUM(NEFC),COEF(5,NEFC),
     *          ALP(5,NEFC),IFRZ(5,NEFC),IEQ(NEFC),
     *          XVAL(NEFC5),XMAX(NEFC5),XMIN(NEFC5),DELTAX(NEFC5),
     *          DELMIN(NEFC5),MASK(NEFC5)
C
      COMMON /CGPPAR/ XGRID,CHISQ,THRSH,RMIN1,RMAX1,RMIN2,RMAX2,
     *                ISCCHG,MAXITS,ICFIX,IERRF,NTRACE,NV,NF,
     *                IFTTYP(2),IFTFIX(2)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C  COPYRIGHT 1965 -- J. P. CHANDLER, PHYSICS DEPT., INDIANA UNIVERSITY.
C  SIMPLEX 1.3          FEBRUARY, 1968
C  MINIMIZES A PIECEWISE CONTINUOUS FUNCTION SUBJECT TO ARBITRARY
C  CONSTRAINTS OF INEQUALITY.
C  J. A. NELDER AND R. MEAD, THE COMPUTER JOURNAL 7 (1965) 308
C  AT PRESENT MATRIX AND ERR ARE INOPERATIVE.
C  AVAILABLE FROM....      QUANTUM CHEMISTRY PROGRAM EXCHANGE,
C                          I.U. CHEMISTRY DEPT., BLOOMINGTON, INDIANA.
C
C         CHISQ = THE CURRENT VALUE OF THE FUNCTION BEING MINIMIZED
C         XVAL = THE CURRENT VALUES OF THE NON-LINEAR PARAMETERS
C         XMAX = THE MAXIMUM ALLOWED VALUE OF EACH PARAMETER
C         XMIN = THE MINIMUM ALLOWED VALUE OF EACH PARAMETER
C         DELTAX = THE INITIAL VARIATION OF EACH PARAMETER
C         DELMIN = THE MINIMUM VARIATION OF EACH PARAMETER
C         NV = THE NUMBER OF PARAMETERS (VARIABLES)
C         NTRACE = NON-ZERO TO GET A TRACE OF THE MINIMIZATION PROCESS
C         MASK = A FREEZE FLAG (= 1) FOR EACH VARIABLE
C         NF = A TEST FOR FLATNESS OF THE SURFACE,USE DEFAULT IN STEPIT
C
      NFMAX=MAXITS
      NFLAT=1
C
C        INITIALIZE DATA
C   XVAL = ACTIVE EXPONENT
C   XMIN = MINIMUM VALUE OF EXPONENT
C   XMAX = MAXIMUM VALUE OF EXPONENT
C   DELMIN = MINIMUM VARIATION DURING OPTIMIZATION (MAKE SMALLER FOR
C            TIGHTER FIT)
C   DELTAX = INITIAL (MAXIMUM) VARAIATION (ARBITRARILY CHOSE 10%)
C   MASK = 1 TO FREEZE EXPONENT, BUT ALWAYS SET TO ZERO BECAUSE
C          ONLY ACTIVE EXPONENTS ARE BEING PASSED TO STEPIT.
C
C        THE REFIT SHOULD START WITH THE FINAL VALUES OF THE 1ST FIT.
C
      IF(NCALL.GT.1) GO TO 40
C
C        ON THE FIRST FIT, USE THE USER'S INPUT AS THE INITIAL GUESS
C        OTHERWISE, USE THE STO-1G FORMULA TO CONVERT BETWEEN
C        THE PREVIOUSLY OPTIMIZED EXPONENT AND THE NEXT ONE.
C
      NALPX=0
      DO 38 IEFC=1,NEFC
         IF(IEQ(IEFC).NE.IEFC) GO TO 38
         DO 37 J=1,INUM(IEFC)
            IF(IFRZ(J,IEFC).EQ.0) THEN
               NALPX = NALPX+1
               IF(NFIT.EQ.1) THEN
                  XVAL(NALPX)=ALP(J,IEFC)
               ELSE
                  IF(IFTTYP(1).EQ.2) THEN
                     XVAL(NALPX)=ALP(J,IEFC)*ALP(J,IEFC)*2.709498091D-01
                  ELSE
                     XVAL(NALPX)=SQRT(ALP(J,IEFC)/2.709498091D-01)
                  END IF
               END IF
               XMIN(NALPX)=0.05D+00
               XMAX(NALPX)=10.0D+00
               DELMIN(NALPX)=0.0005D+00
               DELTAX(NALPX)=0.1D+00*XVAL(NALPX)
               MASK(NALPX)=0
            END IF
   37    CONTINUE
   38 CONTINUE
C
   40 CONTINUE
      HUGE=1.0D+50
      ALPHA=1.0D+00
      BETA=0.5D+00
      GAMMA=2.0D+00
C
      IF(NV)1220,1220,50
   50 DO 130 J=1,NV
      IF(MASK(J))130,60,130
   60 IF((XVAL(J)+DELTAX(J))-XVAL(J))100,70,100
   70 IF(XVAL(J))90,80,90
   80 DELTAX(J)=0.01D+00
      GO TO 100
90    DELTAX(J)=0.01D+00*XVAL(J)
  100 IF(XMAX(J)-XMIN(J))110,110,120
  110 XMAX(J)=HUGE
      XMIN(J)=-HUGE
120   DUMIN=MIN(XMAX(J),XVAL(J))
      XVAL(J)=MAX(XMIN(J),DUMIN)
  130 CONTINUE
C
C  CALCULATE INITIAL P(I) AND Y(I).
C
      NVA=0
      NF=0
      J=1
  230 IF(MASK(J))270,240,270
  240 NVA=NVA+1
      DO 250 K=1,NV
  250 ZZZ(NVA,K)=XVAL(K)
      ZZZ(NVA,J)=ZZZ(NVA,J)+DELTAX(J)
      XS=XVAL(J)
      XVAL(J)=ZZZ(NVA,J)
      NGO=1
      GO TO 330
  260 XVAL(J)=XS
      CHI(NVA)=CHISQ
  270 J=J+1
      IF(J-NV)230,230,280
  280 IF(NVA)290,290,310
  290 DO 300 J=1,NV
  300 MASK(J)=0
      CALL STEPFX(INDEX1,INDEX2,IPIVOT,XQ,BQ,VQ,NVX,
     *            X,Y,Z,QUANT,DIFF,RAW,FITTED,KOUNT,XVAL,
     *            EFPOS,EFC,EFD,EFQ,EFO,ISETA,INUM,COEF,ALP,NEFC)
      RETURN
  310 NVP=NVA+1
      DO 320 J=1,NV
  320 ZZZ(NVP,J)=XVAL(J)
      NGO=2
C
  330 DO 360 JF=1,NV
      IF(MASK(JF))360,340,360
  340 IF(XVAL(JF)-XMAX(JF))350,350,370
  350 IF(XVAL(JF)-XMIN(JF))370,360,360
  360 CONTINUE
      NF = NF + 1
      CALL STEPFX(INDEX1,INDEX2,IPIVOT,XQ,BQ,VQ,NVX,
     *            X,Y,Z,QUANT,DIFF,RAW,FITTED,KOUNT,XVAL,
     *            EFPOS,EFC,EFD,EFQ,EFO,ISETA,INUM,COEF,ALP,NEFC)
      GO TO 380
  370 CHISQ=HUGE
  380 GO TO (260,390,630,720,860,1220),NGO
C
  390 CONTINUE
      CHI(NVP)=CHISQ
      IF(MASWRK) THEN
        WRITE(IW,410) NV,NVA,NFLAT,ALPHA,BETA,GAMMA,CHISQ,
     *                (XVAL(J),J=1,NV)
        WRITE(IW,411)
      END IF
      JL=NVP
C
C  DETERMINE H AND L.
C
  450 JH=JL
      DO 490 J=1,NVP
      IF(CHI(J)-CHI(JH))470,470,460
  460 JH=J
  470 IF(CHI(J)-CHI(JL))480,490,490
  480 JL=J
  490 CONTINUE
      IF(JH-JL)560,500,560
  500 IF(NFLAT)540,540,510
  510 IF(NTRACE)1200,520,520
  520 CONTINUE
      IF(MASWRK) WRITE(IW,530)
  530 FORMAT(1X,'STOPPED BECAUSE THE FUNCTION VALUES AT ALL SIMPLEX',
     *          ' POINTS BECAME EXACTLY EQUAL.')
      GO TO 1200
  540 JH=1
      IF(JL-1)560,550,560
  550 JH=2
C
C  CALCULATE PBAR.
C
  560 DO 600 J=1,NV
      IF(MASK(J))600,570,600
  570 ZBAR(J)=0.0D+00
      DO 590 K=1,NVP
      IF(K-JH)580,590,580
  580 ZBAR(J)=ZBAR(J)+ZZZ(K,J)
  590 CONTINUE
      ZBAR(J)=ZBAR(J)/NVA
  600 CONTINUE
C
C  ATTEMPT A REFLECTION.
C  FORM P* .
C
      DO 620 J=1,NV
      IF(MASK(J))620,610,620
610   XVAL(J)=(1.0D+00+ALPHA)*ZBAR(J)-ALPHA*ZZZ(JH,J)
  620 ZSTAR(J)=XVAL(J)
      NGO=3
      GO TO 330
  630 CHISTR=CHISQ
      IF(CHISQ-CHI(JL))640,730,730
C
C  THE REFLECTION SUCCEEDED.  ATTEMPT AN EXPANSION.
C  FORM P** .
C
  640 IF(NTRACE)690,690,650
  650 CONTINUE
      IF(MASWRK) THEN
         WRITE(IW,660) CHISQ
         WRITE(IW,670) (XVAL(J),J=1,NV)
         WRITE(IW,680)
      END IF
  660 FORMAT(10X,"CHISQ = ",E17.10,10X,"REFLECTION SUCCEEDED"  )
  670 FORMAT(5X,'XVAL(I)....'/,(7E17.8))
  680 FORMAT(" ")
C
  690 DO 710 J=1,NV
      IF(MASK(J))710,700,710
700   XVAL(J)=GAMMA*XVAL(J)+(1.0D+00-GAMMA)*ZBAR(J)
  710 CONTINUE
      NGO=4
      GO TO 330
  720 IF(CHISQ-CHISTR)1070,760,760
C
C  THE REFLECTION FAILED.
C
  730 DO 750 J=1,NVP
      IF(J-JH)740,750,740
  740 IF(CHISQ-CHI(J))790,750,750
  750 CONTINUE
      IF(CHISQ-CHI(JH))810,830,830
C
  760 IF(NTRACE)790,790,770
  770 CONTINUE
      IF(MASWRK) WRITE(IW,780)
  780 FORMAT(45X,"EXPANSION FAILED"  )
C
C  REPLACE P(JH) BY P* .
C
  790 DO 800 J=1,NV
  800 ZZZ(JH,J)=ZSTAR(J)
      CHI(JH)=CHISTR
      GO TO 1120
C
  810 DO 820 J=1,NV
  820 ZZZ(JH,J)=XVAL(J)
      CHI(JH)=CHISQ
C
C  ATTEMPT A CONTRACTION.
C  FORM P** .
C
  830 DO 850 J=1,NV
      IF(MASK(J))850,840,850
840   XVAL(J)=BETA*ZZZ(JH,J)+(1.0D+00-BETA)*ZBAR(J)
  850 CONTINUE
      NGO=5
      GO TO 330
  860 IF(CHISQ-CHI(JH))870,930,930
  870 IF(NTRACE)1100,1100,880
  880 IF(CHISQ-CHI(JL))890,910,910
  890 CONTINUE
      GO TO 1100
  910 CONTINUE
      GO TO 1100
C
C  THE CONTRACTION FAILED.
C  REPLACE ALL P(I) BY (P(I)+P(JL))/2.0 , GUARDING THE ROUNDING.
C
  930 IF(NTRACE)960,960,940
  940 CONTINUE
      IF(MASWRK) WRITE(IW,950)
  950 FORMAT(45X,"CONTRACTION FAILED"  )
  960 JS=JL
      DO 1060 J=1,NVP
      IF(J-JL)970,1060,970
  970 DO 1020 K=1,NV
      IF(MASK(K))1020,980,1020
  980 IF(ZZZ(J,K)-ZZZ(JL,K))990,1000,990
  990 XVAL(K)=(ZZZ(J,K)+ZZZ(JL,K))/2.0D+00
      IF(XVAL(K)-ZZZ(J,K))1010,1000,1010
 1000 XVAL(K)=ZZZ(JL,K)
 1010 ZZZ(J,K)=XVAL(K)
 1020 CONTINUE
      DO 1360 JF=1,NV
      IF(MASK(JF))1360,1345,1360
 1345 IF(XVAL(JF)-XMAX(JF))1350,1350,1370
 1350 IF(XVAL(JF)-XMIN(JF))1370,1360,1360
 1360 CONTINUE
      NF = NF + 1
      CALL STEPFX(INDEX1,INDEX2,IPIVOT,XQ,BQ,VQ,NVX,
     *            X,Y,Z,QUANT,DIFF,RAW,FITTED,KOUNT,XVAL,
     *            EFPOS,EFC,EFD,EFQ,EFO,ISETA,INUM,COEF,ALP,NEFC)
      GO TO 1030
 1370 CHISQ=HUGE
 1030 IF(CHISQ-CHI(JS))1040,1050,1050
 1040 JS=J
 1050 CHI(J)=CHISQ
 1060 CONTINUE
      JL=JS
      GO TO 1120
C
 1070 IF(NTRACE)1100,1100,1080
 1080 CONTINUE
      IF(MASWRK) THEN
         WRITE(IW,1090) CHISQ
         WRITE(IW,670) (XVAL(J),J=1,NV)
         WRITE(IW,680)
      END IF
 1090 FORMAT(10X,"CHISQ = ",E17.10,10X,"EXPANSION SUCCEEDED"  )
C
C  REPLACE P(JH) BY P* OR P** .
C
 1100 DO 1110 J=1,NV
 1110 ZZZ(JH,J)=XVAL(J)
      CHI(JH)=CHISQ
C
C  TEST FOR CONVERGENCE.
C
 1120 DO 1150 J=1,NV
      IF(MASK(J))1150,1130,1150
 1130 ZMAX=ZZZ(1,J)
      ZMIN=ZZZ(1,J)
      DO 1140 K=2,NVP
      ZMAX=MAX(ZMAX,ZZZ(K,J))
 1140 ZMIN=MIN(ZMIN,ZZZ(K,J))
      IF((ZMAX-ZMIN)-ABS(DELMIN(J)))1150,1150,1260
 1150 CONTINUE
      IF(NTRACE)1180,1160,1160
 1160 CONTINUE
      IF(MASWRK) WRITE(IW,1170)
 1170 FORMAT(1X,'STOPPED BECAUSE THE DIMENSIONS OF THE SIMPLEX',
     *          ' BECAME LESS THAN DELMIN(J).')
C
 1180 IF(CHI(JH)-CHI(JL))1190,1200,1200
 1190 JL=JH
 1200 DO 1210 J=1,NV
 1210 XVAL(J)=ZZZ(JL,J)
      NGO=6
      GO TO 330
 1220 IF(NTRACE)1250,1230,1230
 1230 CONTINUE
      IF(MASWRK) THEN
         WRITE(IW,1240) NF,CHISQ,(XVAL(J),J=1,NV)
         IF(ICFIX.EQ.0) THEN
            WRITE(IW,*) 'LINEAR COEFFICIENT VALUES'
            DO 1238 IEFC=1,NEFC
               IF(IEQ(IEFC).NE.IEFC) GO TO 1238
               DO J=1,INUM(IEFC)
                  IF(IFRZ(J,IEFC).EQ.0) THEN
                      WRITE(IW,1245) COEF(J,IEFC)
                  END IF
               ENDDO
 1238       CONTINUE
         END IF
      END IF
 1250 RETURN
C
 1260 CONTINUE
      IF(NF-NFMAX)450,450,1280
 1280 CONTINUE
      IF(MASWRK) WRITE(IW,1290) NFMAX
 1290 FORMAT(////" ABNORMAL TERMINATION....  MORE THAN NFMAX=" ,I5,
     *   31H CALLS TO THE CHISQ SUBROUTINE.   )
      GO TO 1320
 1320 CONTINUE
      DO 1340 J=1,NVP
         IF(MASWRK) WRITE(IW,1330) J,CHI(J)
         IF(MASWRK) WRITE(IW,670) (ZZZ(J,K),K=1,NV)
 1340 CONTINUE
      GO TO 1180
 1330 FORMAT(10X,"SIMPLEX POINT",I3," ....  CHISQ = ",E17.10)
C
  410 FORMAT(1X,I5,' VARIABLES',I5,' ACTIVE',5X,' NFLAT=',I3/
     *       1X,'ALPHA =',F4.1,10X,'BETA =',F5.2,10X,'GAMMA =',F4.1/
     *       1X,'INITIAL VALUE OF CHISQ =',1P,E17.10,0P/
     *       1X,'INITIAL VALUES OF THE PARAMETERS ARE ',:,(/5F15.8))
  411 FORMAT(1X,'BEGINNING SIMPLEX MINIMIZATION....')
 1240 FORMAT(1X,'SIMPLEX PERFORMED',I8,' FUNCTION COMPUTATIONS.'/
     *       1X,'ENDING VALUE OF CHISQ   =',1P,E17.10,0P/
     *       1X,'ENDING VALUES OF THE PARAMETERS ARE ',:,(/5F15.8))
 1245 FORMAT(1X,G15.8)
      END
C
C*MODULE CHGPEN  *DECK STEPFX
      SUBROUTINE STEPFX(INDEX1,INDEX2,IPIVOT,XQ,BQ,VQ,NVX,
     *                  X,Y,Z,QUANT,DIFF,RAW,FITTED,KOUNT,XVAL,
     *                  EFPOS,EFC,EFD,EFQ,EFO,ISETA,INUM,COEF,ALP,NEFC)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION INDEX1(NVX),INDEX2(NVX),IPIVOT(NVX),XQ(NVX,NVX),
     *          BQ(NVX),VQ(NVX),X(KOUNT),Y(KOUNT),Z(KOUNT),
     *          QUANT(KOUNT),DIFF(KOUNT),RAW(KOUNT),FITTED(KOUNT),
     *          XVAL(*),EFPOS(3,NEFC),
     *          EFC(NEFC),EFD(3,NEFC),EFQ(6,NEFC),EFO(10,NEFC),
     *          ISETA(5,NEFC),INUM(NEFC),COEF(5,NEFC),ALP(5,NEFC)
C
      COMMON /CGPPAR/ XGRID,CHISQ,THRSH,RMIN1,RMAX1,RMIN2,RMAX2,
     *                ISCCHG,MAXITS,ICFIX,IERRF,NTRACE,NV,NF,
     *                IFTTYP(2),IFTFIX(2)
C
C  CALLED BY STEPIT.  APPLIES CURRENT EXPONENTS
C  DETERMINES COEFFICIENTS BY LINEAR LEAST SQUARES.
C
      DATA ZERO,ONE,TWO/0.0D+00,1.0D+00,2.0D+00/
C
C---- STORE CURRENT DAMPING EXPONENTS
C LOOP OVER MULTIPOLAR CENTERS
C LOOP OVER TERMS IN DAMPING FUNCTION
C IF THIS TERM HAS ACTIVE EXPONENT, GET CURRENT VALUE FROM -XVAL-
C ISETA MAPS ACTIVE EXPONENTS ONTO PROPER DAMPING CENTER
C
      DO 10 IEFC=1,NEFC
         DO 8 J=1,INUM(IEFC)
            IND=ISETA(J,IEFC)
            IF(IND.EQ.0) GO TO 10
            ALP(J,IEFC)=XVAL(IND)
C--            WRITE(6,5) IEFC,ALP(J,IEFC)
C--    5       FORMAT(1X,'STEPFX: IEFC,ALP = ',I6,F12.5)
    8    CONTINUE
   10 CONTINUE
C
C ----- SET COEFFICIENTS TO 1.0 IF ICFIX IS TURNED ON
C
      IF (ICFIX.EQ.1) THEN
         DO IEFC=1,NEFC
            DO J=1,INUM(IEFC)
               COEF(J,IEFC)=ONE
            ENDDO
         ENDDO
         GO TO 625
      ELSE
C
C ----- IF ICFIX IS NOT ON, DO MATRIX INVERSION LEAST SQUARES
C ----- ZERO OUT ARRAYS USED IN LINEAR COEFFICIENT DETERMINATION -----
C
      DO 100 I=1,NV
      VQ(I)=ZERO
      BQ(I)=ZERO
      DO 100 J=1,NV
      XQ(J,I)=ZERO
100   CONTINUE
C
C ----- ACCUMULATE SUMS FOR LINEAR LEAST SQUARES -----
C
      DO 500 K=1,KOUNT
      IF(IERRF.EQ.0) EVAL=DIFF(K)
      IF(IERRF.EQ.1) EVAL=QUANT(K)
      IF(IERRF.EQ.2) EVAL=DIFF(K)
      IF(IERRF.EQ.3) EVAL=DIFF(K)
      DO 101 I=1,NV
      VQ(I)=ZERO
101   CONTINUE
      DO 450 IEFC=1,NEFC
      XX=(X(K)-EFPOS(1,IEFC))**2
      YY=(Y(K)-EFPOS(2,IEFC))**2
      ZZ=(Z(K)-EFPOS(3,IEFC))**2
      RRI=XX+YY+ZZ
C THE NEXT IF TEST ALLOWS FOR SCREENING CHARGES ONLY
C THIS IS AN OLD IDEA THAT WE DON'T USE ANYMORE
      IF(ISCCHG.EQ.1)THEN
        VALI=EFC(IEFC)/SQRT(RRI)
      ELSE
        VALI=CGPMUL(K,IEFC,X,Y,Z,KOUNT,EFPOS,EFC,EFD,EFQ,EFO,NEFC)
      ENDIF
C
      DO 440 J=1,INUM(IEFC)
      IND=ISETA(J,IEFC)
C WE ONLY GET COEFFICIENTS FOR ACTIVE (NON-FROZEN) TERMS
      IF(IND.EQ.0)GO TO 450
C THE FOLLOWING CHANGE IS FOR ERROR FUNCTIONS
      ALPRRI=ALP(J,IEFC)*RRI
      IF(IERRF.EQ.0) DAMPI=EXP(-ALPRRI)
      IF(IERRF.EQ.1) DAMPI=-ERRF(SQRT(ALPRRI))
      IF(IERRF.EQ.2) DAMPI=EXP(-ALP(J,IEFC)*SQRT(RRI))
      IF(IERRF.EQ.3) DAMPI=EXP(-TWO*ALP(J,IEFC)*SQRT(RRI))*
     *                     (ONE+ALP(J,IEFC)*SQRT(RRI))
      DVALI=VALI*DAMPI
C--      IF(MOD(K,1000).EQ.0) WRITE(6,105) K,J,IEFC,DVALI
C--  105 FORMAT(1X,'STEPFX: K,J,IEFC,VALI = ',3I8,F12.5)
      VQ(IND)=VQ(IND)+DVALI
      BQ(IND)=BQ(IND)-DVALI*EVAL
440   CONTINUE
450   CONTINUE
      DO 350 I=1,NV
      DO 350 J=1,NV
      XQ(I,J)=XQ(I,J)+VQ(I)*VQ(J)
350   CONTINUE
500   CONTINUE
C
C ----- DO MATRIX INVERSION AND STORE COEFFICIENTS -----
C
      CALL CGPINV(XQ,NV,BQ,NVX,1,DET,INDEX1,INDEX2,IPIVOT,PIVOT)
      DO 600 IEFC=1,NEFC
      DO 590 J=1,INUM(IEFC)
C WE ALWAYS USE THE ISETA ARRAY TO MAP THE ACTIVE TERMS
      IND=ISETA(J,IEFC)
      IF(IND.EQ.0)GO TO 600
      COEF(J,IEFC)=BQ(IND)
C--      WRITE(6,510) J,IEFC,COEF(J,IEFC)
C--  510 FORMAT('AFTER CGPINV, J,IEFC,COEF = ',2I6,F12.5)
590   CONTINUE
600   CONTINUE
      ENDIF
C
C ----- CALCULATE CHISQ FOR STEPIT -----
C
C CGPFIT ACTUALLY CALCULATES THE ELECTROSTATIC POTENTIAL DUE TO
C THE DAMPED MULTIPOLES
  625 CONTINUE
      CALL CGPFIT(X,Y,Z,RAW,FITTED,KOUNT,
     *            EFPOS,EFC,EFD,EFQ,EFO,INUM,COEF,ALP,NEFC)
      CHISQ=ZERO
      DO 700 K=1,KOUNT
      XDIFF=(QUANT(K)-FITTED(K))
      XDIFF=(QUANT(K)-FITTED(K))*627.52D+00
C--      IF(MOD(K,1000).EQ.0) WRITE(6,650) K,QUANT(K),FITTED(K),XDIFF
C--  650 FORMAT('STEPFX:',I8,3F12.5)
      CHISQ=CHISQ+XDIFF**2
700   CONTINUE
C CHISQ WILL BE USED BY STEPIT TO DETERMINE THE NEXT SIMPLEX MOVE
      CHISQ=SQRT(CHISQ/(KOUNT-1))
C
C ----- FINISHED -----
C
      RETURN
      END
C
C*MODULE CHGPEN  *DECK CGPPRT
      SUBROUTINE CGPPRT(X,Y,Z,QUANT,FITTED,RAW,
     *                  EFNAM,EFPOS,INUM,COEF,ALP,KOUNT,NEFC)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION X(KOUNT),Y(KOUNT),Z(KOUNT),QUANT(KOUNT),
     *          FITTED(KOUNT),RAW(KOUNT),EFNAM(NEFC),EFPOS(3,NEFC),
     *          INUM(NEFC),COEF(5,NEFC),ALP(5,NEFC)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /CGPPAR/ XGRID,CHISQ,THRSH,RMIN1,RMAX1,RMIN2,RMAX2,
     *                ISCCHG,MAXITS,ICFIX,IERRF,NTRACE,NV,NF,
     *                IFTTYP(2),IFTFIX(2)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO/0.0D+00/
C
C         PRINT OUT FINAL RESULTS OF CHARGE SCREENING
C
      IF(.NOT.MASWRK) RETURN
C
      WRITE(IW,10)
      DO 30 K=1,NEFC
         WRITE(IW,20) EFNAM(K),(EFPOS(I,K),I=1,3),
     *                (COEF(J,K),ALP(J,K),J=1,INUM(K))
         WRITE(IP,21) (EFNAM(K),COEF(J,K),ALP(J,K),J=1,INUM(K))
30    CONTINUE
C
      SUM=ZERO
      RSUM=ZERO
      RSQ=ZERO
      RSQ1=ZERO
      CHISQ=ZERO
      CHISQ1=ZERO
      NUM1=0
      NUMR1=0
      RSQ2=ZERO
      CHISQ2=ZERO
      NUM2=0
      NUMR2=0
      RSQ3=0
      CHISQ3=ZERO
      NUM3=0
      NUMR3=0
      RSQ4=ZERO
      CHISQ4=ZERO
      NUMR4=0
      NUM4=0
      DO 100 K=1,KOUNT
      XDIFF=(QUANT(K)-FITTED(K))*627.52D+00
      YDIFF=(QUANT(K)-RAW(K))*627.52D+00
      SUM=SUM+ABS(XDIFF)
      RSUM=RSUM+ABS(YDIFF)
      CHISQ=CHISQ+XDIFF**2
      RSQ=RSQ+YDIFF**2
      IF(ABS(XDIFF).GT.0.5D+00)THEN
         CHISQ1=CHISQ1+XDIFF**2
         NUM1=NUM1+1
      END IF
      IF(ABS(XDIFF).GT.1.0D+00)THEN
         CHISQ2=CHISQ2+XDIFF**2
         NUM2=NUM2+1
      END IF
      IF(ABS(XDIFF).GT.2.0D+00)THEN
         CHISQ3=CHISQ3+XDIFF**2
         NUM3=NUM3+1
      END IF
      IF(ABS(XDIFF).GT.4.0D+00)THEN
         CHISQ4=CHISQ4+XDIFF**2
         NUM4=NUM4+1
      END IF
      IF(ABS(YDIFF).GT.0.5D+00)THEN
         RSQ1=RSQ1+YDIFF**2
         NUMR1=NUMR1+1
      END IF
      IF(ABS(YDIFF).GT.1.0D+00)THEN
         RSQ2=RSQ2+YDIFF**2
         NUMR2=NUMR2+1
      END IF
      IF(ABS(YDIFF).GT.2.0D+00)THEN
         RSQ3=RSQ3+YDIFF**2
         NUMR3=NUMR3+1
      END IF
      IF(ABS(YDIFF).GT.4.0D+00)THEN
         RSQ4=RSQ4+YDIFF**2
         NUMR4=NUMR4+1
      END IF
100   CONTINUE
C
      WRITE(IW,105)
      RMS =SQRT(RSQ /(KOUNT-1))
      RMS1=SQRT(RSQ1/(NUMR1-1))
      RMS2=SQRT(RSQ2/(NUMR2-1))
      RMS3=SQRT(RSQ3/(NUMR3-1))
      RMS4=SQRT(RSQ4/(NUMR4-1))
      AVG=RSUM/KOUNT
      WRITE(IW,110)KOUNT,AVG,KOUNT,RMS,NUMR1,RMS1,NUMR2,RMS2,NUMR3,
     1             RMS3,NUMR4,RMS4
      WRITE(IW,106)
      RMS =SQRT(CHISQ /(KOUNT-1))
      RMS1=SQRT(CHISQ1/(NUM1 -1))
      RMS2=SQRT(CHISQ2/(NUM2 -1))
      RMS3=SQRT(CHISQ3/(NUM3 -1))
      RMS4=SQRT(CHISQ4/(NUM4 -1))
      AVG=SUM/KOUNT
      WRITE(IW,110) KOUNT,AVG,KOUNT,RMS,NUM1,RMS1,NUM2,RMS2,NUM3,
     1              RMS3,NUM4,RMS4
C
      WRITE(IW,120) THRSH
      DO 130 K=1,KOUNT
         SDIFF=QUANT(K)-FITTED(K)
         RDIFF=QUANT(K)-RAW(K)
         IF(ABS(SDIFF).LT.THRSH/627.52D+00) GO TO 130
         RDST=SQRT(X(K)*X(K)+Y(K)*Y(K)+Z(K)*Z(K))
         WRITE(IW,125) K,RDST,X(K),Y(K),Z(K),QUANT(K)*627.52D+00,
     *                 SDIFF*627.52D+00,RDIFF*627.52D+00
  130 CONTINUE
      RETURN
C
   10 FORMAT(/15X,'----- OPTIMIZED SCREENING PARAMETERS ----- '/
     *       1X,'NAME',10X,'X',8X,'Y',8X,'Z',15X,'COEF',17X,'ALPHA')
   20 FORMAT(1X,A8,3(1X,F8.4),2(1X,F20.10),:,(/36X,2F20.10))
  105 FORMAT(/1X,'STATISTICS FOR UNSCREENED MULTIPOLES'/
     1        1X,'------------------------------------')
  106 FORMAT(/1X,'STATISTICS FOR SCREENED MULTIPOLES'/
     1        1X,'----------------------------------')
  110 FORMAT(' AVERAGE UNSIGNED ERROR       (',I10,' PTS) = ',1P,E12.6/
     *       ' RMS DEVIATION                (',I10,' PTS) = ',1P,E12.6/
     *       ' RMS DEVIATION (ERRORS > 0.5) (',I10,' PTS) = ',1P,E12.6/
     *       ' RMS DEVIATION (ERRORS > 1.0) (',I10,' PTS) = ',1P,E12.6/
     *       ' RMS DEVIATION (ERRORS > 2.0) (',I10,' PTS) = ',1P,E12.6/
     *       ' RMS DEVIATION (ERRORS > 4.0) (',I10,' PTS) = ',1P,E12.6)
  120 FORMAT(/1X,'LARGE ERRORS (QUANTUM - MULTIPOLE FIT) > ',F5.2,
     *           ' KCAL/MOL'/
     *        1X,'  POINT    DISTANCE    X       Y       Z',
     *           '      QUANTUM      DIFF      DIFF   '/
     *        1X,'         FROM ORIGIN                    ',
     *           '                 SCREEN  NOSCREEN'/)
  125 FORMAT(1X,I10,F9.2,3F8.4,3F10.2)
C
   21 FORMAT(1X,A8,2F14.9)
      END

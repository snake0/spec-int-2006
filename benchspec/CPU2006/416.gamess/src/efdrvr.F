C  9 DEC 03 - MWS - EFGRAD: KILL NUMERICAL HESSIAN REQUEST
C  3 JUL 03 - JMM - SUPPRESS PRINTING FOR MONTE CARLO JOBS
C  7 AUG 02 - HT  - USE DYNAMIC MEMORY FOR EFP PAULI REPULSION
C 17 APR 02 - MWS - SYNCH UP FRGINF COMMON
C 13 JUN 01 - MAF - EFSP: COMPUTE CHARGE PENETRATION ENERGY
C 20 FEB 01 - PND - EFSP,EFPPOL: DIP.CONV. AND PRINTING CHANGES
C 25 MAR 00 - MWS - CHANGE ARGUMENTS TO VNNDER
C 20 NOV 97 - MWS - EFSP: USE JAN'S PAULI EXCHANGE ROUTINE
C  2 SEP 97 - MWS - EFSP: CHANGE WORDING OF ENERGY OUTPUT
C 16 MAY 97 - GNM - EFFECTIVE FRAGMENT DRIVER MODULE CREATED
C
C*MODULE EFDRVR  *DECK EFSP
      SUBROUTINE EFSP
C
C ----------------------------------------------------------------
C --- THIS SUBROUTINE CALCULATES FRAGMENT-FRAGMENT INTERACTION ---
C ---     ENERGIES IN THE ABSENCE OF AN AB INITIO MOLECULE     ---
C ----------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=500, MXDFG=5, MXFRG=50, MXPT=100,
     *           MXFGPT=MXPT*MXFRG)
      PARAMETER (ZERO = 0.0D+00)
C
      COMMON /FMCOM / XX(1)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /FUNCT / E,EG(3*MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /OPTGRD/ Q(3*MXATM),ES,QQ(20),
     *                CONVF,FMAXT,DXMAXT,RMAX,RMIN,RLIM,
     *                EIGMAX,EIGMIN,GRDERR,FRMS,FMAX,TRMAX,TRMIN,
     *                IC(20),NSTEP,NSERCH,NPMAX,NP,IFOLOW,
     *                NNEG,IUPHSS,IEXIT,ITRUPD,IPAD
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
C
      DATA ESNRG, CCNRG, CDNRG, CQNRG, CONRG, DDNRG, DQNRG, QQNRG,
     *   REPNRG, POLNRG /10 * 0.0D+00/
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA OPTIMIZ /8HOPTIMIZE/, HSSIAN  /8HHESSIAN /
#else
      CHARACTER*8 :: OPTIMIZ_STR
      EQUIVALENCE (OPTIMIZ, OPTIMIZ_STR)
      CHARACTER*8 :: HSSIAN_STR
      EQUIVALENCE (HSSIAN, HSSIAN_STR)
      DATA OPTIMIZ_STR/"OPTIMIZE"/, HSSIAN_STR/"HESSIAN "/
#endif
C
C            --- SUBROUTINE VARIABLES ---
C
C     CCNRG  = CHARGE-CHARGE INTERACTION ENERGY
C     CDNRG  = CHARGE-DIPOLE INTERACTION ENERGY
C     CQNRG  = CHARGE-QUADRUPOLE INTERACTION ENERGY
C     CONRG  = CHARGE-OCTUPOLE INTERACTION ENERGY
C     DDNRG  = DIPOLE-DIPOLE INTERACTION ENERGY
C     DQNRG  = DIPOLE-QUADRUPOLE INTERACTION ENERGY
C     QQNRG  = QUADRUPOLE-QUADRUPOLE INTERACTION ENERGY
C     ESNRG  = TOTAL ELECTROSTATIC INTERACTION ENERGY
C     REPNRG = EXCHANGE-REPULSION ENERGY
C     POLNRG = POLARIZATION ENERGY
C
      E = ZERO
C
C --- CALCULATE INDIVIDUAL AND TOTAL ELECTROSTATIC INTERACTION ENERGIES
C
      CALL CHGCHG(CCNRG)
      CALL CHGDIP(CDNRG)
      CALL CHGQUA(CQNRG)
      CALL CHGOCT(CONRG)
      CALL DPLDPL(DDNRG)
      CALL DPQUAD(DQNRG)
      CALL QUDQUD(QQNRG)
      ESNRG = CCNRG + CDNRG + CQNRG + CONRG + DDNRG + DQNRG + QQNRG
C
C --- CALCULATE EXCHANGE-REPULSION ENERGY ---
C
      CALL EFCM
      IF(IREP.EQ.1) THEN
         MXRPTS = 0
         DO 100 IFRG = 1,NFRG
            MXRPTS = MAX(NRPTS(IFRG),MXRPTS)
  100    CONTINUE
         MXRPTS = MXRPTS+1
         NDFRG2 = (NDFRG*NDFRG+NDFRG)/2
         LEN = MXRPTS*MXRPTS*NDFRG2
      ELSE
         LEN = 1
      END IF
C
C     --- NOW CALCULATE THE DESIRED REPULSIVE POTENTIAL ENERGY ---
C
      IF(IREP.EQ.1) THEN
         CALL VALFM(LOADFM)
         LAREL = LOADFM + 1
         LCREL = LAREL + LEN
         LEFLD = LCREL + LEN
         LEFAD = LEFLD + 3*NPTTPT
         LAST  = LEFAD + 3*NPTTPT
         NEED = LAST - LOADFM - 1
         CALL GETFM(NEED)
         CALL DAREAD(IDAF,IODA,XX(LAREL),2*LEN,75,0)
         CALL EREPUL(REPNRG,XX(LAREL),XX(LCREL),MXRPTS,NDFRG2)
         CALL RETFM(NEED)
      ELSE IF (NTMO.GT.0) THEN
         MXMO=0
         MXBF=0
         DO I = 1, NFRG
            MXMO=MAX(MXMO,NORB(I))
            MXBF=MAX(MXBF,NPBF(I))
         END DO
         MXMO2=(MXMO*MXMO+MXMO)/2
         CALL VALFM(LOADFM)
         LPROVEC = LOADFM  + 1
         LFOCKMA = LPROVEC + MXBF*NTMO
         LSMAT   = LFOCKMA + MXMO2*NFRG
         LTMAT   = LSMAT   + MXBF*MXBF
         LWRK    = LTMAT   + MXBF*MXBF
         LSIJ    = LWRK    + MXBF
         LTIJ    = LSIJ    + MXMO*MXMO
         LFASQ   = LTIJ    + MXMO*MXMO
         LFBSQ   = LFASQ   + MXMO*MXMO
         LAST    = LFBSQ   + MXMO*MXMO
         NEED=LAST-LOADFM-1
         CALL GETFM(NEED)
C
         LENPV=MXBF*NTMO
         LENFM=MXMO2*NFRG
         CALL DAREAD(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
         CALL DAREAD(IDAF,IODA,XX(LFOCKMA),LENFM,268,0)
         CALL PAULIR(REPNRG,XX(LPROVEC),XX(LFOCKMA),XX(LSMAT),
     *               XX(LTMAT),XX(LWRK),XX(LSIJ),XX(LTIJ),
     *               XX(LFASQ),XX(LFBSQ),MXBF,MXMO,MXMO2)
         CALL RETFM(NEED)
      ELSE
         REPNRG = ZERO
      END IF
C
C --- CALCULATE POLARIZATION AND TOTAL INTERACTION ENERGIES ---
C
      CALL VALFM(LOADFM)
      LEFLD = LOADFM + 1
      LEFAD = LEFLD + 3*NPTTPT
      CALL EFPPOL(XX(LEFLD),XX(LEFAD),POLNRG)
      IF(IDPUNC.EQ.1) RETURN
C
      E = ESNRG + REPNRG + POLNRG
C
C --- PRINT OUT ENERGIES ---
C
      IF(IGOFLG.EQ.2) WRITE(IW,9010)
      IF ((RUNTYP .EQ. OPTIMIZ .AND. NSERCH .NE. 0) .OR.
     *   (RUNTYP .EQ. HSSIAN)) THEN
         IF(IGOFLG.EQ.2) THEN
            WRITE(IW,9095) ESNRG
            WRITE(IW,9105) REPNRG
            WRITE(IW,9115) POLNRG
            WRITE(IW,9130)
         END IF
         IF(IGOFLG.EQ.2) WRITE(IW,9125) E
         IGOFLG=1
      ELSE
         IF(IGOFLG.EQ.2) THEN
            WRITE(IW,9020) CCNRG
            WRITE(IW,9030) CDNRG
            WRITE(IW,9040) CQNRG
            WRITE(IW,9050) CONRG
            WRITE(IW,9060) DDNRG
            WRITE(IW,9070) DQNRG
            WRITE(IW,9080) QQNRG
            WRITE(IW,9090) ESNRG
            WRITE(IW,9100) REPNRG
            WRITE(IW,9110) POLNRG
         END IF
         IF(IGOFLG.EQ.2) WRITE(IW,9120) E
         IGOFLG=1
      END IF
C
      RETURN
C
C --- PRINT FORMAT STATEMENTS ---
C
 9010 FORMAT(/,17X,38('-')/
     *       17X,'FRAGMENT-FRAGMENT INTERACTION ENERGIES'/
     *       17X,38('-'))
 9020 FORMAT(/,17X,'CHARGE-CHARGE         = ',F14.12)
 9030 FORMAT(17X,'CHARGE-DIPOLE         = ',F14.12)
 9040 FORMAT(17X,'CHARGE-QUADRUPOLE     = ',F14.12)
 9050 FORMAT(17X,'CHARGE-OCTUPOLE       = ',F14.12)
 9060 FORMAT(17X,'DIPOLE-DIPOLE         = ',F14.12)
 9070 FORMAT(17X,'DIPOLE-QUADRUPOLE     = ',F14.12)
 9080 FORMAT(17X,'QUADRUPOLE-QUADRUPOLE = ',F14.12)
 9090 FORMAT(17X,38('-')/
     *       17X,'ELECTROSTATIC ENERGY  = ',F14.12)
 9095 FORMAT(17X,'ELECTROSTATIC ENERGY  = ',F14.12)
 9100 FORMAT(/17X,'REPULSION ENERGY      = ',F14.12)
 9105 FORMAT(17X,'REPULSION ENERGY      = ',F14.12)
 9110 FORMAT(/17X,'POLARIZATION ENERGY   = ',F14.12)
 9115 FORMAT(17X,'POLARIZATION ENERGY   = ',F14.12)
 9120 FORMAT(/19X,'FINAL EFP ENERGY    = ',F14.12)
 9125 FORMAT( 19X,'FINAL EFP ENERGY    = ',F14.12)
 9130 FORMAT(17X,38('-'))
C
      END
C*MODULE EFDRVR  *DECK EFPPOL
      SUBROUTINE EFPPOL(EFLD,EFADD,POLNRG)
C
C -----------------------------------------------------------------
C --- THIS SUBROUTINE CALCULATES FRAGMENT-FRAGMENT POLARIZATION ---
C ---      ENERGIES IN THE ABSENCE OF AN AB INITO MOLECULE      ---
C -----------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXPT=100, MXFRG=50, MXFGPT=MXPT*MXFRG)
      PARAMETER (ZERO=0.0D+00, DEBYE=2.541766D+00)
C
      CHARACTER*8 POLNAM
C
      LOGICAL MINMEM
C
      COMMON /CONV  / ACURCY,ENUCR,AJUNK(3),DIFF,ITER,ICALCP,ICBET
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),POLNAM(MXFGPT)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /FRFD  / PPEFX(MXFGPT), PPEFY(MXFGPT), PPEFZ(MXFGPT)
      COMMON /INDDIP/ TMUX,TMUY,TMUZ,TMUXD,TMUYD,TMUZD,MINMEM
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
C
      DIMENSION EFLD(3,NPTTPT),EFADD(3,NPTTPT)
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA ENERGY  /8HENERGY  /,GRADIENT/8HGRADIENT/
#else
      CHARACTER*8 :: ENERGY_STR
      EQUIVALENCE (ENERGY, ENERGY_STR)
      CHARACTER*8 :: GRADIENT_STR
      EQUIVALENCE (GRADIENT, GRADIENT_STR)
      DATA ENERGY_STR/"ENERGY  "/,GRADIENT_STR/"GRADIENT"/
#endif
C
C --- THIS SUBROUTINE MAKES USE OF "METHOD 2 " TO CALCULATE ITERATIVELY
C ---   THE INDUCED DIPOLES ON THE FRAGMENTS UNTIL SELF-CONSISTENCY IS
C --- REACHED, ADD RESULTING FIELD DURING SAME SCF ITERATION. ITERATION
C --- OF INDUCED DIPOLES ALSO COUPLED TO SCF. "EFADD" IS THE FIELD DUE
C --- TO INDUCED DIPOLES. "PFX", "PFY", AND "PFZ" ARE THE TOTAL FIELD,
C ---              INCLUDING FIELD DUE TO INDUCED DIPOLES.
C
      IFIRST = 0
C
      IF(ITER .EQ. IFIRST) THEN
         CALL VCLR(PPEFX,1,MXFGPT)
         CALL VCLR(PPEFY,1,MXFGPT)
         CALL VCLR(PPEFZ,1,MXFGPT)
         CALL FRGFLD(PPEFX,PPEFY,PPEFZ,NMTTPT)
         CALL VCLR(EFADD,1,3*NPTTPT)
      END IF
C
      TMUX = ZERO
      TMUY = ZERO
      TMUZ = ZERO
C
      INDEX = 1
      DO 10 IFRG=1,NFRG
        I1 = INDEX
        INDEX = INDEX + NPPTS(IFRG)
        I2 = I1 + NPPTS(IFRG) - 1
        DO 20 LEFP = I1,I2
C
C --- POLARIZABILITY TENSOR ALPHA FOR THE POINT ---
C
           BETAXX = EFPOL(1,LEFP)
           BETAYY = EFPOL(2,LEFP)
           BETAZZ = EFPOL(3,LEFP)
           BETAXY = EFPOL(4,LEFP)
           BETAXZ = EFPOL(5,LEFP)
           BETAYZ = EFPOL(6,LEFP)
           BETAYX = EFPOL(7,LEFP)
           BETAZX = EFPOL(8,LEFP)
           BETAZY = EFPOL(9,LEFP)
C
          PFXADD= PPEFX(LEFP) + EFADD(1,LEFP)
          PFYADD= PPEFY(LEFP) + EFADD(2,LEFP)
          PFZADD= PPEFZ(LEFP) + EFADD(3,LEFP)
C
          EFLD(1,LEFP) = PPEFX(LEFP)
          EFLD(2,LEFP) = PPEFY(LEFP)
          EFLD(3,LEFP) = PPEFZ(LEFP)
C
C --- INDUCED DIPOLES ---
C
          PMUX = (PFXADD*BETAXX + PFYADD*BETAXY + PFZADD*BETAXZ)
          PMUY = (PFYADD*BETAYY + PFXADD*BETAYX + PFZADD*BETAYZ)
          PMUZ = (PFZADD*BETAZZ + PFXADD*BETAZX + PFYADD*BETAZY)
          DIND(1,LEFP) = PMUX
          DIND(2,LEFP) = PMUY
          DIND(3,LEFP) = PMUZ
C          PMUX =(PFXADD*BETAXX + PFYADD*BETAYX + PFZADD*BETAZX)
C          PMUY =(PFYADD*BETAYY + PFXADD*BETAXY + PFZADD*BETAZY)
C          PMUZ =(PFZADD*BETAZZ + PFXADD*BETAXZ + PFYADD*BETAYZ)
C          DINDD(1,LEFP) = PMUX
C          DINDD(2,LEFP) = PMUY
C          DINDD(3,LEFP) = PMUZ
C
   20   CONTINUE
   10 CONTINUE
C
      CALL DIPIT(EFLD,EFADD,NPTTPT)
      IF(IDPUNC.EQ.1) RETURN
C
      DO 25 LEFP=1,NPTTPT
         PMUX = DIND(1,LEFP)
         PMUY = DIND(2,LEFP)
         PMUZ = DIND(3,LEFP)
C
      TMUX = TMUX + PMUX
      TMUY = TMUY + PMUY
      TMUZ = TMUZ + PMUZ
 25   CONTINUE
C
      TMUXD = TMUX*DEBYE
      TMUYD = TMUY*DEBYE
      TMUZD = TMUZ*DEBYE
C
C --- CALCULATE POLARIZATION ENERGY ---
C
      POLNRG = ZERO
      POLEX = ZERO
      POLEY = ZERO
      POLEZ = ZERO
      DO 1000 II=1,NPTTPT
         POLEX = POLEX + DIND(1,II)*PPEFX(II)
         POLEY = POLEY + DIND(2,II)*PPEFY(II)
         POLEZ = POLEZ + DIND(3,II)*PPEFZ(II)
 1000 CONTINUE
      POLNRG = -0.5D+00*(POLEX + POLEY + POLEZ)
C
C --- PRINT OUT INDUCED DIPOLE ---
C
      IF ((RUNTYP .EQ. ENERGY) .OR. (RUNTYP .EQ. GRADIENT))
     *   WRITE(IW,9000) TMUX, TMUXD, TMUY, TMUYD, TMUZ, TMUZD
C
      RETURN
C
 9000 FORMAT(/,17X,'INDUCED DIPOLE',4X,'ATOMIC UNITS',3X,'DEBYE'/
     *       17X,14('-'),4X,12('-'),3X,5('-')/
     *       21X,'X(IND)',9X,F8.5,3X,F8.5/
     *       21X,'Y(IND)',9X,F8.5,3X,F8.5/
     *       21X,'Z(IND)',9X,F8.5,3X,F8.5)
C
      END
C*MODULE EFDRVR  *DECK EFGRAD
      SUBROUTINE EFGRAD
C
C ---------------------------------------------------------------
C --- THIS SUBROUTINE CALCULATES THE GRADIENT ASSOCIATED WITH ---
C --- A FRAGMENT ONLY RUN, I.E., FRAGMENTS IN THE ABSENCE OF  ---
C ---                  AN AB INITIO MOLECULE                  ---
C ---------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=500, MXPT=100, MXFRG=50, MXFGPT=MXPT*MXFRG)
      PARAMETER (MXPSH=5*MXPT, MXPG=5*MXPSH)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /FMCOM / X(1)
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG
      COMMON /INFOA / NAT,ICH,MUL,NUM,NX,NE,NA,NB,ZAN(MXATM),C(3,MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULIN/ EX(MXPG,MXFRG),CS(MXPG,MXFRG),CP(MXPG,MXFRG),
     *                CD(MXPG,MXFRG),CF(MXPG,MXFRG),CG(MXPG,MXFRG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXPSH,MXFRG),KATOM(MXPSH,MXFRG),
     *                KTYPE(MXPSH,MXFRG),KNG(MXPSH,MXFRG),
     *                KLOC(MXPSH,MXFRG), KMIN(MXPSH,MXFRG),
     *                KMAX(MXPSH,MXFRG),NSHELL(MXFRG),NGAUSS(MXFRG),
     *                NATEF(MXFRG),NUMEF(MXFRG),NTPATM
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      IF(NGLEVL.NE.0) THEN
         IF(MASWRK) WRITE(IW,*) 'NO NUMERICAL GRADIENT WITH FRAGMENTS'
         CALL ABRT
      END IF
C
      NFRPTS = NMTTPT + NPTTPT + NRTTPT + NTPATM + NTMO
C
      CALL VALFM(LOADFM)
      LDRG = LOADFM + 1
      LEF3 = LDRG   + 1
      LWORK= LEF3   + 3*NFRPTS
      LAST = LWORK  + 10*NMTTPT
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      CALL VCLR(DEF,1,3*MXFGPT)
      CALL VCLR(ATORQ,1,3*NFRG)
      CALL VNNDER(X(LDRG),NAT,X(LEF3),NFRPTS,DUMMY,1,X(LWORK))
      CALL EFFT
C
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE EFDRVR  *DECK MDX
      SUBROUTINE MDX
      WRITE(6,*) 'MDX CALLED BY MISTAKE'
      CALL ABRT
      STOP
      END
C*MODULE EFDRVR  *DECK POTGRAD
      SUBROUTINE POTGRAD
      WRITE(6,*) 'POTGRAD CALLED BY MISTAKE'
      CALL ABRT
      STOP
      END
C*MODULE EFDRVR  *DECK POTNRG
      SUBROUTINE POTNRG(METHOD)
      IF(METHOD.LT.0) RETURN
      WRITE(6,*) 'POTNRG CALLED BY MISTAKE'
      CALL ABRT
      STOP
      END
C*MODULE EFDRVR  *DECK POTMAX
      SUBROUTINE POTMAX(NFRG,DEFT,TORQ,MAXGRD,RMSGRD)
      DOUBLE PRECISION DEFT(3,*),TORQ(3,*),MAXGRD,RMSGRD
      IF(NFRG.LE.0) RETURN
C
      DEFT(1,1) = 0.0D+00
      TORQ(1,1) = 0.0D+00
      MAXGRD = 0.0D+00
      RMSGRD = 0.0D+00
      WRITE(6,*) 'POTMAX CALLED BY MISTAKE'
      CALL ABRT
      STOP
      END

C  9 DEC 03 - OQ  - CPRHF: SAVE INFORMATION FOR EXTENDED TDHF PACKAGE
C  3 SEP 03 - SPW - AOFLM2: ADD CIS ARGUMENT TO TWOEI CALL
C 12 DEC 02 - MWS - AOFLM2: INT. ACCURACY ADJUSTMENT IF DIRECT JOB
C 22 MAY 02 - KRG - CPDIIS,CDIISU: TRUNCATE DIIS SPACE IF SINGULARITIES
C 24 JAN 02 - CMA - CDIISU: NEW FOR UMP2 CPHF, SOLVCP: MOD. ITER SCHEME
C  6 SEP 01 - MWS - ADD DUMMY ARGUMENTS TO NAMEIO CALL
C 25 JUN 01 - MWS - ALTER COMMON BLOCK WFNOPT
C 20 FEB 01 - MWS - AO CPHF BY PRECONDITIONED CONJUGATE GRADIENT
C 29 DEC 00 - MWS - STRAIGHTFORWARD PARALLELIZATION OF AO BASIS CPHF
C 26 OCT 00 - MWS - INTRODUCE MXAO PARAMETER
C 11 JUN 00 - MWS - CPRHF: ALWAYS ALLOCATE A HONDO INTEGRAL BUFFER
C  1 MAY 00 - MWS - CPWXYO: FIX SPHERICAL HARMONICS PROBLEM
C 21 DEC 99 - MWS - MAKE GUGWFN COMMON CONSISTENT
C 13 FEB 99 - MAF - CILAI: CORRECT DGEMM CALLS IF SPHERICAL HARMONICS
C  1 DEC 98 - MWS - CHANGES TO DEBUGGING OUTPUT
C 12 NOV 98 - GDF - CHANGE BIT PACKING TO ISHIFT
C 26 OCT 98 - MAF - CPRHF: ALLOW FOR USE OF SPHERICAL HARMONICS
C  6 JAN 98 - MWS - CHANGE CALL TO RACLOS
C 28 SEP 97 - MWS - CONVERT PARALLEL CALLS FROM TCGMSG TO DDI
C  2 SEP 97 - MWS - CPRHF: WATCH OUT FOR IN MEMORY OVERFLOW IF 32 BITS
C 24 MAR 97 - MWS - CPDIIS: REDUCE I/O, INCREASE AO CPHF ITERATION LIMIT
C 17 JAN 97 - SPW - ZDENCI: FIX CORE/VALENCE SEMICORE ECP CONTRIBUTION
C 18 DEC 96 - TLW - CPFCK,CPHFX,CPINP,CPRHF: MODIFIED FOR AO BASIS CPHF,
C                   ADD AOCPCL,AOFLM2,AOHST2 ROUTINES, MOVE CPDIIS HERE
C 26 NOV 96 - SPW - CPFA,CPFCK,CPRHF,CPTA,XDELTA,ZDENCI,ZGRDCI: CHANGES
C                   FOR FROZEN CORE CI GRADIENT, ADDED CILAI
C 17 OCT 96 - SPW,MWS - ADD RESPONSE CODE FOR RHF+CI GRADIENT,
C                   INCLUDING NEW XDELTA,ZDENCI,ZGRDCI ROUTINES
C 13 JUN 96 - MWS - SPARAX,SPARXA: REMOVE SOME FTNCHECK WARNINGS.
C  5 MAR 96 - MWS - CHANGE SHELL SYMMETRY PACKING COMMONS
C 16 FEB 96 - MWS - IMPROVEMENTS TO IN- AND OUT-OF-CORE SOLVER
C 21 APR 95 - SPW - CPHFX,CPFCK,CPRHF,CPWAB3: POLARIZABILITY, ADD CPINP
C 27 MAR 95 - SPW - CPRHF,CPTA,CPWAB3: IR INTENSITY, ADDED CPSDDM
C 30 DEC 94 - MWS - CPWXYO: ONLY MASTER NODE SHOULD SKIP 1E- INTS
C 15 DEC 94 - MWS - USE GSUMCP TO AVOID LARGE GLOBAL ORB. HESS. SUMS
C 11 NOV 94 - MWS - REMOVE FTNCHEK WARNINGS
C 10 AUG 94 - MWS - INCREASE NUMBER OF DAF RECORDS
C  5 AUG 94 - MWS - CPRHF,CPFCK,CPWXYI,CPWXYO: USE DOUBLE LABEL PACKING
C  1 JUN 94 - MWS - IMPLEMENT PARALLEL FORMATION OF CPHF EQUATIONS
C 28 FEB 94 - MD  - CPFCK: RESHAPE FMO ARRAY
C 27 JAN 94 - MWS - SOLVCG: IMPROVE FAILURE TO CONVERGE MESSAGE
C  2 NOV 93 - HS  - CPRHF: FIX MEMORY GLITCH
C  5 AUG 93 - MWS - CPRHF: PRINT CORRECT OUT OF MEMORY NEED
C 12 MAR 92 - MWS - REDIMENSION TO 500 ATOMS
C  1 FEB 92 - MWS - MODIFY EXTERNAL CPHF SOLVER TO MINIMIZE I/O
C 11 JAN 92 - TLW - CPWXYI: MAKE READ PARALLEL
C 10 JAN 92 - MWS,TLW - CHANGE OPENCI TO SEQOPN, REWIND WITH SEQREW
C  4 JAN 92 - TLW - MAKE WRITES PARALLEL;ADD COMMON PAR
C  7 OCT 91 - MWS - CHANGE UNIX BYTE UNPACKING
C 14 AUG 91 - TLW - CPSYM: ADD FTR AND GTR TO COMMON SYMSPD
C  3 NOV 90 - MWS - SKIP CPHF OVER DUMMY ATOMS
C  7 OCT 90 - MWS - IMPLEMENT OUT OF MEMORY OPTION FOR RHF CPHF
C  7 AUG 90 - TLW - ADD CF AND CG TO COMMON NSHEL
C 22 JUN 90 - MWS - ALLOW OS-TCSCF TO CALL CPROHF CODE
C  3 JUN 90 - JAM - CHANGE VAX BYTE PACKING TO FULL 8 BITS
C  8 MAY 90 - MWS - FLUSH PRINT BUFFER WHEN CPHF EQNS ARE SET UP.
C 27 NOV 89 - MWS - REMOVE STUB ROUTINE, RENAME SOLVER CODE, ALPHABETIZE
C 20 JUN 89 - MWS - ADD DUMMY STUB ROUTINE FOR CP-ROHF PROBLEM
C  1 JUN 89 - MWS - MAKE SEPARATE CPRHF ROUTINE, CPHFX IS BOSS.
C  4 APR 89 - MWS - USE LETTERS IN MEMORY POINTERS
C 13 MAR 89 - MWS - CPFA: TRANSFORM TO MO BASIS IS NOW DONE BY JDDEND
C 25 FEB 89 - STE - CPFCM: DELETE 9996
C 24 JAN 89 - MWS - PRINT OUT MEMORY NEEDS FOR EACH CPHF STEP
C 18 JAN 89 - MWS - ADAPT ANALYTIC RHF HESSIAN CODE FROM MICHEL'S HONDO7
C*MODULE CPHF    *DECK CILAI
      SUBROUTINE CILAI(ZKL,PMN,X,Y,XLMN,BUF,IBUF,XLAI1,
     *                 NOCACT,NFZC,NOC,NVIR,NUM,NUM2,NUM3,C)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL PACK2E
C
      DIMENSION ZKL(NOCACT,NFZC),PMN(NUM2),XLMN(NUM2),
     *          X(NUM,NUM),Y(NUM,NUM),BUF(NINTMX),IBUF(NINTMX),
     *          XLAI1(NOC,NVIR),C(NUM,NUM)
C
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTG76
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(400)
C
      PARAMETER (ONE=1.0D+00, TWO=2.0D+00)
C
C     ----- COMPLETE CONSTRUCTION OF THE CI LAGRANGIAN -----
C
C        BEGIN TRANSFORMING CORE-VALENCE -ZKL- TO AO BASIS AS -PMN-
C
      CALL TRPOSE(XLAI1,X,NOC,NVIR,1)
C
      CALL VCLR(X,1,NUM3)
      CALL VCLR(Y,1,NUM3)
C
C     ---- GET ORBITAL COEFFICIENTS ----
C
      CALL DAREAD(IDAF,IODA,C,NUM3,15,0)
C
C     ---- TRNSFORM FROZEN CORE - VALENCE DENSITY -ZKL- TO AO BASIS ----
C
      CALL MRARTR(ZKL,NOCACT,NOCACT,NFZC,C,NUM,NUM,X,NUM)
      CALL DGEMM('N','N',NUM,NUM,NOCACT,TWO,C(1,NFZC+1),
     *            NUM,X,NUM,ONE,Y,NUM)
C
      MUNU = 0
      DO 110 MU=1,NUM
         DO 100 NU=1,MU
            MUNU=MUNU+1
            PMN(MUNU) = Y(MU,NU) + Y(NU,MU)
  100    CONTINUE
  110 CONTINUE
C
C           CONSTRUCT FOCK-LIKE MATRIX
C           DIRECT METHOD = RECOMPUTE 2E- AO INTEGRALS
C           STANDARD METHOD = PROCESS INTEGRALS FROM DISK
C
      CALL FLMAT(PMN,Y,XLMN,BUF,IBUF,NUM)
C
C     ---- TRANSFORM THIS TERM TO MO BASIS, AND ADD
C          TO OCCUPIED-VIRTUAL CI LAGRANGIAN ASYMMETRY ----
C
      CALL MRARBR(Y,NUM,NUM,NUM,C,NUM,NOC,X,NUM)
      CALL DGEMM('T','N',NVIR,NOC,NUM,ONE,C(1,NOC+1),NUM,X,NUM,
     *           ONE,XLAI1,NVIR)
C
      CALL TRPOSE(XLAI1,X,NVIR,NOC,1)
C
      RETURN
      END
C*MODULE CPHF    *DECK CPDIIS
      SUBROUTINE CPDIIS(IW,ITDIIS,PAI,ERR,WRK,A,X,IPVT,B,IODIIS,
     *                  NOCP,MAXIT,MAXIT2,MAXIO,ERDIIS,NOTOPN,
     *                  NROT,NOC,NVIR,NXYZ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL NOTOPN,DBG,GOPARR,DSKWRK,MASWRK,GPSAVE,DSKSAV
C
      DIMENSION PAI(NROT*NXYZ),ERR(NROT*NXYZ),WRK(NROT*NXYZ),
     *          NOCP(NXYZ),IODIIS(MAXIO),A(MAXDII,MAXDII),X(MAXIT,NXYZ),
     *          IPVT(MAXIT),B(MAXIT2,NXYZ)
C
      COMMON /DIISSO/ SOGTOL,ETHRSH,MAXDII,IRAF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA DBUG,DBUGME/8HDEBUG   ,8HCPDIIS  /
#else
      CHARACTER*8 :: DBUG_STR, DBUGME_STR
      EQUIVALENCE (DBUGME, DBUGME_STR), (DBUG, DBUG_STR)
      DATA DBUG_STR,DBUGME_STR/"DEBUG   ","CPDIIS  "/
#endif
C
C                 THIS ROUTINE PERFORMS THE
C        *** DIRECT INVERSION IN THE ITERATIVE SUBSPACE ***
C        INTERPOLATION USING THE CURRENT AND PREVIOUS CPHF
C        SOLUTIONS TO SPEED UP THE CONVERGENCE OF THE SELF
C        CONSISTENT SOLUTION.
C        IT IS A MODIFIED VERSION OF THE SUBROUTINE DIIS.
C
C        THE METHOD IS P.PULAY, J.COMPUT.CHEM., 3, 556-560 (1982).
C        BUT SEE ALSO P.PULAY, CHEM.PHYS.LETT., 73, 393-398 (1980),
C        T.P.HAMILTON, P.PULAY, J.CHEM.PHYS., 84, 5728-5734 (1986).
C
C     ON ENTRY, -PAI- AND AND -ERR- ARE THE CURRENT CPHF
C               AND ERROR MATRICES, EXPRESSED IN THE MO BASIS.
C     ON EXIT, -ERR- IS DESTROYED, -PAI-  WILL CONTAIN
C               THE INTERPOLATED CPHF SOLUTION (IF ITDIIS.GT.2)
C
C     ITDIIS.EQ.1 MEANS DIIS IS NOT YET TURNED ON
C     ITDIIS.EQ.2 MEANS DIIS HAS BEEN INITIATED
C     ITDIIS.GT.2 MEANS A DIIS INTERPOLATION OF ITDIIS-1
C                 FOCK MATRICES HAS BEEN PERFORMED.
C
      DBG = (NPRINT.EQ.5  .OR.  EXETYP.EQ.DBUG  .OR.  EXETYP.EQ.DBUGME)
     *      .AND. MASWRK
C
C     DIIS DATA IS SAVED ON DIRECT FILE -IRAF- IN CYCLIC ORDER,
C                 1,2,3,...,MAXDII = LAST MAXDII ERROR MATRICES
C        MAXDII + 1,2,3,...,MAXDII = LAST MAXDII CPHF SOLUTIONS
C
      LRAFE = 0
      LRAFPAI= MAXDII
      DSKSAV = DSKWRK
      DSKWRK = .FALSE.
C
      IF(NOTOPN) THEN
         NOTOPN = .FALSE.
         IRAF   = 20
         NDAF20 = MAXIO
         LEN20  = NROT*NXYZ
         CALL RAOPEN(IRAF,IODIIS,0,NDAF20,LEN20,-5)
      END IF
C
C     ----- SAVE THE CURRENT CPHF SOLUTION -----
C
      LPAI = LRAFPAI + MOD(ITDIIS-1,MAXDII) + 1
      CALL RAWRIT(IRAF,IODIIS,PAI,NROT*NXYZ,LPAI,0)
C
C     ----- SAVE THE CURRENT ERROR MATRIX -----
C
      LERR = LRAFE + MOD(ITDIIS-1,MAXDII) + 1
      CALL RAWRIT(IRAF,IODIIS,ERR,NROT*NXYZ,LERR,0)
C
C     ----- START DIIS PROCEDURE IF ERDIIS < ETHRSH -----
C
      ETHRSH = 5.0D-02
      IF(NXYZ.GT.1) ETHRSH = 3.0D-01
      LOC=0
      ERDIIS=ZERO
      DO 110 IXYZ=1,NXYZ
         IF(NOCP(IXYZ).EQ.0) THEN
            IMAX = IDAMAX(NROT,ERR(LOC+1),1)
            EMAX = ABS(ERR(LOC+IMAX))
            IF(EMAX.GT.ERDIIS) ERDIIS=EMAX
         END IF
         LOC = LOC+NROT
  110 CONTINUE
      IF(ERDIIS.GT.ETHRSH  .AND.  ITDIIS.EQ.1) THEN
         DSKWRK = DSKSAV
         RETURN
      END IF
      ITDIIS = ITDIIS+1
      IF (MASWRK  .AND.  ITDIIS.EQ.2) WRITE(IW,900)
C
C        WHEN RUNNING IN PARALLEL, THE O(N**2) COMMUNICATIONS
C        COSTS IN -RAREAD- BELOW ARE THE SAME MAGNITUDE AS
C        THE COMPUTATION IN -TRAREC- AND -DAXPY-.
C        IT SEEMS WISEST JUST TO LET THE MASTER DO THIS I/O,
C        THEN BROADCAST THE INTERPOLATION RESULTS AT THE END.
C
      GPSAVE = GOPARR
      GOPARR = .FALSE.
C
C         LOOP OVER THE -NXYZ- RESPONSES
C
      DO 200 IXYZ = 1, NXYZ
         IF (NOCP(IXYZ).NE.0) GO TO 200
         ITEMP = (IXYZ-1)*NROT
C
C         FORM LAST ROW (ROW ITDIIS) OF TRIANGULAR MATRIX B,
C         FIRST DOING THE DIAGONAL AND THE FIRST ELEMENT OF THE ROW.
C
         BJJ=DDOT(NROT,ERR(ITEMP+1),1,ERR(ITEMP+1),1)
C
         IF(ITDIIS.EQ.2) THEN
            CALL VCLR(B(1,IXYZ),1,MAXIT2)
            B(1,IXYZ)=ZERO
            B(2,IXYZ)=-ONE
            B(3,IXYZ)=BJJ
            IF (IXYZ.EQ.NXYZ) THEN
              GOPARR = GPSAVE
              DSKWRK = DSKSAV
              RETURN
            ELSE
              GO TO 200
            END IF
         ELSE
            J1   = (ITDIIS*ITDIIS-ITDIIS)/2 + 1
            JJ   = (ITDIIS*ITDIIS+ITDIIS)/2
            B(J1,IXYZ)= -ONE
            B(JJ,IXYZ)= BJJ
         END IF
  200 CONTINUE
C
C        THE REST OF THE BIJ'S.
C        NOTE THAT WE ONLY COMPUTE THE NA-2 VALUES NEXT TO THE
C        DIAGONAL, SO THAT THE OTHER ELEMENTS (EXCEPT THE FIRST
C        COLUMN) ARE RANDOM VALUES.
C
      NA=MIN(ITDIIS,MAXDII)
      NAM1=NA-1
      IJ=JJ-NA+1
      DO 320 IX=2,NAM1
         IJ=IJ+1
         LERR = LRAFE + MOD(ITDIIS-NA+IX-2,MAXDII) + 1
         CALL RAREAD(IRAF,IODIIS,WRK,NROT*NXYZ,LERR,0)
         DO 310 IXYZ = 1, NXYZ
            IF (NOCP(IXYZ).NE.0) GO TO 310
            ITEMP = (IXYZ-1)*NROT
            BIJ=DDOT(NROT,ERR(ITEMP+1),1,WRK(ITEMP+1),1)
            B(IJ,IXYZ)=BIJ
  310    CONTINUE
  320 CONTINUE
C
      DO 330 IXYZ=1,NXYZ
         IF(NOCP(IXYZ).NE.0) GO TO 330
         IF(DBG) THEN
            WRITE(IW,*) 'DIIS EQUATIONS - ROTATION',IXYZ
            CALL PRTRI(B(1,IXYZ),ITDIIS)
         END IF
C
C     ----- SET UP AND SOLVE THE SET OF DIIS LINEAR EQUATIONS -----
C
  325    CONTINUE
         CALL DIISEQ(A,NA,B(1,IXYZ),JJ,ITDIIS)
         CALL VCLR(X(1,IXYZ),1,NA)
         X(1,IXYZ)=-ONE
         IERR=0
         CALL SLVLEQ(A,X(1,IXYZ),IPVT,NA,NA,0,IERR)
         IF(IERR.NE.0) THEN
           NA = NA - 1
           IF (MASWRK) WRITE(IW,*)
     *         'TRUNCATING RHF MP2 RESPONSE VECTOR DIIS EQUATIONS'
           IF (NA .NE. 1) GO TO 325
           IF (MASWRK) WRITE(IW,*)
     *         'ERROR: RESPONSE VECTOR DIIS EQUATIONS ARE SINGULAR'
           CALL ABRT
           STOP
         END IF
         IF(DBG) THEN
            WRITE(IW,*) 'DIIS INTERPOLATION COEFFICIENTS'
            WRITE(IW,910) (X(I,IXYZ),I=1,NA)
         END IF
  330 CONTINUE
C
C     ----- FORM THE INTERPOLATED CPHF SOLUTION -----
C     THE INTERPOLATION IS SUMMATION C(I)*PAI(I)
C
      CALL VCLR(PAI,1,NROT*NXYZ)
      DO 420 IX=2,NA
         LPAI = LRAFPAI  + MOD(ITDIIS-NA+IX-2,MAXDII) + 1
         CALL RAREAD(IRAF,IODIIS,WRK,NROT*NXYZ,LPAI,0)
         DO 410 IXYZ = 1, NXYZ
            IF (NOCP(IXYZ).NE.0) GO TO 410
            ITEMP = (IXYZ-1)*NROT
            CI = X(IX,IXYZ)
            CALL DAXPY(NROT,CI,WRK(ITEMP+1),1,PAI(ITEMP+1),1)
  410    CONTINUE
  420 CONTINUE
C
      IF(DBG) THEN
         DO 430 IXYZ = 1, NXYZ
            IF (NOCP(IXYZ).NE.0) GO TO 430
            ITEMP = (IXYZ-1)*NROT
            WRITE(IW,*) 'DIIS INTERPOLATED CPHF SOLUTION IS'
            CALL PRSQ(PAI(ITEMP+1),NOC,NVIR,NVIR)
  430    CONTINUE
      END IF
C
      GOPARR=GPSAVE
      DSKWRK = DSKSAV
      IF(GOPARR) THEN
         CALL DDI_BCAST(1005,'F',PAI,NXYZ*NROT,MASTER)
      END IF
      RETURN
C
  900 FORMAT(' ..... INITIATING DIIS PROCEDURE .....')
  910 FORMAT(1X,5F13.8)
      END
C*MODULE CPHF    *DECK CDIISU
      SUBROUTINE CDIISU(IW,ITDIIS,PAI1,PAI2,ERR,WRK,A,X,IPVT,B,IODIIS,
     *                  NOCP,MAXIT,MAXIT2,MAXIO,ERDIIS,NOTOPN,
     *                  NBF,NBF3,NXYZ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL NOTOPN,DBG,GOPARR,DSKWRK,MASWRK,GPSAVE,DSKSAV
C
      DIMENSION PAI1(NBF3*NXYZ),ERR(NBF3*NXYZ),WRK(NBF3*NXYZ),
     *          PAI2(NBF3*NXYZ),
     *          NOCP(NXYZ),IODIIS(MAXIO),A(MAXIT,MAXIT),X(MAXIT,NXYZ),
     *          IPVT(MAXIT),B(MAXIT2,NXYZ)
C
      COMMON /DIISSO/ SOGTOL,ETHRSH,MAXDII,IRAF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA DBUG,DBUGME/8HDEBUG   ,8HCDIISU  /
#else
      CHARACTER*8 :: DBUG_STR, DBUGME_STR
      EQUIVALENCE (DBUGME, DBUGME_STR), (DBUG, DBUG_STR)
      DATA DBUG_STR,DBUGME_STR/"DEBUG   ","CDIISU  "/
#endif
C
C                 THIS ROUTINE PERFORMS THE
C        *** DIRECT INVERSION IN THE ITERATIVE SUBSPACE ***
C        INTERPOLATION USING THE CURRENT AND PREVIOUS CPHF
C        SOLUTIONS TO SPEED UP THE CONVERGENCE OF THE SELF
C        CONSISTENT SOLUTION.
C        IT IS A MODIFIED VERSION OF THE SUBROUTINE DIIS.
C
C        THE METHOD IS P.PULAY, J.COMPUT.CHEM., 3, 556-560 (1982).
C        BUT SEE ALSO P.PULAY, CHEM.PHYS.LETT., 73, 393-398 (1980),
C        T.P.HAMILTON, P.PULAY, J.CHEM.PHYS., 84, 5728-5734 (1986).
C
C     ON ENTRY, -PAI- AND AND -ERR- ARE THE CURRENT CPHF
C               AND ERROR MATRICES, EXPRESSED IN THE MO BASIS.
C     ON EXIT, -ERR- IS DESTROYED, -PAI-  WILL CONTAIN
C               THE INTERPOLATED CPHF SOLUTION (IF ITDIIS.GT.2)
C
C     ITDIIS.EQ.1 MEANS DIIS IS NOT YET TURNED ON
C     ITDIIS.EQ.2 MEANS DIIS HAS BEEN INITIATED
C     ITDIIS.GT.2 MEANS A DIIS INTERPOLATION OF ITDIIS-1
C                 FOCK MATRICES HAS BEEN PERFORMED.
C
      DBG = (NPRINT.EQ.5  .OR.  EXETYP.EQ.DBUG  .OR.  EXETYP.EQ.DBUGME)
     *      .AND. MASWRK
C
C     DIIS DATA IS SAVED ON DIRECT FILE -IRAF- IN CYCLIC ORDER,
C                 1,2,3,...,MAXDII = LAST MAXDII ERROR MATRICES
C        MAXDII + 1,2,3,...,MAXDII = LAST MAXDII CPHFA SOLUTIONS
C      2*MAXDII + 1,2,3,...,MAXDII = LAST MAXDII CPHFB SOLUTIONS
C
      LRAFE = 0
      LRAFPAI1= MAXDII
      LRAFPAI2= 2*MAXDII
      DSKSAV = DSKWRK
      DSKWRK = .FALSE.
C
      IF(NOTOPN) THEN
         NOTOPN = .FALSE.
         IRAF   = 20
         NDAF20 = MAXIO
         LEN20  = NBF3*NXYZ
         CALL RAOPEN(IRAF,IODIIS,0,NDAF20,LEN20,-5)
      END IF
C
C     ----- SAVE THE CURRENT CPHF SOLUTIONS -----
C
      LPAI1 = LRAFPAI1 + MOD(ITDIIS-1,MAXDII) + 1
      CALL RAWRIT(IRAF,IODIIS,PAI1,NBF3*NXYZ,LPAI1,0)
      LPAI2 = LRAFPAI2 + MOD(ITDIIS-1,MAXDII) + 1
      CALL RAWRIT(IRAF,IODIIS,PAI2,NBF3*NXYZ,LPAI2,0)
C
C     ----- SAVE THE CURRENT ERROR MATRIX -----
C
      LERR = LRAFE + MOD(ITDIIS-1,MAXDII) + 1
      CALL RAWRIT(IRAF,IODIIS,ERR,NBF3*NXYZ,LERR,0)
C
C     ----- START DIIS PROCEDURE IF ERDIIS < ETHRSH -----
C
      ETHRSH = 5.0D-02
      IF(NXYZ.GT.1) ETHRSH = 3.0D-01
      LOC=0
      ERDIIS=ZERO
      DO 110 IXYZ=1,NXYZ
         IF(NOCP(IXYZ).EQ.0) THEN
            IMAX = IDAMAX(NBF3,ERR(LOC+1),1)
            EMAX = ABS(ERR(LOC+IMAX))
            IF(EMAX.GT.ERDIIS) ERDIIS=EMAX
         END IF
         LOC = LOC+NBF3
  110 CONTINUE
      IF(ERDIIS.GT.ETHRSH  .AND.  ITDIIS.EQ.1) THEN
         DSKWRK = DSKSAV
         RETURN
      END IF
      ITDIIS = ITDIIS+1
C
      IF (MASWRK  .AND.  ITDIIS.EQ.2) WRITE(IW,900)
C
C        WHEN RUNNING IN PARALLEL, THE O(N**2) COMMUNICATIONS
C        COSTS IN -RAREAD- BELOW ARE THE SAME MAGNITUDE AS
C        THE COMPUTATION IN -TRAREC- AND -DAXPY-.
C        IT SEEMS WISEST JUST TO LET THE MASTER DO THIS I/O,
C        THEN BROADCAST THE INTERPOLATION RESULTS AT THE END.
C
      GPSAVE = GOPARR
      GOPARR = .FALSE.
C
C         LOOP OVER THE -NXYZ- RESPONSES
C
      DO 200 IXYZ = 1, NXYZ
         IF (NOCP(IXYZ).NE.0) GO TO 200
         ITEMP = (IXYZ-1)*NBF3
C
C         FORM LAST ROW (ROW ITDIIS) OF TRIANGULAR MATRIX B,
C         FIRST DOING THE DIAGONAL AND THE FIRST ELEMENT OF THE ROW.
C
         BJJ=DDOT(NBF3,ERR(ITEMP+1),1,ERR(ITEMP+1),1)
C
         IF(ITDIIS.EQ.2) THEN
            CALL VCLR(B(1,IXYZ),1,MAXIT2)
            B(1,IXYZ)=ZERO
            B(2,IXYZ)=-ONE
            B(3,IXYZ)=BJJ
            IF (IXYZ.EQ.NXYZ) THEN
              GOPARR = GPSAVE
              DSKWRK = DSKSAV
              RETURN
            ELSE
              GO TO 200
            END IF
         ELSE
            J1   = (ITDIIS*ITDIIS-ITDIIS)/2 + 1
            JJ   = (ITDIIS*ITDIIS+ITDIIS)/2
            B(J1,IXYZ)= -ONE
            B(JJ,IXYZ)= BJJ
         END IF
  200 CONTINUE
C
C        THE REST OF THE BIJ'S.
C        NOTE THAT WE ONLY COMPUTE THE NA-2 VALUES NEXT TO THE
C        DIAGONAL, SO THAT THE OTHER ELEMENTS (EXCEPT THE FIRST
C        COLUMN) ARE RANDOM VALUES.
C
      NA=MIN(ITDIIS,MAXDII)
      NAM1=NA-1
      IJ=JJ-NA+1
      DO 320 IX=2,NAM1
         IJ=IJ+1
         LERR = LRAFE + MOD(ITDIIS-NA+IX-2,MAXDII) + 1
         CALL RAREAD(IRAF,IODIIS,WRK,NBF3*NXYZ,LERR,0)
         DO 310 IXYZ = 1, NXYZ
            IF (NOCP(IXYZ).NE.0) GO TO 310
            ITEMP = (IXYZ-1)*NBF3
            BIJ=DDOT(NBF3,ERR(ITEMP+1),1,WRK(ITEMP+1),1)
            B(IJ,IXYZ)=BIJ
  310    CONTINUE
  320 CONTINUE
C
      DO 330 IXYZ=1,NXYZ
         IF(NOCP(IXYZ).NE.0) GO TO 330
         IF(DBG) THEN
            WRITE(IW,*) 'DIIS EQUATIONS - ROTATION',IXYZ
            CALL PRTRI(B(1,IXYZ),ITDIIS)
         END IF
C
C     ----- SET UP AND SOLVE THE SET OF DIIS LINEAR EQUATIONS -----
C
  325    CONTINUE
         CALL DIISEQ(A,NA,B(1,IXYZ),JJ,ITDIIS)
         CALL VCLR(X(1,IXYZ),1,NA)
         X(1,IXYZ)=-ONE
         IERR=0
         CALL SLVLEQ(A,X(1,IXYZ),IPVT,NA,NA,0,IERR)
         IF(IERR.NE.0) THEN
           NA = NA - 1
           IF (MASWRK) WRITE(IW,*)
     *         'TRUNCATING UHF MP2 RESPONSE VECTOR DIIS EQUATIONS'
           IF (NA .NE. 1) GO TO 325
           IF (MASWRK) WRITE(IW,*)
     *         'ERROR: RESPONSE VECTOR DIIS EQUATIONS ARE SINGULAR'
           CALL ABRT
           STOP
         END IF
         IF(DBG) THEN
            WRITE(IW,*) 'DIIS INTERPOLATION COEFFICIENTS'
            WRITE(IW,910) (X(I,IXYZ),I=1,NA)
         END IF
  330 CONTINUE
C
C     ----- FORM THE INTERPOLATED CPHF SOLUTION -----
C     THE INTERPOLATION IS SUMMATION C(I)*PAI(I)
C
      CALL VCLR(PAI1,1,NBF3*NXYZ)
      DO 420 IX=2,NA
         LPAI1 = LRAFPAI1 + MOD(ITDIIS-NA+IX-2,MAXDII) + 1
         CALL RAREAD(IRAF,IODIIS,WRK,NBF3*NXYZ,LPAI1,0)
         DO 410 IXYZ = 1, NXYZ
            IF (NOCP(IXYZ).NE.0) GO TO 410
            ITEMP = (IXYZ-1)*NBF3
            CI = X(IX,IXYZ)
            CALL DAXPY(NBF3,CI,WRK(ITEMP+1),1,PAI1(ITEMP+1),1)
  410    CONTINUE
  420 CONTINUE
C
      CALL VCLR(PAI2,1,NBF3*NXYZ)
      DO 426 IX=2,NA
         LPAI2 = LRAFPAI2 + MOD(ITDIIS-NA+IX-2,MAXDII) + 1
         CALL RAREAD(IRAF,IODIIS,WRK,NBF3*NXYZ,LPAI2,0)
         DO 424 IXYZ = 1, NXYZ
            IF (NOCP(IXYZ).NE.0) GO TO 426
            ITEMP = (IXYZ-1)*NBF3
            CI = X(IX,IXYZ)
            CALL DAXPY(NBF3,CI,WRK(ITEMP+1),1,PAI2(ITEMP+1),1)
  424    CONTINUE
  426 CONTINUE
C
      IF(DBG) THEN
         DO 430 IXYZ = 1, NXYZ
            IF (NOCP(IXYZ).NE.0) GO TO 430
            ITEMP = (IXYZ-1)*NBF3
            WRITE(IW,*) 'DIIS INTERPOLATED ALPHA CPHF SOLUTION IS'
            CALL PRSQ(PAI1(ITEMP+1),NBF,NBF,NBF)
            ITEMP = (IXYZ-1)*NBF3
            WRITE(IW,*) 'DIIS INTERPOLATED BETA CPHF SOLUTION IS'
            CALL PRSQ(PAI2(ITEMP+1),NBF,NBF,NBF)
  430    CONTINUE
      END IF
C
      GOPARR=GPSAVE
      DSKWRK = DSKSAV
      IF(GOPARR) THEN
         CALL DDI_BCAST(1005,'F',PAI1,NXYZ*NBF3,MASTER)
         CALL DDI_BCAST(1005,'F',PAI2,NXYZ*NBF3,MASTER)
      END IF
      RETURN
C
  900 FORMAT(' ..... INITIATING DIIS PROCEDURE .....')
  910 FORMAT(1X,5F13.8)
      END
C
C*MODULE CPHF    *DECK CPFA
      SUBROUTINE CPFA(DBG,WAX,AA,DFMO,WAXC,IA,NUM,
     *                NOCC,NVIR,NUM2,NOCC2,NXYZ,NFT18,NFZC,NOCACT,NDER)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION WAX(NOCC,NVIR,NXYZ),AA(NOCC2,NXYZ),DFMO(NUM2),IA(NUM)
      DIMENSION WAXC(NFZC,NOCACT,NXYZ)
C
      LOGICAL DBG,GOPARR,DSKWRK,MASWRK,SVDSKW
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (FOUR=4.0D+00)
C
C     ----- INITIALIZE -WAX- AND -AA- WITH DF/DA TERMS -----
C
      CALL VCLR(WAX,1,NOCC*NVIR*NXYZ)
      CALL VCLR(WAXC,1,NFZC*NOCACT*NXYZ)
      CALL VCLR(AA,1,NOCC2*NXYZ)
C
C        ONLY THE MASTER NODE HAS THE DERIVATIVE FOCK MATRIX DISK FILE
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT18)
C
      DO 300 IXYZ=1,NXYZ
         CALL SQREAD(NFT18,DFMO,NUM2)
         IF(DBG) THEN
            WRITE(IW,*) 'FCKDER',IXYZ
            CALL PRTRI(DFMO,NUM)
         END IF
C
         DO 120 IVIR=1,NVIR
            DO 110 IOCC=1,NOCC
               IJ=IA(IVIR+NOCC)+IOCC
               WAX(IOCC,IVIR,IXYZ)=FOUR*DFMO(IJ)
  110       CONTINUE
  120    CONTINUE
C
         IF (NDER.EQ.1 .AND. NFZC.GT.0) THEN
            DO 150 IACT=1,NOCACT
               DO 140 IFZC=1,NFZC
                  IJ=IA(IACT+NFZC)+IFZC
                  WAXC(IFZC,IACT,IXYZ)=FOUR*DFMO(IJ)
  140          CONTINUE
  150       CONTINUE
         END IF
C
         DO 220 IOCC=1,NOCC
            DO 210 JOCC=1,IOCC
               IJ=IA(IOCC)+JOCC
               AA(IJ,IXYZ) = FOUR*DFMO(IJ)
  210       CONTINUE
  220    CONTINUE
  300 CONTINUE
C
      CALL SEQREW(NFT18)
      DSKWRK = SVDSKW
      RETURN
      END
C*MODULE CPHF    *DECK CPFCK
      SUBROUTINE CPFCK(WAX,AA,TA,FMO,DTEMP,FTEMP,C,Y,X,WORK,
     *                 HF,WAXC,XX,IX,GHONDO,XINTS,DSH,DDIJ,IA,
     *                 NOCC,NVIR,NORB,NOCC2,NORB2,NXYZ,NNXYZ,NFTI,
     *                 NINTMX,NUM,NUM2,NFZC,NOCACT,NDER,MAXG,NSH2,MXG2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,POLAR,AODRV
C
C        -FMO- IS USED ONLY FOR COMPUTING RESPONSES FROM MO INTEGRALS.
C        -DTEMP-, -FTEMP-, -C-, -Y-, -X-, -WORK- ARE USED ONLY FOR
C           CALCULATION OF RESPONSES FROM AO BASIS INTEGRALS.
C        -HF- IS USED FOR OPTIONAL POLARIZABILITY COMPUTATION.
C        -WAXC- IS USED ONLY DURING CI GRADIENT RUNS.
C
      DIMENSION WAX(NOCC,NVIR,NNXYZ),AA(NOCC2,NXYZ),TA(NOCC2,NXYZ),
     *          FMO(NXYZ,NORB2),DTEMP(NXYZ,NUM2),FTEMP(NXYZ,NUM2),
     *          C(NUM,NUM),Y(NUM,NUM),X(NUM,NUM),WORK(*),
     *          HF(NUM2,3),WAXC(NFZC,NOCACT,NNXYZ),XX(NINTMX),IX(*),
     *          GHONDO(MAXG),XINTS(NSH2),DSH(NSH2),DDIJ(16*MXG2),IA(NUM)
C
      COMMON /CHFINF/ CHFSLV,CPTYPE,NWDCHF,POLAR
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
C
      PARAMETER (PT5=0.5D+00, FOUR=4.0D+00)
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA TYPEAO/8HAO      /
#else
      CHARACTER*8 :: TYPEAO_STR
      EQUIVALENCE (TYPEAO, TYPEAO_STR)
      DATA TYPEAO_STR/"AO      "/
#endif
C
C     ----- FORM THE INTEGRAL CONTRIBUTIONS TO -AA- AND -WAX- -----
C
      AODRV = CPTYPE.EQ.TYPEAO
      IF(AODRV) THEN
C
C          EITHER WE ARE WORKING WITH INTEGRALS IN THE AO BASIS...
C
C     TRANSFORM THE TAS INTO THE AO BASIS,
C     THESE "DENSITY MATRICES" ARE STORED IN -DTEMP-
C
         DO 290 IXYZ=1,NXYZ
            CALL EXPND(TA(1,IXYZ),WORK,NOCC,0)
            CALL MRARTR(WORK,NOCC,NOCC,NOCC,C,NUM,NUM,X,NUM)
            CALL MRARBR(C,NUM,NUM,NOCC,X,NUM,NUM,Y,NUM)
C
            IJ = 0
            DO 260 I=1,NUM
               DO 250 J=1,I
                  IJ = IJ + 1
                  DTEMP(IXYZ,IJ) = Y(I,J) + Y(J,I)
  250          CONTINUE
  260       CONTINUE
  290    CONTINUE
C
C     NOW BUILD THE "FOCK-LIKE MATRICES" IN -FTEMP-
C
         CALL AOFLM2(DTEMP,FTEMP,GHONDO,XINTS,DSH,DDIJ,XX,IX,
     *               NUM,NXYZ,MAXG,NSH2,MXG2,NINT,NSCHWZ)
C
C     TRANSFORM THE RESULTS TO THE MO BASIS
C
         DO 390 IXYZ = 1,NXYZ
            DO 310 IDUM=1,NUM2
               WORK(IDUM) = FTEMP(IXYZ,IDUM)
  310       CONTINUE
            CALL EXPND(WORK,Y,NUM,0)
            CALL MRARBR(Y,NUM,NUM,NUM,C,NUM,NOCC,X,NUM)
            CALL MRTRBT(C,NUM,NUM,NOCC,X,NUM,WORK,1,1)
C
C     FORM THE AIJ^A CONTRIBUTION OF EQUATION 13.
C     NOTE THAT THE FACTOR OF 4 IS THE 2 FROM EQUATION 13 AND
C     ANOTHER TWO TAKING INTO ACCOUNT THE SYMMETRY OF THE TRANSFORMATION
C     (HAVE TWO TERMS THAT ARE SYMMETRIC, I CALCULATED ONE
C      AND NEED TO MULTIPLY BY TWO WHICH I AM DOING HERE)
C
            DO 330 IJ=1,NOCC2
               AA(IJ,IXYZ) = AA(IJ,IXYZ) + 4.0D+00*WORK(IJ)
  330      CONTINUE
C
C     DO LAST PART OF SECOND TRANSFORMATION INTO THE MO BASIS
C     (FIRST PART IS THE SAME AS THE PREVIOUS TRANSFORMATION)
C     THIS IS FOR EQUATION 14 TO FORM WAX
C
           CALL MRTRBR(C(1,NOCC+1),NUM,NUM,NVIR,X,NUM,NOCC,WORK,NVIR)
C
C     NOW FORM WAX
C     NOTE THAT THE FACTOR OF 8 IS THE 4 FROM EQUATION 14 AND
C     ANOTHER TWO TAKING INTO ACCOUNT THE SYMMETRY OF THE TRANSFORMATION
C     (HAVE TWO TERMS THAT ARE SYMMETRIC, I CALCULATED ONE
C      AND NEED TO MULTIPLY BY TWO WHICH I AM DOING HERE)
C
         I = 1
         DO 360 IOCC=1,NOCC
            DO 350 IVIR=1,NVIR
                  WAX(IOCC,IVIR,IXYZ) = WAX(IOCC,IVIR,IXYZ) +
     *                                  8.0D+00*WORK(I)
                  I = I + 1
  350          CONTINUE
  360       CONTINUE
  390    CONTINUE
C
C          ...OR WE ARE WORKING WITH INTEGRALS TRANSFORMED TO MO BASIS.
C
      ELSE
         CALL VCLR(FMO,1,NXYZ*NORB2)
C
C     ----- READ IN MO INTEGRALS -----
C     TRANSFORMED INTEGRALS ASSUMED IN REVERSE CANONICAL ORDER
C
         CALL SEQREW(NFTI)
         IF (MASWRK) READ(NFTI)
  500    CONTINUE
         CALL PREAD(NFTI,XX,IX,NX,NINTMX)
         IF(NX.EQ.0) GO TO 710
         MX=ABS(NX)
         IF(MX.GT.NINTMX) GO TO 9000
C
C     ----- UNPACK LABEL AND PROCESS INTEGRAL -----
C
         DO 700 M=1,MX
         VAL   = XX(M)
C
                       NPACK = M
                       IF (LABSIZ .EQ. 2) THEN
#if !defined(SPEC_CPU_ILP64)
                         LABEL1 = IX( 2*NPACK - 1 )
                         LABEL2 = IX( 2*NPACK     )
                         IPACK = ISHFT( LABEL1, -16 )
                         JPACK = IAND( LABEL1, 65535 )
                         KPACK = ISHFT( LABEL2, -16 )
                         LPACK = IAND( LABEL2, 65535 )
#endif
#if defined(SPEC_CPU_ILP64)
                         LABEL = IX(NPACK)
                         IPACK = ISHFT( LABEL, -48 )
                         JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
                         KPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
                         LPACK = IAND( LABEL, 65535 )
#endif
                       ELSE IF (LABSIZ .EQ. 1) THEN
#if !defined(SPEC_CPU_ILP64)
                         LABEL = IX(NPACK)
                         IPACK = ISHFT( LABEL, -24 )
                         JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
                         KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
                         LPACK = IAND( LABEL, 255 )
#endif
#if defined(SPEC_CPU_ILP64)
                         IF ( MOD(NPACK,2) .EQ. 0 ) THEN
                           LABEL = IX( NPACK/2 )
                           IPACK = IAND( ISHFT( LABEL, -24 ), 255 )
                           JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
                           KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
                           LPACK = IAND( LABEL, 255 )
                         ELSE
                           LABEL = IX( (NPACK/2)+1 )
                           IPACK = ISHFT( LABEL, -56 )
                           JPACK = IAND( ISHFT( LABEL, -48 ), 255 )
                           KPACK = IAND( ISHFT( LABEL, -40 ), 255 )
                           LPACK = IAND( ISHFT( LABEL, -32 ), 255 )
                         END IF
#endif
                       END IF
                       K = IPACK
                       L = JPACK
                       I = KPACK
                       J = LPACK
C
C
C     ----- -AA- TERMS -----
C
         IF(I.GT.NOCC) GO TO 600
         IF(J.EQ.I           ) VAL=VAL*PT5
         IF(L.EQ.K           ) VAL=VAL*PT5
         IF(K.EQ.I.AND.L.EQ.J) VAL=VAL*PT5
         VALJ=(VAL +VAL )
         VALJ=(VALJ+VALJ)
         VALK=-VAL
         NIJ=IA(I)+J
         NKL=IA(K)+L
         NIK=IA(I)+K
         NIL=IA(I)+L
         NJK=IA(MAX(J,K))+MIN(J,K)
         NJL=IA(MAX(J,L))+MIN(J,L)
C
         DO 550 IXYZ=1,NXYZ
            FMO(IXYZ,NIJ)=FMO(IXYZ,NIJ)+VALJ*TA(NKL,IXYZ)
            FMO(IXYZ,NKL)=FMO(IXYZ,NKL)+VALJ*TA(NIJ,IXYZ)
            FMO(IXYZ,NIK)=FMO(IXYZ,NIK)+VALK*TA(NJL,IXYZ)
            FMO(IXYZ,NIL)=FMO(IXYZ,NIL)+VALK*TA(NJK,IXYZ)
            FMO(IXYZ,NJK)=FMO(IXYZ,NJK)+VALK*TA(NIL,IXYZ)
            FMO(IXYZ,NJL)=FMO(IXYZ,NJL)+VALK*TA(NIK,IXYZ)
  550    CONTINUE
         GO TO 700
C
C     ----- -WAX- TERMS -----
C
  600    CONTINUE
         IF(J.GT.NOCC.OR.K.GT.NOCC) GO TO 700
         IF(L.EQ.K) VAL=VAL*PT5
         VALJ=(VAL +VAL )
         VALJ=(VALJ+VALJ)
         VALK=-VAL
         NIJ=IA(I)+J
         NKL=IA(K)+L
         NIK=IA(I)+K
         NIL=IA(I)+L
         NJK=IA(MAX(J,K))+MIN(J,K)
         NJL=IA(MAX(J,L))+MIN(J,L)
C
         DO 690 IXYZ=1,NXYZ
            FMO(IXYZ,NIJ)=FMO(IXYZ,NIJ)+VALJ*TA(NKL,IXYZ)
            FMO(IXYZ,NIK)=FMO(IXYZ,NIK)+VALK*TA(NJL,IXYZ)
            FMO(IXYZ,NIL)=FMO(IXYZ,NIL)+VALK*TA(NJK,IXYZ)
  690    CONTINUE
C
  700    CONTINUE
         IF(NX.GT.0) GO TO 500
C
C          DONE WITH INTEGRAL CONTRIBUTIONS TO -FMO-
C
  710    CONTINUE
         IF(GOPARR) CALL DDI_GSUMF(2101,FMO,NORB2*NXYZ)
C
         CALL DSCAL(NORB2*NXYZ,PT5,FMO,1)
         DO 750 IXYZ=1,NXYZ
            MM=0
            DO 740 M=1,NORB
               MM = MM+M
               FMO(IXYZ,MM)=FMO(IXYZ,MM)+FMO(IXYZ,MM)
  740       CONTINUE
  750    CONTINUE
C
C     ----- -FMO- CONTRIBUTION TO -AA- -----
C
         DO 810 IXYZ=1,NXYZ
         DO 810 IOCC=1,NOCC
         DO 810 JOCC=1,IOCC
         IJ=IA(IOCC)+JOCC
  810    AA(IJ,IXYZ)        =AA(IJ,IXYZ)
     *                      +(FOUR+FOUR)*FMO(IXYZ,IJ)
C
C     ----- -FMO- CONTRIBUTION TO -WAX- -----
C
         DO 830 IXYZ=1,NXYZ
         DO 830 IVIR=1,NVIR
         DO 830 IOCC=1,NOCC
         IJ=IA(IVIR+NOCC)+IOCC
  830    WAX(IOCC,IVIR,IXYZ)=WAX(IOCC,IVIR,IXYZ)
     *                      +(FOUR*FOUR)*FMO(IXYZ,IJ)
C
C     ----- -FMO- CONTRIBUTION TO -WAXC- -----
C
         IF (NDER.EQ.1 .AND. NFZC.GT.0) THEN
            DO 850 IXYZ=1,NXYZ
            DO 850 IACT=1,NOCACT
            DO 850 IFZC=1,NFZC
            IJ=IA(IACT+NFZC)+IFZC
  850       WAXC(IFZC,IACT,IXYZ)=WAXC(IFZC,IACT,IXYZ)
     *                          +(FOUR*FOUR)*FMO(IXYZ,IJ)
         END IF
C
C            END OF SECTION PROCESSING MO INTEGRALS
C
      END IF
C
C     ---- IF POLARIZABILITY GET TRANSFORMED DIPOLE INTEGRALS ----
C                      ---- ADD TO -WAX- ----
C     ---- NOTE THAT MULTIPLICATION BY FOUR NEEDED TO RECONCILE ----
C     ---- SCHAEFER'S AND KOMORNIKI'S FORMULATIONS              ----
C
      IF(POLAR) THEN
         CALL DAREAD(IDAF,IODA,HF(1,1),NUM2,252,0)
         CALL DAREAD(IDAF,IODA,HF(1,2),NUM2,253,0)
         CALL DAREAD(IDAF,IODA,HF(1,3),NUM2,254,0)
C
         DO 950 IVIR=1,NVIR
            DO 960 IOCC=1,NOCC
               IJ=IA(IVIR+NOCC)+IOCC
               WAX(IOCC,IVIR,NXYZ+1)=FOUR*HF(IJ,1)
               WAX(IOCC,IVIR,NXYZ+2)=FOUR*HF(IJ,2)
               WAX(IOCC,IVIR,NXYZ+3)=FOUR*HF(IJ,3)
  960       CONTINUE
  950    CONTINUE
      END IF
C
      RETURN
C
 9000 IF (MASWRK) WRITE(IW,9999) MX,NINTMX
      CALL ABRT
      STOP
C
 9999 FORMAT(' ERROR STOP IN -CPFCK-',/,
     1       ' MX IS LARGER THAN NINTMX. MX =',I10,' NINTMX =',I10)
      END
C*MODULE CPHF    *DECK CPFCM
      SUBROUTINE CPFCM(FCM,NAT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION DNAM(3),FC(9),FCM(*)
C
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA DNAM /8HD/DX    ,8HD/DY    ,8HD/DZ    /
#else
      CHARACTER*8 :: DNAM_STR(3)
      EQUIVALENCE (DNAM, DNAM_STR)
      DATA DNAM_STR/"D/DX    ","D/DY    ","D/DZ    "/
#endif
C
      NC=3*NAT
C
C     ----- PRINT FORCE CONSTANT MATRIX -----
C
      IF (MASWRK) WRITE(IW,9998)
      MAX=0
   50 MIN=MAX+1
      MAX=MAX+3
      IF(MAX.GT.NAT) MAX=NAT
      IF (MASWRK) THEN
         WRITE(IW,9997)
         WRITE(IW,9994) (J,J=MIN,MAX)
         WRITE(IW,9997)
         WRITE(IW,9993) ((DNAM(I),I=1,3),J=MIN,MAX)
         WRITE(IW,9997)
      END IF
      JMIN=3*(MIN-1)+1
      JMAX=3* MAX
      I=0
      DO 80 IAT=1,NAT
         DO 70 N=1,3
            I=I+1
            DO 60 J=JMIN,JMAX
               IJ=NC*(J-1)+I
               FC(J-JMIN+1)=FCM(IJ)
   60       CONTINUE
            KMAX=JMAX-JMIN+1
            IF (MASWRK) WRITE(IW,9995) DNAM(N),(FC(J),J=1,KMAX)
   70    CONTINUE
   80 CONTINUE
      IF(MAX.LT.NAT) GO TO 50
      IF (MASWRK) WRITE(IW,9997)
      RETURN
C
 9998 FORMAT(/1X,' --- HESSIAN --- ')
 9997 FORMAT(1X)
 9995 FORMAT(5X,A4,9F12.7)
 9994 FORMAT(5X,'ATOM',3(19X,I2,15X))
 9993 FORMAT(5X,'    ',9(6X,A4,2X))
      END
C*MODULE CPHF    *DECK CPHFX
      SUBROUTINE CPHFX
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL PPGVB,TCSCF,ROGVB,SOME,DBG,GOPARR,DSKWRK,MASWRK,POLAR
C
      PARAMETER (MXSH=1000, MXATM=500, MXAO=2047)
C
      DIMENSION NOCP((3*MXATM)+3)
C
      COMMON /CHFINF/ CHFSLV,CPTYPE,NWDCHF,POLAR
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFIRST(MXATM,6),
     *                KLAST(MXATM,6),LMAX(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /FMCOM / X(1)
      COMMON /FUNCT / E,EG(3,MXATM)
      COMMON /GVBWFN/ CICOEF(2,12),F(25),ALPHA(325),BETA(325),NO(10),
     *                NCO,NSETO,NOPEN,NPAIR,NORB,NCONF(MXAO),NHAM
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(400)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
      COMMON /WFNOPT/ SCFTYP,CITYP,DFTYPE,CCTYP,MPLEVL,MPCTYP
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA CPWORD/8HCPHF    /
#else
      CHARACTER*8 :: CPWORD_STR
      EQUIVALENCE (CPWORD, CPWORD_STR)
      DATA CPWORD_STR/"CPHF    "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA RHF/8HRHF     /, ROHF/8HROHF    /, GVB/8HGVB     /,
     *     UHF/8HUHF     /, RMC/8HMCSCF   /
#else
      CHARACTER*8 :: RHF_STR
      EQUIVALENCE (RHF, RHF_STR)
      CHARACTER*8 :: ROHF_STR
      EQUIVALENCE (ROHF, ROHF_STR)
      CHARACTER*8 :: GVB_STR
      EQUIVALENCE (GVB, GVB_STR)
      CHARACTER*8 :: UHF_STR
      EQUIVALENCE (UHF, GVB_STR)
      CHARACTER*8 :: RMC_STR
      EQUIVALENCE (RMC, GVB_STR)
      DATA RHF_STR/"RHF     "/, ROHF_STR/"ROHF    "/, 
     * GVB_STR/"GVB     "/, UHF_STR/"UHF     "/, RMC_STR/"MCSCF   "/
#endif
C
C     ----- MAIN DRIVER FOR RESPONSE EQUATION CONTRIBUTIONS -----
C     THIS MEANS ANALYTIC 2ND DERIVATIVES FOR SCF FUNCTIONS,
C     OR 1ST DERIVATIES FOR NON-SCF FUNCTIONS SUCH AS -CI-.
C
      DBG=EXETYP.EQ.CPWORD .AND. MASWRK
      SOME = NPRINT.NE.-5 .AND. MASWRK
      NFT16 = 16
      NFT18 = 18
C
      CALL DERCHK(NDER)
      IF(NDER.EQ.1  .AND.  SCFTYP.NE.RHF) THEN
         IF(MASWRK) WRITE(IW,*)
     *           'CPHF PROGRAMMED FOR RHF+CI GRADIENTS ONLY'
         CALL ABRT
      END IF
C
C     ----- DEFINE UNIQUE -XYZ- FOR WHICH -CPHF- IS NEEDED -----
C
      NXYZ = NAT*3
C
      IF(NDER.EQ.2) THEN
         NUNIQ= 0
         DO 40 IXYZ=1,NXYZ
            NOCP(IXYZ)=1
   40    CONTINUE
         DO 60 IAT=1,NAT
            NUCZ = INT(ZAN(IAT)+0.01D+00) + IZCORE(IAT)
            IF(NUCZ.EQ.0) GO TO 60
            DO 50 IT=1,NT
               IF(MAPCTR(IAT,IT).GT.IAT) GO TO 60
   50       CONTINUE
            IXYZ=3*(IAT-1)
            NOCP(IXYZ+1)=0
            NOCP(IXYZ+2)=0
            NOCP(IXYZ+3)=0
            NUNIQ = NUNIQ+3
   60    CONTINUE
         IF(POLAR) THEN
            NOCP(NXYZ+1)=0
            NOCP(NXYZ+2)=0
            NOCP(NXYZ+3)=0
            NUNIQ = NUNIQ+3
         END IF
      ELSE
         NUNIQ=1
         NOCP(1)=0
         POLAR=.FALSE.
      END IF
C
      IF(NDER.EQ.1) GO TO 300
C
C     ----- INITIALIZE -FCM- WITH ALL NON-CPHF TERMS -----
C
      NEG  = 3*NAT
      NEH  = 9*(NAT*NAT+NAT)/2
      NEGH = NEG + NEH
      NC3  = (3*NAT)*(3*NAT)
C
      CALL VALFM(LOADFM)
      LFCM = LOADFM + 1
      LEG  = LFCM + NC3
      LEH  = LEG  + NEG
      LAST = LEH  + NEH
      NEED = LAST - LFCM
      CALL GETFM(NEED)
C
C     ----- READ FINISHED GRADIENT AND PARTIAL HESSIAN -----
C
      CALL DAREAD(IDAF,IODA,X(LEG),NEGH,67,0)
C
C     ----- SAVE GRADIENT -----
C
      CALL DAWRIT(IDAF,IODA,X(LEG),NEG, 3,0)
      CALL DAWRIT(IDAF,IODA,X(LEG),NEG,29,0)
      CALL DCOPY(NEG,X(LEG),1,EG,1)
      IF(DBG) WRITE(IW,9010)
      IF(DBG) CALL EGOUT(X(LEG),NAT)
C
C     ----- FILL HESSIAN WITH ALL NON-CPHF CONTRIBUTIONS -----
C
      CALL CPWAB0(X(LFCM),X(LEH),NAT)
      IF(DBG) WRITE(IW,9993)
      IF(DBG) CALL CPFCM(X(LFCM),NAT)
      CALL DAWRIT(IDAF,IODA,X(LFCM),NC3,4,0)
      CALL RETFM(NEED)
C
C     ----- NOW DO THE APPROPRIATE CPHF PROBLEM -----
C
  300 CONTINUE
      ROGVB = (SCFTYP.EQ.GVB  .AND.  NPAIR.EQ.0)  .OR.  SCFTYP.EQ.ROHF
      TCSCF = (SCFTYP.EQ.GVB  .AND.  NPAIR.EQ.1)
      PPGVB = (SCFTYP.EQ.GVB  .AND.  NPAIR.GT.1)
C
      IF(SCFTYP.EQ.RHF) CALL CPRHF(NDER,SOME,DBG,NOCP,NXYZ,NUNIQ,
     *                             NFT16,NFT18)
      IF(SCFTYP.EQ.UHF) CALL ABRT
      IF(ROGVB)         CALL CPROHF(TCSCF,SOME,DBG,NOCP,NXYZ,NUNIQ,
     *                              NFT16,NFT18)
      IF(TCSCF)         CALL CPROHF(TCSCF,SOME,DBG,NOCP,NXYZ,NUNIQ,
     *                              NFT16,NFT18)
      IF(PPGVB)         CALL ABRT
      IF(SCFTYP.EQ.RMC) CALL ABRT
C
      IF (MASWRK) WRITE(IW,9000)
      CALL TIMIT(1)
      RETURN
C
 9000 FORMAT(1X,'...... DONE WITH CPHF CONTRIBUTIONS ......')
 9010 FORMAT(10X,15("-")/10X,'ENERGY GRADIENT'/10X,15("-"))
 9993 FORMAT(1X,'-FCM- WITH ALL INTEGRAL DERIVATIVE CONTRIBUTIONS')
      END
C*MODULE CPHF    *DECK CPINP
      SUBROUTINE CPINP
C
      IMPLICIT DOUBLE PRECISION(A-H, O-Z)
C
      LOGICAL GOPARR,MASWRK,DSKWRK,POLAR,OK
C
      COMMON /CHFINF/ CHFSLV,CPTYPE,NWDCHF,POLAR
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,CITYP,DFTYPE,CCTYP,MPLEVL,MPCTYP
C
C         NAMELIST DEFINITIONS
C
      PARAMETER (NNAM=4)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA CPHF /8HCPHF    /
#else
      CHARACTER*8 :: CPHF_STR
      EQUIVALENCE (CPHF, CPHF_STR)
      DATA CPHF_STR/"CPHF    "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA QNAM /8HCPHF    ,8HPOLAR   ,8HSOLVER  ,8HNWORD   /
#else
      CHARACTER*8 :: QNAM_STR(NNAM)
      EQUIVALENCE (QNAM, QNAM_STR)
      DATA QNAM_STR/"CPHF    ","POLAR   ","SOLVER  ","NWORD   "/
#endif
      DATA KQNAM /5,0,5,1/
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA BLANK/8H        /
#else
      CHARACTER*8 :: BLANK_STR
      EQUIVALENCE (BLANK, BLANK_STR)
      DATA BLANK_STR/"        "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA TYPEAO,TYPEMO/8HAO      ,8HMO      /
#else
      CHARACTER*8 :: TYPEAO_STR, TYPEMO_STR
      EQUIVALENCE (TYPEMO, TYPEMO_STR), (TYPEAO, TYPEAO_STR)
      DATA TYPEAO_STR,TYPEMO_STR/"AO      ","MO      "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA RHF/8HRHF     /, ANONE/8HNONE    /
#else
      CHARACTER*8 :: RHF_STR
      EQUIVALENCE (RHF, RHF_STR)
      CHARACTER*8 :: ANONE_STR
      EQUIVALENCE (ANONE, ANONE_STR)
      DATA RHF_STR/"RHF     "/, ANONE_STR/"NONE    "/
#endif
C
C     ----- READ $CPHF INPUT GROUP ----
C     CHFSLV IS UNDOCUMENTED DEBUGGING OPTION,
C     FOR MO BASIS RESPONSE EQUATIONS,
C       USE 'CONJG' TO FORCE USE OF CONJUGATE GRADIENTS, EVEN FOR
C            LITTLE PROBLEMS THAT NORMALLY WOULD CALL LINPACK ROUTINES.
C       USE 'ONDISK' TO FORCE THE OUT-OF-CORE CONJUGATE GRADIENT SOLVER.
C     FOR AO BASIS RESPONSE EQUATIONS,
C       USE 'CONJG' FOR ORDINARY PRECONDITIONED CONJUGATE GRADIENT
C       USE 'DIIS' TO USE SIMON WEBB'S DIIS-LIKE ITERATIVE SOLVER
C     FOR EITHER, USE BLANK TO LET THE SOLVER TAKE ITS NORMAL CHOICE.
C
      CPTYPE= TYPEMO
      POLAR = .FALSE.
      CHFSLV= BLANK
      NWDCHF= 0
C
      CALL NAMEIO(IR,JRET,CPHF,NNAM,QNAM,KQNAM,
     *            CPTYPE,POLAR,CHFSLV,NWDCHF,
     *      0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *      0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *      0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0)
C
      IF(MASWRK  .AND.  NPRINT.NE.-5) WRITE(IW,9010) POLAR,NWDCHF
C
C     CPTYPE IS UNDOCUMENTED OPTION TO ALLOW RHF RESPONSES IN AO BASIS.
C     EXTENDED TDHF CODE PROGRAMMED ONLY IN THE AO BASIS.
C
      IF(SCFTYP.NE.RHF)   CPTYPE=TYPEMO
      IF(CITYP.NE.ANONE)  CPTYPE=TYPEMO
      IF(IGETOLI(0).NE.0) CPTYPE=TYPEAO
      OK = .FALSE.
      IF (CPTYPE.EQ.TYPEAO) OK = .TRUE.
      IF (CPTYPE.EQ.TYPEMO) OK = .TRUE.
      IF (.NOT.OK) THEN
         IF(MASWRK) WRITE(IW,*) 'ILLEGAL CHOICE FOR -CPTYPE- IN $CPHF'
         CALL ABRT
      END IF
C
      IF(JRET.EQ.2) THEN
         IF (MASWRK) WRITE(IW,9020)
         CALL ABRT
      END IF
      RETURN
C
 9010 FORMAT(/5X,30("-")/5X,'CPHF RESPONSE SOLUTION OPTIONS'/5X,30("-")/
     *       5X,'POLAR  =',L8,5X,'NWORD  =',I8)
 9020 FORMAT(1X,'ERROR IN $CPHF INPUT - STOP ')
      END
C*MODULE CPHF    *DECK CPRHF
      SUBROUTINE CPRHF(NDER,SOME,DBG,NOCP,NXYZ,NUNIQ,NFT16,NFT18)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL DBG,SOME,CHKMEM,PACK2E,INCORE,GOPARR,DSKWRK,MASWRK,
     *        SVDSKW,SVGPAR,POLAR,AODRV,DIRSCF,FDIFF
C
      PARAMETER (MXATM=500, MXSH=1000, MXGTOT=5000, MXGSH=30, MXAO=2047)
C
      DIMENSION NOCP(NXYZ+3)
C
      COMMON /CHFINF/ CHFSLV,CPTYPE,NWDCHF,POLAR
      COMMON /DIISSO/ SOGTOL,ETHRSH,MAXDII,IRAF
      COMMON /FMCOM / X(1)
      COMMON /GUGWFN/ NFZC,NMCC,NDOC,NAOS,NBOS,NALP,NVAL,NEXT,NFZV,
     *                IFORS,IEXCIT,ICICI,NOIRR
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTG76
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(400)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /OPTSCF/ DIRSCF,FDIFF
C
      DATA MAXEQU /128/
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA CHECK/8HCHECK   /
#else
      CHARACTER*8 :: CHECK_STR
      EQUIVALENCE (CHECK, CHECK_STR)
      DATA CHECK_STR/"CHECK   "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA CONJG,ONDISK/8HCONJG   ,8HONDISK  /
#else
      CHARACTER*8 :: CONJG_STR, ONDISK_STR
      EQUIVALENCE (CONJG, CONJG_STR), (ONDISK, ONDISK_STR)
      DATA CONJG_STR,ONDISK_STR/"CONJG   ","ONDISK  "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA BLANK,DIIS/8H        ,8HDIIS    /
#else
      CHARACTER*8 :: BLANK_STR, DIIS_STR
      EQUIVALENCE (BLANK, BLANK_STR), (DIIS, DIIS_STR)
      DATA BLANK_STR,DIIS_STR/"        ","DIIS    "/
#endif
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA TYPEAO/8HAO      /
#else
      CHARACTER*8 :: TYPEAO_STR
      EQUIVALENCE (TYPEAO, TYPEAO_STR)
      DATA TYPEAO_STR/"AO      "/
#endif
C
C     ----- CLOSED SHELL CPHF CALCULATION -----
C     FOR NDER=1, WE ARE DOING A RHF+CI GRADIENT COMPUTATION
C     FOR NDER=2, WE ARE DOING A RHF ANALYTIC HESSIAN CALCULATION
C
      IF(SOME) WRITE(IW,9000)
      AODRV = CPTYPE.EQ.TYPEAO
      IF(NDER.EQ.1) THEN
         NOCC = (NFZC + NMCC) + NDOC + NAOS + NBOS + NALP
         NOCACT = NOCC - NFZC
         NCVROT = NFZC*NOCACT
         IF(SOME) WRITE(IW,9005)
      ELSE
         NOCC = NA
      END IF
      NORB = NQMT
      NVIR = NORB - NOCC
      NROT = NOCC * NVIR
      IF(SOME) WRITE(IW,9010) NROT
C
      IF(NDER.EQ.2) THEN
         NC  = NAT*3
         NC3 = NC * NC
      ELSE
         NC  = 1
         NC3 = 1
      END IF
C
      NUM2 =(NUM*NUM+NUM)/2
      NUM3 = NUM*NUM
      NORB2=(NORB*NORB+NORB)/2
      NOCC2=(NOCC*NOCC+NOCC)/2
C
      IF(AODRV  .AND.  DIRSCF) THEN
         CALL BASCHK(LMAX)
                       NANGM =  4
         IF(LMAX.EQ.2) NANGM =  6
         IF(LMAX.EQ.3) NANGM = 10
         IF(LMAX.EQ.4) NANGM = 15
         MAXG = NANGM**4
         NSH2 = (NSHELL*NSHELL+NSHELL)/2
         MXG2 = MXGSH*MXGSH
         INTMAX = 1
      ELSE
         MAXG = 1
         NSH2 = 1
         MXG2 = 1
         INTMAX = NINTMX
      END IF
C
C     ---- IF CALCULATING ALPHA POLARIZABILITIES ----
C     ---- 3 EXTRA SOLUTIONS REQUIRED            ----
C
      IF(POLAR) THEN
         NNXYZ=NXYZ+3
         IF(MASWRK) WRITE(IW,9015) NUNIQ-3,3
      ELSE
         NNXYZ=NXYZ
         IF(MASWRK) WRITE(IW,9015) NUNIQ,0
      END IF
C
      IF(NVIR .EQ. 0) RETURN
C
C     ----- BEGIN CPHF TERMS -----
C     FIRST BRANCH ALL ABOUT TO CHECK MEMORY NEEDS,
C     THEN COME BACK TO -90- AND ACTUALLY BEGIN TO DO THE WORK.
C
      TIM1 = 0.0D+00
      CHKMEM = .TRUE.
      CALL VALFM(LOADFM)
      CALL GOTFM(NGOTMX)
      IF(NWDCHF.GT.0) NGOTMX=MIN(NGOTMX,NWDCHF)
      INCORE=.FALSE.
      NDFA   = 0
      NDTA   = 0
      NDFCK  = 0
      NDWXY  = 0
      NDWXYI = 0
      GO TO 95
C
   90 CONTINUE
      CHKMEM = .FALSE.
      IF(SOME) THEN
         WRITE(IW,9020) NDFA,NDTA,NDFCK,NDWXY,NGOTMX
         IF(.NOT.INCORE  .AND.  .NOT.AODRV  .AND.  NDWXYI.GT.0)
     *        WRITE(IW,9030) NDWXYI
      END IF
      NDMAX = MAX(NDFA,NDTA,NDFCK,NDWXY)
      IF(NDMAX.GT.NGOTMX) THEN
         IF (MASWRK) WRITE(IW,9040) NDMAX,NGOTMX
         CALL ABRT
         STOP
      END IF
C
      IF(EXETYP.EQ.CHECK) THEN
         CALL GETFM(NDMAX)
         CALL RETFM(NDMAX)
         RETURN
      END IF
C
C     ----- TRANSFORM -DF/DQ- TO MO BASIS -----
C
      CALL TSECND(TIM1)
   95 CONTINUE
      LFCM = 1    + LOADFM
      LWAX = LFCM + NC3
      LC   = LWAX + NROT *NNXYZ
      LAA  = LC   + NUM3
      LTA  = LAA  + NOCC2*NXYZ
      LDFAO= LTA  + NOCC2*NXYZ
      LDFMO= LDFAO+ NUM2
      LT   = LDFMO+ NUM2
      LAST = LT   + NUM
      IF(NDER.EQ.1 .AND. NFZC.GT.0) THEN
         LWAXC= LAST
         LAST = LWAXC+ NCVROT*NXYZ
      ELSE
         LWAXC= LAST
      END IF
      NEED = LAST - LOADFM - 1
      NDFA = NEED
      IF(CHKMEM) GO TO 115
      CALL GETFM(NEED)
C
C        READ IN HESSIAN WITH ALL NON-CPHF TERMS
C
      IF(NDER.EQ.2) CALL DAREAD(IDAF,IODA,X(LFCM),NC3,4,0)
C
C        READ MO VECTORS.
C
      CALL DAREAD(IDAF,IODA,X(LC),NUM3,15,0)
C
      CALL CPFA(DBG,X(LWAX),X(LAA),X(LDFMO),X(LWAXC),
     *          IA,NUM,NOCC,NVIR,NUM2,NOCC2,NXYZ,NFT18,NFZC,NOCACT,NDER)
C
C        SAVE DERIVATIVE FOCK MATRIX FOR EXTENDED TDHF JOBS.
C
      IF(IGETOLI(1).NE.0) THEN
         CALL SVGGA1(X(LDFMO),NFT18)
      END IF
C
      IF (NDER.EQ.1 .AND. NFZC.GT.0) THEN
         CALL DAWRIT(IDAF,IODA,X(LWAXC),NCVROT*NXYZ,304,0)
         IF(DBG) THEN
            WRITE(IW,*) '-WAXC- MATRIX AFTER -DFMO- TERMS'
            CALL PRSQ(X(LWAXC),NXYZ,NCVROT,NCVROT)
         END IF
      END IF
C
      IF(DBG) THEN
         WRITE(IW,*) '-WAX- MATRIX AFTER -DFMO- TERMS'
         CALL PRSQ(X(LWAX),NXYZ,NROT,NROT)
         DO 110 IXYZ=1,NXYZ
            WRITE(IW,9976) IXYZ
            CALL PRTRI(X(LAA+NOCC2*(IXYZ-1)),NOCC)
  110    CONTINUE
      END IF
      CALL RETFM(NEED)
      CALL TSECND(TIM2)
      TIMFA=TIM2-TIM1
      IF(SOME) WRITE(IW,9988) ' -FA-   ',TIMFA
      TIM1 = TIM2
C
C     ----- TRANSFORM - TA = -1/2 * DS/DA - TO MO BASIS -----
C
  115 CONTINUE
      LFCM = 1+LOADFM
      LWAX = LFCM + NC3
      LC   = LWAX + NROT *NNXYZ
      LAA  = LC   + NUM3
      LTA  = LAA  + NOCC2*NXYZ
      LE   = LTA  + NOCC2*NXYZ
      LDSAO= LE   + NUM
      LDSMO= LDSAO+ NUM2 *NXYZ
      LT   = LDSMO+ NUM2
      LDS  = LT   + NUM
      LAST = LDS  + NUM3*3
      IF(NDER.EQ.2) THEN
         LSDI = LAST
         LSDIA= LSDI + NAT*9
         LH   = LSDIA+ NAT*9
         LF   = LH   + NUM2*3
         LAST = LF   + NUM2
      ELSE
         LSDI  = LAST
         LSDIA = LAST
         LH    = LAST
         LF    = LAST
      END IF
      IF(NDER.EQ.1 .AND. NFZC.GT.0) THEN
         LWAXC= LAST
         LAST = LWAXC+ NCVROT*NXYZ
      ELSE
         LWAXC= LAST
      END IF
      NEED = LAST - LOADFM - 1
      NDTA = NEED
      IF(CHKMEM) GO TO 125
      CALL GETFM(NEED)
C
      IF(NDER.EQ.2) CALL VCLR(X(LH),1,NUM2*3)
C
C        READ 1ST DERIVATIVES OF OVERLAP MATRIX
C
      CALL DAREAD(IDAF,IODA,X(LDS       ),NUM3,63,0)
      CALL DAREAD(IDAF,IODA,X(LDS+NUM3  ),NUM3,64,0)
      CALL DAREAD(IDAF,IODA,X(LDS+NUM3*2),NUM3,65,0)
C
C        READ RHF ORBITAL ENERGIES
C
      CALL DAREAD(IDAF,IODA,X(LE),NUM,17,0)
C
      IF (NDER.EQ.1 .AND. NFZC.GT.0)
     *    CALL DAREAD(IDAF,IODA,X(LWAXC),NCVROT*NXYZ,304,0)
C
      CALL CPTA(NDER,X(LWAX),X(LTA),X(LC),X(LE),X(LDSAO),X(LDSMO),
     *          X(LT),X(LDS),X(LSDI),X(LF),X(LH),X(LWAXC),IA,
     *          NUM,NOCC,NVIR,NORB,NUM2,NOCC2,NXYZ,NAT,NFZC,NOCACT)
C
C        SAVE DERIVATIVE OVERLAP MATRIX FOR EXTENDED TDHF JOBS.
C
      IF(IGETOLI(1).NE.0) THEN
         CALL SVGSA(X(LDSAO),X(LDSMO),X(LC),X(LT))
      ENDIF
C
      IF (NDER.EQ.1 .AND. NFZC.GT.0) THEN
         CALL DAWRIT(IDAF,IODA,X(LWAXC),NCVROT*NXYZ,304,0)
         IF(DBG) THEN
            WRITE(IW,*) '-WAXC- MATRIX AFTER -TA- TERMS'
            CALL PRSQ(X(LWAXC),NXYZ,NCVROT,NCVROT)
         END IF
      END IF
C
      IF(DBG) THEN
         WRITE(IW,*) '-WAX- MATRIX AFTER -TA- TERMS'
         CALL PRSQ(X(LWAX),NXYZ,NROT,NROT)
         DO 120 IXYZ=1,NXYZ
            WRITE(IW,9994) IXYZ
            CALL PRTRI(X(LTA+NOCC2*(IXYZ-1)),NOCC)
  120    CONTINUE
      END IF
C
      CALL TSECND(TIM2)
      TIMTA=TIM2-TIM1
      IF(SOME) WRITE(IW,9988) ' -TA-   ',TIMTA
C
C     --- ADD OVERLAP DERIVATIVE CONTRIBUTIONS TO DIPOLE DERIVATIVE ---
C
      IF(NDER.EQ.2) THEN
         IF(DBG) THEN
            WRITE(IW,9995)
            CALL DDMOUT(X(LSDI),3*NAT)
         END IF
         CALL DAREAD(IDAF,IODA,X(LSDIA),9*NAT,34,0)
         CALL VADD(X(LSDIA),1,X(LSDI),1,X(LSDIA),1,9*NAT)
         CALL DAWRIT(IDAF,IODA,X(LSDIA),9*NAT,34,0)
C
C     ----- ADD - TA * TB - CONTRIBUTIONS TO -FCM- -----
C
         CALL CPWAB1(X(LFCM),X(LTA),X(LE),IA,NOCC,NOCC2,NXYZ)
         IF(DBG) WRITE(IW,9992)
         IF(DBG) CALL CPFCM(X(LFCM),NAT)
      END IF
C
      CALL RETFM(NEED)
C
C     ----- FORM MODIFIED FOCK MATRICES -----
C
      CALL TSECND(TIM1)
  125 CONTINUE
      LFCM = LOADFM + 1
      LWAX = LFCM + NC3
      LC   = LWAX + NROT *NNXYZ
      LAA  = LC   + NUM3
      LTA  = LAA  + NOCC2*NXYZ
      LAST = LTA  + NOCC2*NXYZ
C
      IF(AODRV) THEN
         LDTEMP = LAST
         LFTEMP = LDTEMP + NUM2*NXYZ
         LX     = LFTEMP + NUM2*NXYZ
         LY     = LX     + NUM3
         LWORK  = LY     + NUM3
         LGHOND = LWORK  + MAX(NUM2,NOCC*NOCC,NOCC2)
         LXINTS = LGHOND + MAXG
         LDSH   = LXINTS + NSH2
         LDDIJ  = LDSH   + NSH2
         LAST   = LDDIJ  + 16*MXG2
         LFMO   = LAST
      ELSE
         LFMO   = LAST
         LAST   = LFMO   + NORB2*NXYZ
         LDTEMP = LAST
         LFTEMP = LAST
         LX     = LAST
         LY     = LAST
         LWORK  = LAST
         LGHOND = LAST
         LXINTS = LAST
         LDSH   = LAST
         LDDIJ  = LAST
      END IF
      LXX  = LAST
      LIX  = LXX + NINTMX
      LAST = LIX + NINTMX
      IF(POLAR) THEN
         LHF  = LAST
         LAST = LHF  + NUM2*3
      ELSE
         LHF  = LAST
      END IF
C
      IF(NDER.EQ.1 .AND. NFZC.GT.0) THEN
         LWAXC= LAST
         LAST = LWAXC+ NCVROT*NXYZ
      ELSE
         LWAXC= LAST
      END IF
C
      NEED = LAST - LOADFM - 1
      NDFCK = NEED
      IF(CHKMEM) GO TO 135
      CALL GETFM(NEED)
C
      IF (NDER.EQ.1 .AND. NFZC.GT.0)
     *    CALL DAREAD(IDAF,IODA,X(LWAXC),NCVROT*NXYZ,304,0)
C
      CALL CPFCK(X(LWAX),X(LAA),X(LTA),X(LFMO),X(LDTEMP),X(LFTEMP),
     *           X(LC),X(LY),X(LX),X(LWORK),X(LHF),X(LWAXC),
     *           X(LXX),X(LIX),X(LGHOND),X(LXINTS),X(LDSH),X(LDDIJ),IA,
     *           NOCC,NVIR,NORB,NOCC2,NORB2,NXYZ,NNXYZ,IJKT,
     *           NINTMX,NUM,NUM2,NFZC,NOCACT,NDER,MAXG,NSH2,MXG2)
C
      IF (NDER.EQ.1 .AND. NFZC.GT.0) THEN
         CALL DAWRIT(IDAF,IODA,X(LWAXC),NCVROT*NXYZ,304,0)
         IF(DBG) THEN
            WRITE(IW,*) '-WAXC- MATRIX AFTER -FCK- CONTRIBUTIONS'
            CALL PRSQ(X(LWAXC),NXYZ,NCVROT,NCVROT)
         END IF
      END IF
C
      IF(DBG) THEN
         WRITE(IW,*) 'COMPLETED -WAX- MATRIX, AFTER -FCK- CONTRIBUTIONS'
         CALL PRSQ(X(LWAX),NNXYZ,NROT,NROT)
         DO 130 IXYZ=1,NXYZ
            WRITE(IW,9973) IXYZ
            CALL PRTRI(X(LAA+NOCC2*(IXYZ-1)),NOCC)
  130    CONTINUE
      END IF
C
      CALL TSECND(TIM2)
      TIMFCK=TIM2-TIM1
      IF(SOME) WRITE(IW,9988) ' -FCK-  ',TIMFCK
C
C     ----- ADD - TB * AA - CONTRIBUTIONS TO -FCM- -----
C
      IF(NDER.EQ.2) THEN
         CALL CPWAB2(X(LFCM),X(LAA),X(LTA),IA,NOCC,NOCC2,NXYZ)
         IF(DBG) WRITE(IW,9991)
         IF(DBG) CALL CPFCM(X(LFCM),NAT)
      END IF
C
      CALL RETFM(NEED)
C
C     ----- CALCULATE -WXY- MATRIX AND SOLVE CPHF EQNS -----
C
      CALL TSECND(TIM1)
  135 CONTINUE
C
C  AO INTEGRAL DRIVEN METHOD
C
      IF (AODRV) THEN
         IF(CHFSLV.EQ.BLANK) CHFSLV=CONJG
C           NOTE THE FIRST THREE ARE INHERITED FROM ABOVE IN THIS ORDER
         LFCM   = LOADFM + 1
         LWAX   = LFCM   + NC3
         LC     = LWAX   + NROT*NNXYZ
         LYA    = LC     + NUM3
         LWRK1  = LYA    + NROT*NNXYZ
         LWRK2  = LWRK1  + NUM3
         LEIG   = LWRK2  + NUM3
         LGHOND = LEIG   + NUM
         LXINTS = LGHOND + MAXG
         LDSH   = LXINTS + NSH2
         LDDIJ  = LDSH   + NSH2
         LXX    = LDDIJ  + 16*MXG2
         LIX    = LXX    + INTMAX
         LDTEMP = LIX    + INTMAX
         LFTEMP = LDTEMP + NUM2*NUNIQ
         LAST   = LFTEMP + NUM2*NUNIQ
C
C           NOTE -LERR- WORKING STORAGE FOR DIIS OVERLAPS DTEMP/FTEMP
C
         IF(CHFSLV.EQ.DIIS) THEN
            MAXIO  = 2*MAXDII
            MAXIT  = 50+1
            MAXIT2 = (MAXIT*MAXIT+MAXIT)/2
            LAST = MAX(LAST,LDTEMP + NROT*NNXYZ)
            LERR   = LAST
            LYNEW  = LERR   + NROT*NNXYZ
            LADIIS = LYNEW  + NROT*NNXYZ
            LXDIIS = LADIIS + MAXDII*MAXDII
            LIPVT  = LXDIIS + MAXIT*NNXYZ
            LBDIIS = LIPVT  + MAXIT
            LIODII = LBDIIS + MAXIT2*NNXYZ
            LAST   = LIODII + MAXIO
         ELSE
            LRESID = LAST
            LZRES  = LRESID + NROT*NUNIQ
            LPDIR  = LZRES  + NROT*NUNIQ
            LPRCND = LPDIR  + NROT*NUNIQ
            LBNORM = LPRCND + NROT
            LBKNUM = LBNORM + NNXYZ
            LBKDEN = LBKNUM + NNXYZ
            LAST   = LBKDEN + NNXYZ
         END IF
C
         NEED = LAST - LOADFM - 1
C
         NDWXY = NEED
         IF(CHKMEM) GO TO 90
         CALL GETFM(NEED)
C
C        GET RHF ORBITAL ENERGIES, AND START SOLVING.
C
         CALL DAREAD(IDAF,IODA,X(LEIG),NUM,17,0)
C
         IF(CHFSLV.EQ.DIIS) THEN
            CALL AOCPDI(X(LWAX),X(LC),X(LYA),X(LYNEW),X(LDTEMP),
     *                  X(LFTEMP),X(LEIG),X(LWRK1),X(LWRK2),
     *                  X(LERR),X(LADIIS),X(LXDIIS),X(LIPVT),
     *                  X(LBDIIS),X(LIODII),X(LXX),X(LIX),X(LGHOND),
     *                  X(LXINTS),X(LDSH),X(LDDIJ),NOCP,
     *                  NROT,NNXYZ,NUNIQ,NOCC,NVIR,NUM,NUM2,NUM3,
     *                  MAXIT,MAXIT2,MAXIO,MAXG,NSH2,MXG2)
         ELSE
            CALL AOCPCG(X(LWAX),X(LYA),X(LRESID),X(LZRES),X(LPDIR),
     *                  X(LPRCND),X(LBNORM),X(LBKNUM),X(LBKDEN),
     *                  X(LC),X(LEIG),X(LDTEMP),X(LFTEMP),
     *                  X(LWRK1),X(LWRK2),NOCP,X(LGHOND),X(LXINTS),
     *                  X(LDSH),X(LDDIJ),X(LXX),X(LIX),
     *                  NNXYZ,NUNIQ,NXYZF,NFOCK,NROT,NOCC,NVIR,
     *                  NUM,NUM2,NUM3,NSH2,MAXG,MXG2)
         END IF
         NSOLV = NNXYZ
C
C        SAVE RESPONSE VECTORS AND OTHER INFO FOR EXTENDED TDHF JOBS.
C
         IF(IGETOLI(1).NE.0) THEN
          CALL SVGGA2(X(LEIG),X(LC),X(LYA),NROT,X(LWRK1),X(LWRK2),
     *            X(LDTEMP),X(LFTEMP),NUM2,
     *            X(LGHOND),X(LXINTS),X(LDSH),X(LDDIJ),X(LXX),X(LIX),
     *            MAXG,NSH2,MXG2)
         ENDIF
C
C  MO INTEGRAL DRIVEN METHOD
C
      ELSE
         LFCM = 1+LOADFM
         LWAX = LFCM + NC3
         LWII = LWAX + NROT*NNXYZ
         LAST = LWII + NROT
         IF(NDER.EQ.1) THEN
            LLAGR  = LAST
            LDLAGR = LLAGR  + NUM3
            LX     = LDLAGR + NROT
            LY     = LX     + NUM3
            LAST   = LY     + NUM3
         ELSE
            LLAGR  = LAST
            LDLAGR = LAST
            LX     = LAST
            LY     = LAST
         END IF
         IF(NDER.EQ.1 .AND. NFZC.GT.0) THEN
            LZCV   = LAST
            LWAXC  = LZCV   + NCVROT
            LPMN   = LWAXC  + NCVROT*NXYZ
            LXLMN  = LPMN   + NUM2
            LAST   = LXLMN  + NUM2
         ELSE
            LZCV   = LAST
            LWAXC  = LAST
            LPMN   = LAST
            LXLMN  = LAST
         END IF
C                         OVERLAP PART OF -WXY- FORMATION STORAGE...
         LE   = LAST
         LXX  = LE  + NUM
         LIX  = LXX + NINTMX
         LAST1= LIX + NINTMX
C                         ...WITH PART OF THE CPHF SOLUTION STORAGE...
         IF(NDER.EQ.2) THEN
            LYA  = LAST
            LAST2= LYA  + NROT*NNXYZ
         ELSE
            LYA  = LAST
            LAST2= LYA  + NROT
         END IF
C
         LAST = MAX(LAST1,LAST2)
         NNEED= LAST-LOADFM-1
         NFREE= NGOTMX-NNEED
C
C        FOR DEBUGGING, WE MAY WANT TO FORCE A PARTICULAR SOLVER.
C
         IF(CHFSLV.EQ.CONJG) MAXEQU=1
         IF(CHFSLV.EQ.ONDISK) THEN
            MAXEQU=1
            NFREE = NUM*NUM +2*NNXYZ +4*NNXYZ*NROT + (NROT*NROT+10)/2
         END IF
C
C        IF -WXY- IS VERY SMALL, WE SOLVE FOR ONE RESPONSE
C        AT A TIME.  THE CONJUGATE GRADIENT OPTION, IN OR OUT
C        OF CORE SOLVES FOR ALL RESPONSES SIMULTANEOUSLY TO
C        MINIMIZE DISK I/O ON THE EXTERNAL FILE OF -WXY-, OR
C        MEMORY ACCESSES ON -WXY-.
C        FOR 1ST DERIVATIVES, WE NEED SOLVE ONLY FOR THE Z-VECTOR.
C
         IF(NDER.EQ.1) THEN
            NSOLV = 1
         ELSE
            NSOLV = NNXYZ
         END IF
         IF(NROT.LE.MAXEQU) NSOLV=1
C
C         DECIDE IF PROBLEM FITS IN AVAILABLE MEMORY,
C         WATCH OUT FOR 32 BIT SYSTEMS
C
         DMY = 2.0D+00**31 - 2*NSOLV - 4*NROT*NSOLV - 1000
         N32MAX = INT(SQRT(DMY))
         IF(NWDVAR.EQ.1  .OR.  NROT.LE.N32MAX) THEN
            INMEM  = NROT*NROT + 2*NSOLV + 4*NROT*NSOLV
            INCORE = INMEM.LE.NFREE
            NDWXYI = NNEED + INMEM
         ELSE
            INMEM = 0
            INCORE = .FALSE.
            NDWXYI = 0
         END IF
C
C                         ...FOLLOWED BY MORE SOLVER STORAGE,
C                         WITH -WXY- ITSELF ALLOCATED LAST.
C
         IF(INCORE) THEN
            NWIDTH = NROT
            IF(SOME  .AND.  CHKMEM) WRITE(IW,9050)
            LIROT= LAST
            LBNRM= LAST
            LRESD= LBNRM + NSOLV
            LWRK1= LRESD + NSOLV
            LWRK2= LWRK1 + NROT*NSOLV
            LWRK3= LWRK2 + NROT*NSOLV
            LWRK4= LWRK3 + NROT*NSOLV
            LWXY = LWRK4 + NROT*NSOLV
            LAST = LWXY  + NROT*NROT
         ELSE
            NWIDTH = (NFREE - NUM*NUM - 2*NSOLV- 4*NROT*NSOLV)/NROT
            IF(NWIDTH.GT.0) THEN
               NSLICE = (NROT-1)/NWIDTH + 1
            ELSE
               NSLICE=-1
            END IF
            IF(NWIDTH.LE.0  .OR.  (NSLICE.GT.NAT .AND. NAT.GT.5)) THEN
               IF (MASWRK) THEN
                  NEEDX = NUM*NUM + 2*NSOLV + 4*NROT*NSOLV
                  NNEED = NNEED + NEEDX
                  NFREE = NFREE - NEEDX
                  NEEDW = (NROT-1)/(NAT-1)
                  NEED  = NNEED + NROT*NEEDW
                  WRITE(IW,9070) NWIDTH,NSLICE,NAT,NFREE,NNEED,NROT,NEED
               END IF
               CALL ABRT
               STOP
            END IF
            IF(SOME  .AND.  CHKMEM) WRITE(IW,9060) NSLICE,NWIDTH
            LIROT= LAST
            LBNRM= LIROT + NUM*NUM
            LRESD= LBNRM + NSOLV
            LWRK1= LRESD + NSOLV
            LWRK2= LWRK1 + NROT*NSOLV
            LWRK3= LWRK2 + NROT*NSOLV
            LWRK4= LWRK3 + NROT*NSOLV
            LWXY = LWRK4 + NROT*NSOLV
            LAST = LWXY  + NROT*NWIDTH
         END IF
C
         NEED = LAST - LOADFM - 1
         NDWXY = NEED
         IF(CHKMEM) GO TO 90
         CALL GETFM(NEED)
C
C        GET RHF ORBITAL ENERGIES
C
         CALL DAREAD(IDAF,IODA,X(LE),NUM,17,0)
C
C        COMPUTE ORBITAL HESSIAN
C
         IF(INCORE) THEN
            NWIDTH = NROT
            CALL CPWXYI(X(LWXY),X(LE),X(LXX),X(LIX),
     *                  NUM,NOCC,NVIR,IJKT,NINTMX)
            IF(DBG) THEN
               WRITE(IW,9998)
               CALL PRSQ(X(LWXY),NROT,NROT,NROT)
            END IF
         ELSE
            SVDSKW = DSKWRK
            DSKWRK = .FALSE.
            CALL SEQOPN(NFT16,'WORK16','UNKNOWN',.FALSE.,'UNFORMATTED')
            DSKWRK = SVDSKW
            CALL CPWXYO(X(LWXY),X(LE),X(LXX),X(LIX),X(LIROT),X(LWII),
     *                  NROT,NWIDTH,NUM,NOCC,NVIR,IJKT,NINTMX,NFT16,DBG)
         END IF
C
         CALL TSECND(TIM2)
         TIMWXY=TIM2-TIM1
         IF(SOME) THEN
            WRITE(IW,9988) ' -WXY-  ',TIMWXY
            CALL FLSHBF(IW)
         END IF
         TIM1 = TIM2
C
C        --- GET CI LAGRANGIAN XIJ FROM DAF ---
C       --- CONSTRUCT ITS ASYMMETRY (XIJ - XJI) ---
C
         IF(NDER.EQ.1) THEN
            CALL DAREAD(IDAF,IODA,X(LLAGR),NUM3,36,0)
            CALL XDELTA(X(LLAGR),X(LDLAGR),X(LZCV),X(LE),X(LX),X(LY),
     *                  X(LPMN),X(LXLMN),X(LXX),X(LIX),
     *                  NOCC,NVIR,NORB,NUM,NUM2,NUM3,NOCACT,NFZC,NINTMX)
         END IF
C
C        1ST DER: USE Z-VECTOR APPROACH FOR ONE RESPONSE.
C        2ND DER: SOLVE FOR SYMMETRY UNIQUE CPHF RESPONSE VECTORS
C        AT THIS POINT -NSOLV- SHOULD ALREADY BE SET CORRECTLY,
C        SO ALL WE NEED TO DO IS POINT AT THE CORRECT INHOMOGENEITY.
C
C        SOLVING IS DONE SEQUENTIALLY ON THE MASTER NODE AT PRESENT!
C
         NITER=0
         NPASS=0
         SVGPAR = GOPARR
         SVDSKW = DSKWRK
         GOPARR = .FALSE.
         DSKWRK = .FALSE.
         IF(MASWRK) THEN
            LINHMG = LWAX
            IF(NDER.EQ.1) LINHMG = LDLAGR
            IF(NDER.EQ.1) NNXYZ  = 1
            CALL SOLVCP(X(LWXY),X(LINHMG),X(LYA),NROT,NNXYZ,NOCP,
     *                  X(LWII),X(LWRK1),X(LWRK2),X(LWRK3),X(LWRK4),
     *                  X(LBNRM),X(LRESD),NITER,NPASS,NWIDTH,NSOLV,
     *                  INCORE,NFT16,MAXEQU)
C              OTHER NODES SHOULD ZERO SO -CPWAB3- MATH IS DEFINED.
         ELSE
            CALL VCLR(X(LYA),1,NROT*NNXYZ)
         END IF
         GOPARR = SVGPAR
         DSKWRK = SVDSKW
      END IF
C
C          END OF MO BASIS RESPONSE EQUATION SOLVING.
C
      IF(DBG) THEN
         WRITE(IW,*) 'CPHF RESPONSE VECTORS -YA-'
         CALL PRSQ(X(LYA),NNXYZ,NROT,NROT)
      END IF
C
C     --- FORM CI GRADIENT CONTRIBUTION FROM THE Z-VECTOR ---
C     --- FORM RELAXED CI DENSITY FROM THE Z-VECTOR ---
C
      IF(NDER.EQ.1) THEN
         IF(NFZC.GT.0) THEN
            CALL DAREAD(IDAF,IODA,X(LWAXC),NCVROT*NXYZ,304,0)
         END IF
         CALL ZGRDCI(X(LYA),X(LWAX),X(LWAXC),X(LZCV),NVIR,NOCC,
     *               NXYZ,NAT,NFZC,NOCACT)
         CALL ZDENCI(X(LYA),X(LLAGR),X(LZCV),X(LX),X(LY),
     *               NOCC,NUM,NUM2,NUM3,NVIR,NFZC,NOCACT)
      END IF
C
      CALL RETFM(NEED)
      CALL TSECND(TIM2)
      TIMYA=TIM2-TIM1
      IF(SOME) WRITE(IW,9988) ' -YA-   ',TIMYA
      IF(SOME  .AND.  .NOT.AODRV) THEN
         IF(NITER.GT.0) WRITE(IW,9080) NUNIQ,NITER
         IF(.NOT.INCORE) WRITE(IW,9090) NPASS
      END IF
C
      IF(NDER.EQ.1) GO TO 900
C
C     ----- ADD WAX * YB - CONTRIBUTIONS TO -FCM- -----
C
      LFCM = 1+LOADFM
      LWAX = LFCM + NC3
      LAST = LWAX + NROT*NNXYZ
      IF(AODRV) THEN
         ISKIP = NUM3
      ELSE
         ISKIP = NROT
      END IF
      LYA  = LAST + ISKIP
      LH   = LYA  + NROT*NNXYZ
      LDDM = LH   + NUM2*3
      LDDMA= LDDM + NAT*9
      LSK  = LDDMA+ NAT*9
      LAST = LSK  + NAT
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      CALL CPWAB3(X(LFCM),X(LWAX),X(LYA),X(LH),X(LDDM),IA,
     *            NROT,NXYZ,NNXYZ,NUM2,NOCC,NVIR)
      IF(DBG) WRITE(IW,9990)
      IF(DBG) CALL CPFCM(X(LFCM),NAT)
C
C     ---- ADD RESPONSE CONTRIBUTIONS TO DIPOLE DERIVATIVE ----
C
      IF(DBG) THEN
         WRITE(IW,9996)
         CALL DDMOUT(X(LDDM),3*NAT)
      END IF
      CALL DAREAD(IDAF,IODA,X(LDDMA),NAT*9,34,0)
      CALL VADD(X(LDDMA),1,X(LDDM),1,X(LDDMA),1,NAT*9)
      CALL DAWRIT(IDAF,IODA,X(LDDMA),NAT*9,34,0)
C
C     ---- SYMMETRIZE DIPOLE DERIVATIVE ----
C
      CALL CPSDDM(X(LDDMA),X(LSK),3*NAT)
C
C     ----- SYMMETRIZE -FCM- AND OUTPUT IT -----
C
      CALL CPSYM(X(LFCM),NC)
      IF(DBG) CALL CPFCM(X(LFCM),NAT)
      CALL DAWRIT(IDAF,IODA,X(LFCM),NC3,4,0)
      CALL RETFM(NEED)
C
  900 CONTINUE
      RETURN
C
 9998 FORMAT(' -WXY- MATRIX ')
 9994 FORMAT(' -TA- MATRIX ',I5)
 9992 FORMAT(' ADD T(A) * T(B) CONTRIBUTION TO -FCM- ')
 9991 FORMAT(' ADD T(A) * AA(B) CONTRIBUTION TO -FCM- ')
 9995 FORMAT(/10X,34("-")/
     *        10X,'OVERLAP DERIVATIVE CONTRIBUTION TO'/
     *        10X,34(1H-))
 9996 FORMAT(/10X,31("-")/
     *        10X,'RESPONSE FACTOR CONTRIBUTION TO'/
     *        10X,31(1H-))
 9990 FORMAT(' ADD WAX * YA CONTRIBUTION TO -FCM- ')
 9988 FORMAT(1X,'       TIME FOR',A8,'= ',F12.3)
 9976 FORMAT(' AFTER -DFMO- CONTRIBUTION TO -AA- ',I3)
 9973 FORMAT(' AFTER -FCK- CONTRIBUTION TO -AA- ',I3)
 9000 FORMAT(/5X,43("-")/
     *        5X,'COUPLED-PERTURBED CLOSED SHELL HARTREE-FOCK'/
     *        5X,43(1H-))
 9005 FORMAT(/10X,'...... USING THE Z VECTOR METHOD ......')
 9010 FORMAT(1X,'THE CPHF HAS',I8,' INDEPENDENT ORBITAL ROTATIONS.')
 9015 FORMAT(1X,'SOLVING FOR',I5,' NUCLEAR RESPONSES AND',I2,
     *          ' ELECTRIC FIELD RESPONSES')
 9020 FORMAT(10X,' -FA- WILL USE',I10,' WORDS,'/
     *       10X,' -TA- WILL USE',I10,' WORDS,'/
     *       10X,'-FCK- WILL USE',I10,' WORDS,'/
     *        1X,'-WXY- AND -YA- WILL USE',I10,' WORDS,'/
     *       10X,'     THERE ARE',I10,' WORDS AVAILABLE.')
 9030 FORMAT(1X,'IN MEMORY FORMATION OF -WXY- WOULD REQUIRE',I10,
     *          ' WORDS')
 9040 FORMAT(1X,'NOT ENOUGH MEMORY TO DO CPHF, NEED=',I10,' GOT=',I10)
 9050 FORMAT(1X,'CHOOSING IN MEMORY CPHF ALGORITHM')
 9060 FORMAT(1X,'CHOOSING OUT OF MEMORY CPHF ALGORITHM,'/
     *   1X,'-WXY- WILL BE FORMED IN',I5,' SLICES OF',I7,' COLUMNS.')
 9070 FORMAT(/1X,'*** NOT ENOUGH MEMORY TO RUN THE OUT OF MEMORY',
     *          ' CPHF CODE ***'/
     *       1X,'NWIDTH=',I10,'  NSLICE=',I10,'   NAT=',I10/
     *       1X,' NFREE=',I10,'   NNEED=',I10,'  NROT=',I10//
     *       1X,'INCREASE MEMORY IN $SYSTEM TO AT LEAST',I10/
     *       1X,'LARGER AMOUNTS OF MEMORY ARE EVEN BETTER!')
 9080 FORMAT(1X,'SOLVING FOR ALL',I4,' UNIQUE RESPONSES TOOK',
     *          I5,' CG UPDATES.')
 9090 FORMAT(1X,'CONJUGATE GRADIENT SOLVER MADE',I4,
     *          ' READS OF THE EXTERNALLY STORED -WXY-')
      END
C*MODULE HESS    *DECK CPSDDM
      SUBROUTINE CPSDDM(DDM,SKIP,NCOORD)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION DDM(3,NCOORD)
      DIMENSION V(3,3)
C
      LOGICAL SKIP(NAT),OUT,GOPARR,DSKWRK,MASWRK
      PARAMETER (MXSH=1000, MXATM=500)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SYMSPD/ PTR(3,144),DTR(6,288),FTR(10,480),GTR(15,720)
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                TDMY(432),INVT(48),NT
C
      PARAMETER (ZERO=0.0D+00, TM9=1.0D-09)
C
C     ----- SYMMETRIZE THE DIPOLE DERIVATIVE TENSOR -----
C
      OUT = NPRINT.EQ.1 .AND. MASWRK
C
C     ----- GET RAW DIPOLE DERIVATIVE MATRIX -----
C
      CALL DAREAD(IDAF,IODA,DDM,3*NCOORD,34,0)
      IF(OUT) WRITE(IW,9020)((DDM(I,J),I=1,3),J=1,NCOORD)
C
C     ----- GET TRANFORMATION MATRICES OF COORDINATES. -----
C
      IF(NT.EQ.1) GO TO 400
      CALL DAREAD(IDAF,IODA,PTR,432,7,0)
C
C     ---- SEE WHICH BLOCKS HAVE ALREADY BEEN COMPUTED ----
C
      DO 220 IC = 1,NAT
         SKIP(IC) = .FALSE.
         DO 210 IT = 1,NT
            IF (MAPCTR(IC,IT) .GT. IC) GO TO 220
  210    CONTINUE
         SKIP(IC) = .TRUE.
  220 CONTINUE
C
C     ----- SYMMETRIZE DIPOLE DERIVATIVES -----
C
      DO 360 IC = 1,NAT
         IF(.NOT.SKIP(IC)) GO TO 360
         DO 340 IT = 1,NT
            ICNU = MAPCTR(IC,IT)
            IF(SKIP(ICNU)) GO TO 340
            INDX = 3*(IC-1)
            N = 3*(IT-1)
            DO 280 JT = 1,3
               DO 260 L=1,3
                  DUM = ZERO
                  DO 240 M=1,3
                     DUM = DUM + DDM(JT,INDX+M)*PTR(L,N+M)
  240             CONTINUE
                  V(JT,L) = DUM
  260          CONTINUE
  280       CONTINUE
            INDX = 3*(ICNU-1)
            DO 320 JT = 1,3
               DO 310 L=1,3
                  DUM = ZERO
                  DO 300 M=1,3
                     DUM = DUM + PTR(JT,N+M)*V(M,L)
  300             CONTINUE
                  DDM(JT,INDX+L) = DUM
  310          CONTINUE
  320       CONTINUE
            SKIP(ICNU) = .TRUE.
  340    CONTINUE
  360 CONTINUE
C
C     ---- CONVERT TO DEBYE/ANGSTROM, ZERO OUT VERY SMALL VALUES ----
C
  400 CONTINUE
      DO 420 I=1,NAT*3
         DO 410 J=1,3
            DDM(J,I)=DDM(J,I)*4.803242D+00
            IF(ABS(DDM(J,I)).LT.TM9) DDM(J,I)=ZERO
  410    CONTINUE
  420 CONTINUE
C
C     ----- STORE IT ON THE DAF -----
C
      CALL DAWRIT(IDAF,IODA,DDM,3*NCOORD,34,0)
      RETURN
C
 9020 FORMAT(/' RAW DIPOLE DERIVATIVE MATRIX'/(3E15.6))
      END
C*MODULE CPHF    *DECK CPTA
      SUBROUTINE CPTA(NDER,WAX,TA,C,E,DSAO,DSMO,T,DS,SDIDER,F,H,
     *                WAXC,IA,NUM,NOCC,NVIR,NORB,NUM2,NOCC2,NXYZ,
     *                NAT,NFZC,NOCACT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C        SDIDER,F,H NEEDED ONLY FOR RHF 2ND DERIVATIVE
C
      DIMENSION WAX(NOCC,NVIR,NXYZ),TA(NOCC2,NXYZ),C(NUM,NUM),E(NUM),
     *          DSAO(NUM2,NXYZ),DSMO(NUM2),T(NUM),DS(NUM,NUM,3),IA(NUM),
     *          SDIDER(9*NAT),F(NUM2),H(NUM2,3),WAXC(NFZC,NOCACT,NXYZ)
C
      PARAMETER (MXGTOT=5000, MXSH=1000)
C
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(400)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
C
      PARAMETER (PT5=0.5D+00, FOUR=4.0D+00, TWO=2.0D+00, ZERO=0.0D+00)
C
C     ----- COMPUTE DS/DA IN THE MO BASIS -----
C
      CALL VCLR(DSAO,1,NUM2*NXYZ)
C
      DO 150 ISHELL = 1,NSHELL
         IAT  = KATOM(ISHELL)
         IXYZ = 3*(IAT-1)
         LOCI = KLOC(ISHELL) - KMIN(ISHELL)
         MINI = KMIN(ISHELL)
         MAXI = KMAX(ISHELL)
         DO 140 I = MINI,MAXI
            II   = LOCI + I
            DO 130 JJ = 1,NUM
               IJ = IA(MAX(II,JJ)) + MIN(II,JJ)
               DSAO(IJ,IXYZ+1) = DSAO(IJ,IXYZ+1) + DS(II,JJ,1)
               DSAO(IJ,IXYZ+2) = DSAO(IJ,IXYZ+2) + DS(II,JJ,2)
               DSAO(IJ,IXYZ+3) = DSAO(IJ,IXYZ+3) + DS(II,JJ,3)
  130       CONTINUE
  140    CONTINUE
  150 CONTINUE
C
C     ---- GET DIPOLE INTEGRALS AND TRANSFORM TO MO BASIS   ----
C     ---- WRITE TRANSFORMED INTEGRALS TO DAF FOR LATER USE ----
C
      IF(NDER.EQ.2) THEN
         CALL DAREAD(IDAF,IODA,F,NUM2,95,0)
         CALL TFTRI(H(1,1),F,C,T,NORB,NUM,NUM)
         CALL DAREAD(IDAF,IODA,F,NUM2,96,0)
         CALL TFTRI(H(1,2),F,C,T,NORB,NUM,NUM)
         CALL DAREAD(IDAF,IODA,F,NUM2,97,0)
         CALL TFTRI(H(1,3),F,C,T,NORB,NUM,NUM)
C
         CALL DAWRIT(IDAF,IODA,H(1,1),NUM2,252,0)
         CALL DAWRIT(IDAF,IODA,H(1,2),NUM2,253,0)
         CALL DAWRIT(IDAF,IODA,H(1,3),NUM2,254,0)
      END IF
C
      DO 500 IXYZ=1,NXYZ
         CALL TFTRI(DSMO,DSAO(1,IXYZ),C,T,NORB,NUM,NUM)
C
C     ----- SET -TA- -----
C
         DO 220 IOCC=1,NOCC
            DO 210 JOCC=1,IOCC
               IJ=IA(IOCC)+JOCC
               TA(IJ,IXYZ)=(-PT5)*DSMO(IJ)
  210       CONTINUE
  220    CONTINUE
C
C     ----- CONTRIBUTION TO THE INHOMOGENEITY -----
C
         DO 320 IVIR=1,NVIR
            DO 310 IOCC=1,NOCC
               IJ=IA(IVIR+NOCC)+IOCC
               WAX(IOCC,IVIR,IXYZ)=WAX(IOCC,IVIR,IXYZ)
     *                            -FOUR*DSMO(IJ)*E(IOCC)
  310       CONTINUE
  320    CONTINUE
C
         IF (NDER.EQ.1 .AND. NFZC.GT.0) THEN
            DO 340 IACT=1,NOCACT
               DO 330 IFZC=1,NFZC
                  IJ=IA(IACT+NFZC)+IFZC
                  WAXC(IFZC,IACT,IXYZ)=WAXC(IFZC,IACT,IXYZ)
     *                               -FOUR*DSMO(IJ)*E(IFZC)
  330          CONTINUE
  340       CONTINUE
         END IF
C
C     ----- CONTRIBUTION TO DIPOLE DERIVATIVE -----
C
         IF(NDER.EQ.2) THEN
            NN=1 + (IXYZ-1)*3
            SDIDER(NN  )=ZERO
            SDIDER(NN+1)=ZERO
            SDIDER(NN+2)=ZERO
            DO 440 IOCC=1,NOCC
               DO 430 JOCC=1,IOCC
                  IJ=IA(IOCC)+JOCC
                  VAL=DSMO(IJ)
                  IF (IOCC .NE. JOCC) VAL= VAL + VAL
                  SDIDER(NN  )=SDIDER(NN  )+(TWO*VAL*H(IJ,1))
                  SDIDER(NN+1)=SDIDER(NN+1)+(TWO*VAL*H(IJ,2))
                  SDIDER(NN+2)=SDIDER(NN+2)+(TWO*VAL*H(IJ,3))
  430          CONTINUE
  440       CONTINUE
         END IF
  500 CONTINUE
      RETURN
      END
C*MODULE CPHF    *DECK CPSYM
      SUBROUTINE CPSYM(A,NC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION A(NC,NC)
      DIMENSION T(3,3),U(3,3),V(3,3)
C
      PARAMETER (MXSH=1000, MXATM=500)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(400)
      COMMON /SYMSPD/ PTR(3,144),DTR(6,288),FTR(10,480),GTR(15,720)
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                TDMY(432),INVT(48),NT
C
      DATA ZERO,ONE,TWO /0.0D+00,1.0D+00,2.0D+00/
C
C     ----- SYMMETRIZE THE HESSIAN MATRIX -----
C     READ IN TRANFORMATION MATRICES OF COORDINATES.
C
      CALL DAREAD(IDAF,IODA,PTR,432,7,0)
C
C     ----- FILL IN SYMMETRY EQUIVALENT BLOCKS -----
C
      DO 400 JAT=1,NAT
      DO 310 IT=1,NT
      IF(MAPCTR(JAT,IT).GT.JAT) GO TO 400
  310 CONTINUE
      DO 390 IAT=1,NAT
      LOCI=3*(IAT-1)
      LOCJ=3*(JAT-1)
      DO 320 J=1,3
      DO 320 I=1,3
  320 T(I,J)=A(LOCI+I,LOCJ+J)
C
      DO 380 IT=1,NT
      KAT=MAPCTR(IAT,IT)
      LAT=MAPCTR(JAT,IT)
      N=3*(INVT(IT)-1)
      DO 340 L=1,3
      DO 340 K=1,3
      DUM=ZERO
      DO 330 M=1,3
  330 DUM=DUM+T(K,M)*PTR(M,L+N)
  340 U(K,L)=DUM
      DO 360 L=1,3
      DO 360 K=1,3
      DUM=ZERO
      DO 350 M=1,3
  350 DUM=DUM+PTR(M,K+N)*U(M,L)
  360 V(K,L)=DUM
      LOCK=3*(KAT-1)
      LOCL=3*(LAT-1)
      DO 370 L=1,3
      DO 370 K=1,3
  370 A(LOCK+K,LOCL+L)=V(K,L)
  380 CONTINUE
C
  390 CONTINUE
  400 CONTINUE
C
      DO 410 I=1,NC
      DO 410 J=1,I
      SUM =(A(I,J)+A(J,I))/TWO
      A(J,I)=SUM
  410 A(I,J)=SUM
C
      IF(NT.EQ.1) RETURN
C
C     ----- SYMMETRIZE HESSIAN MATRIX -----
C
      DO 800 IC = 1,NAT
      DO 700 JC = 1,NAT
C
C     ----- APPLY PROJECTION OPERATOR -----
C
      DO 510 J  = 1,3
      DO 510 I  = 1,3
  510 V(I,J) = ZERO
C
      DO 570 IT = 1,NT
      KC = MAPCTR(IC,IT)
      LC = MAPCTR(JC,IT)
C
      LOCL=3*(LC-1)
      LOCK=3*(KC-1)
      DO 520 L = 1,3
      DO 520 K = 1,3
  520 T(K,L) = A(LOCK+K,LOCL+L)
      N = 3*(IT-1)
      DO 540 L = 1,3
      DO 540 K = 1,3
      SUM = ZERO
      DO 530 M = 1,3
  530 SUM = SUM + T(K,M) * PTR(M,L+N)
  540 U(K,L) = SUM
      DO 560 K = 1,3
      DO 560 L = 1,3
      SUM = ZERO
      DO 550 M = 1,3
  550 SUM = SUM + PTR(M,K+N) * U(M,L)
  560 V(K,L) = V(K,L) + SUM
  570 CONTINUE
C
      FAC = ONE / NT
      LOCJ=3*(JC-1)
      LOCI=3*(IC-1)
      DO 580 J = 1,3
      DO 580 I = 1,3
  580 V(I,J) = V(I,J) * FAC
C
C     ----- REMAP PROJECTED BLOCK ONTO EQUIVALENT BLOCKS -----
C
      DO 660 IT = 1,NT
      KC = MAPCTR(IC,IT)
      LC = MAPCTR(JC,IT)
C
      N = 3*(INVT(IT) - 1)
      DO 620 L = 1,3
      DO 620 K = 1,3
      SUM = ZERO
      DO  610 M = 1,3
  610 SUM = SUM + V(K,M) * PTR(M,L+N)
  620 U(K,L) = SUM
      DO 640 L = 1,3
      DO 640 K = 1,3
      SUM = ZERO
      DO 630 M = 1,3
  630 SUM = SUM + PTR(M,K+N) * U(M,L)
  640 T(K,L) = SUM
C
      LOCL=3*(LC-1)
      LOCK=3*(KC-1)
      DO 650 L = 1,3
      DO 650 K = 1,3
  650 A(LOCK+K,LOCL+L) = T(K,L)
  660 CONTINUE
C
  700 CONTINUE
  800 CONTINUE
C
C     ----- END OF SYMMETRIZATION -----
C
      RETURN
      END
C*MODULE CPHF    *DECK CPWAB0
      SUBROUTINE CPWAB0(FCM,EH,NAT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION EH(9,*),FCM(*)
C
C     EXPAND HESSIAN TO FULL SQUARE STORAGE.
C
      DO 210 IAT=1,NAT
         DO 200 JAT=1,IAT
            IJAT=(IAT*(IAT-1))/2+JAT
            IJC=0
            DO 110 IC=1,3
               DO 100 JC=1,3
                  IJC=IJC+1
                  I=3*(IAT-1)+IC
                  J=3*(JAT-1)+JC
                  IJ=I+3*NAT*(J-1)
                  JI=J+3*NAT*(I-1)
                  FCM(IJ)=EH(IJC,IJAT)
                  FCM(JI)=EH(IJC,IJAT)
  100          CONTINUE
  110       CONTINUE
  200    CONTINUE
  210 CONTINUE
      RETURN
      END
C*MODULE CPHF    *DECK CPWAB1
      SUBROUTINE CPWAB1(FCM,TA,E,IA,NOCC,NOCC2,NXYZ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION FCM(NXYZ,NXYZ),TA(NOCC2,NXYZ),E(*),IA(*)
C
      PARAMETER (ZERO=0.0D+00, EIGHT=8.0D+00)
C
C     ----- ADD (EI+EJ)*TA*TB CONTRIBUTION TO HESSIAN -----
C
      DO 210 IXYZ=1,NXYZ
         DO 200 JXYZ=1,IXYZ
            DUM=ZERO
            DO 110 IOCC=1,NOCC
               DO 100 JOCC=1,NOCC
                  IJ=IA(MAX(IOCC,JOCC))+MIN(IOCC,JOCC)
                  DUM=DUM+(E(IOCC)+E(JOCC))*TA(IJ,IXYZ)*TA(IJ,JXYZ)
  100          CONTINUE
  110       CONTINUE
            DUM=DUM*EIGHT
            FCM(IXYZ,JXYZ)=FCM(IXYZ,JXYZ)+DUM
            IF(JXYZ.EQ.IXYZ) GO TO 200
            FCM(JXYZ,IXYZ)=FCM(JXYZ,IXYZ)+DUM
  200    CONTINUE
  210 CONTINUE
      RETURN
      END
C*MODULE CPHF    *DECK CPWAB2
      SUBROUTINE CPWAB2(FCM,AA,TA,IA,NOCC,NOCC2,NXYZ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION FCM(NXYZ,NXYZ),TA(NOCC2,NXYZ),AA(NOCC2,NXYZ),IA(*)
C
      PARAMETER (ZERO=0.0D+00)
C
C     ----- ADD T(A)*A(B) + T(B)*A(A) CONTRIBUTION TO HESSIAN -----
C
      DO 210 IXYZ=1,NXYZ
         DO 200 JXYZ=1,IXYZ
            DUM=ZERO
            DO 110 IOCC=1,NOCC
               DO 100 JOCC=1,NOCC
                  IJ=IA(MAX(IOCC,JOCC))+MIN(IOCC,JOCC)
                  DUM=DUM + TA(IJ,IXYZ)*AA(IJ,JXYZ)
     *                    + TA(IJ,JXYZ)*AA(IJ,IXYZ)
  100          CONTINUE
  110       CONTINUE
            FCM(IXYZ,JXYZ)=FCM(IXYZ,JXYZ)+DUM
            IF(JXYZ.EQ.IXYZ) GO TO 200
            FCM(JXYZ,IXYZ)=FCM(JXYZ,IXYZ)+DUM
  200    CONTINUE
  210 CONTINUE
      RETURN
      END
C*MODULE CPHF    *DECK CPWAB3
      SUBROUTINE CPWAB3(FCM,WAX,YA,H,DDM,IA,NROT,NXYZ,NNXYZ,
     *                  NUM2,NOCC,NVIR)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL POLAR
C
      PARAMETER (MXATM=500)
C
      DIMENSION FCM(NXYZ,NXYZ),WAX(NROT,NNXYZ),
     *          YA(NROT,NNXYZ),H(NUM2,3)
      DIMENSION DDM(9*NAT),IA(NUM)
      DIMENSION APOL(6)
C
      COMMON /CHFINF/ CHFSLV,CPTYPE,NWDCHF,POLAR
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(400)
C
      PARAMETER (ZERO=0.0D+00, FOUR=4.0D+00)
C
C     ----- ADD FINAL CPHF WAX(A)*Y(B) CONTRIBUTION TO HESSIAN -----
C
      DO 210 IXYZ=1,NXYZ
         DO 200 JXYZ=1,NXYZ
            DUM=ZERO
            DO 100 IROT=1,NROT
               DUM=DUM+WAX(IROT,IXYZ)*YA(IROT,JXYZ)
  100       CONTINUE
            FCM(IXYZ,JXYZ)=FCM(IXYZ,JXYZ)+DUM
  200    CONTINUE
  210 CONTINUE
C
C     ---- GET TRANSFORMED DIPOLE INTEGRALS AND CALCULATE RESPONSE ----
C     ---- FACTOR CONTRIBUTION TO DIPOLE DERIVATIVE                ----
C
      CALL DAREAD(IDAF,IODA,H(1,1),NUM2,252,0)
      CALL DAREAD(IDAF,IODA,H(1,2),NUM2,253,0)
      CALL DAREAD(IDAF,IODA,H(1,3),NUM2,254,0)
C
      CALL VCLR(DDM,1,9*NAT)
C
      DO 340 IXYZ=1,NXYZ
         NN= 1 + (IXYZ-1)*3
         IROT=0
         DO 360 IVIR=1,NVIR
            DO 370 IOCC=1,NOCC
               IROT=IROT + 1
               IJ=IA(IVIR+NOCC)+IOCC
               DDM(NN  )=DDM(NN  )-(FOUR*YA(IROT,IXYZ)*H(IJ,1))
               DDM(NN+1)=DDM(NN+1)-(FOUR*YA(IROT,IXYZ)*H(IJ,2))
               DDM(NN+2)=DDM(NN+2)-(FOUR*YA(IROT,IXYZ)*H(IJ,3))
  370       CONTINUE
  360    CONTINUE
  340 CONTINUE
C
C     ---- CALCULATE ALPHA POLARIZABILITY TENSOR ----
C
      IF(POLAR) THEN
         DO 400 K=1,3
            DO 410 L=1,K
            KL=IA(K)+L
            APOL(KL)=ZERO
            IROT=0
               DO 420 IVIR=1,NVIR
                  DO 430 IOCC=1,NOCC
                     IROT=IROT + 1
                     IJ=IA(IVIR+NOCC)+IOCC
                     APOL(KL)=APOL(KL)-(FOUR*YA(IROT,NXYZ+K)*H(IJ,L))
  430             CONTINUE
  420          CONTINUE
  410       CONTINUE
  400 CONTINUE
C
C     ---- WRITE ALPHA POLARIZABILITY TENSOR TO DAF ----
C
      CALL DAWRIT(IDAF,IODA,APOL,6,251,0)
C
      END IF
C
      RETURN
      END
C*MODULE CPHF    *DECK CPWXYI
      SUBROUTINE CPWXYI(WXY,E,XX,IX,L1,NOCC,NVIR,NFTI,NINTMX)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION WXY(NOCC,NVIR,NOCC,NVIR),E(L1),XX(NINTMX),IX(*)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
C
      PARAMETER (FOUR=4.0D+00)
C
C     ----- COMPUTE ORBITAL HESSIAN -WXY- MATRIX -----
C               USING AN IN MEMORY ALGORITHM
C
      CALL VCLR(WXY,1,NOCC*NVIR*NOCC*NVIR)
C
C     ----- READ IN MO INTEGRALS TO CREATE -WXY- MATRIX -----
C     TRANSFORMED INTEGRALS ASSUMED IN REVERSE CANONICAL ORDER
C
      CALL SEQREW(NFTI)
      IF(MASWRK) READ(NFTI)
  100 CONTINUE
      CALL PREAD(NFTI,XX,IX,NX,NINTMX)
      IF(NX.EQ.0) GO TO 300
      MX=IABS(NX)
      IF(MX.GT.NINTMX) GO TO 9000
C
C     ----- UNPACK LABELS AND PROCESS INTEGRALS -----
C
      DO 200 M = 1,MX
      VAL   = XX(M)
C
                       NPACK = M
                       IF (LABSIZ .EQ. 2) THEN
#if !defined(SPEC_CPU_ILP64)
                         LABEL1 = IX( 2*NPACK - 1 )
                         LABEL2 = IX( 2*NPACK     )
                         IPACK = ISHFT( LABEL1, -16 )
                         JPACK = IAND( LABEL1, 65535 )
                         KPACK = ISHFT( LABEL2, -16 )
                         LPACK = IAND( LABEL2, 65535 )
#endif
#if defined(SPEC_CPU_ILP64)
                         LABEL = IX(NPACK)
                         IPACK = ISHFT( LABEL, -48 )
                         JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
                         KPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
                         LPACK = IAND( LABEL, 65535 )
#endif
                       ELSE IF (LABSIZ .EQ. 1) THEN
#if !defined(SPEC_CPU_ILP64)
                         LABEL = IX(NPACK)
                         IPACK = ISHFT( LABEL, -24 )
                         JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
                         KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
                         LPACK = IAND( LABEL, 255 )
#endif
#if defined(SPEC_CPU_ILP64)
                         IF ( MOD(NPACK,2) .EQ. 0 ) THEN
                           LABEL = IX( NPACK/2 )
                           IPACK = IAND( ISHFT( LABEL, -24 ), 255 )
                           JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
                           KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
                           LPACK = IAND( LABEL, 255 )
                         ELSE
                           LABEL = IX( (NPACK/2)+1 )
                           IPACK = ISHFT( LABEL, -56 )
                           JPACK = IAND( ISHFT( LABEL, -48 ), 255 )
                           KPACK = IAND( ISHFT( LABEL, -40 ), 255 )
                           LPACK = IAND( ISHFT( LABEL, -32 ), 255 )
                         END IF
#endif
                       END IF
                       K = IPACK
                       L = JPACK
                       I = KPACK
                       J = LPACK
C
      II = MAX(I,J)
      JJ = MIN(I,J)
      KK = MAX(K,L)
      LL = MIN(K,L)
      IF(KK.LT.II) GO TO 180
      IF(KK.EQ.II.AND.LL.LE.JJ) GO TO 180
      NN = II
      II = KK
      KK = NN
      NN = JJ
      JJ = LL
      LL = NN
  180 CONTINUE
C
      IF(II.LE.NOCC) GO TO 200
      IF(JJ.LE.NOCC) GO TO 190
      IF(KK.GT.NOCC) GO TO 200
C
C     ----- ( VIR VIR / OCC OCC ) -----
C
      WXY(KK,II-NOCC,LL,JJ-NOCC)=WXY(KK,II-NOCC,LL,JJ-NOCC)-VAL
      IF(JJ.EQ.II.OR.LL.EQ.KK) GO TO 200
      WXY(LL,II-NOCC,KK,JJ-NOCC)=WXY(LL,II-NOCC,KK,JJ-NOCC)-VAL
      GO TO 200
C
C     ----- ( VIR OCC / VIR OCC ) -----
C
  190 CONTINUE
      IF(KK.LE.NOCC) GO TO 200
      IF(LL.GT.NOCC) GO TO 200
      WXY(JJ,II-NOCC,LL,KK-NOCC)=WXY(JJ,II-NOCC,LL,KK-NOCC)+VAL*FOUR
      IF(KK.EQ.II) THEN
         WXY(JJ,KK-NOCC,LL,II-NOCC)=WXY(JJ,KK-NOCC,LL,II-NOCC)-VAL
      ELSE
         WXY(LL,II-NOCC,JJ,KK-NOCC)=WXY(LL,II-NOCC,JJ,KK-NOCC)-VAL
      END IF
C
  200 CONTINUE
      IF(NX .GT. 0) GO TO 100
C
C         DONE WITH INTEGRAL CONTRIBUTIONS TO -WXY-
C
  300 CONTINUE
      CALL SEQREW(NFTI)
      IF(GOPARR) CALL GSUMCP(2102,WXY,NOCC*NVIR*NOCC*NVIR)
C
C     ----- COMPLETE -WXY- MATRIX CONSTRUCTION -----
C     ADD ORBITAL ENERGY TERM, AND SYMMETRIZE THE MATRIX
C
      DO 320 IVIR=1,NVIR
         DO 310 IOCC=1,NOCC
            WXY(IOCC,IVIR,IOCC,IVIR) = WXY(IOCC,IVIR,IOCC,IVIR)
     *                               + (E(IVIR+NOCC)-E(IOCC))
  310    CONTINUE
  320 CONTINUE
C
      DO 370 IVIR=1,NVIR
         DO 360 IOCC=1,NOCC
            DO 350 JVIR=1,IVIR
               JOMAX = NOCC
               IF(JVIR.EQ.IVIR) JOMAX = IOCC
               DO 340 JOCC=1,JOMAX
                  WXY(IOCC,IVIR,JOCC,JVIR) =
     *                                  FOUR*WXY(IOCC,IVIR,JOCC,JVIR)
                  WXY(JOCC,JVIR,IOCC,IVIR) = WXY(IOCC,IVIR,JOCC,JVIR)
  340          CONTINUE
  350       CONTINUE
  360    CONTINUE
  370 CONTINUE
      RETURN
C
 9000 IF (MASWRK) WRITE(6,9999) MX,NINTMX
      CALL ABRT
      STOP
C
 9999 FORMAT(1X,'*** ERROR, MX=',I10,' EXCEEDS NINTMX=',I10)
      END
C*MODULE CPHF    *DECK CPWXYO
      SUBROUTINE CPWXYO(WXY,E,XX,IX,IROT,WXYII,NROT,NWIDTH,L1,
     *                  NOCC,NVIR,NFTI,NINTMX,NFT16,DBG)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL DBG,GOPARR,DSKWRK,MASWRK,SVDSKW
C
      DIMENSION WXY(NROT,NWIDTH),WXYII(NROT),IROT(L1,L1),E(L1),
     *          XX(NINTMX),IX(*)
C
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
C
      PARAMETER (HALF=0.5D+00, FOUR=4.0D+00)
C
C     ----- COMPUTE ORBITAL HESSIAN -WXY- MATRIX -----
C             USING AN OUT OF MEMORY ALGORITHM
C
      MROT = 0
      DO 50 I=1,NOCC+NVIR
         DO 40 J=1,I
            IF(I.GT.NOCC  .AND.  J.LE.NOCC) THEN
               MROT = MROT+1
               IROT(I,J) = MROT
               IROT(J,I) = MROT
            ELSE
               IROT(I,J) = 0
               IROT(J,I) = 0
            END IF
   40    CONTINUE
   50 CONTINUE
      IF(MROT.NE.NROT) THEN
         IF(MASWRK) WRITE(IW,9030) MROT,NROT,NOCC,L1
         CALL ABRT
      END IF
      NVIR = L1-NOCC
C
      IF(MASWRK) REWIND NFT16
C
      KOL2 = 0
  100 CONTINUE
      KOL0 = KOL2
      KOL1 = KOL2 + 1
      KOL2 = KOL2 + NWIDTH
      IF(KOL2.GT.NROT) KOL2=NROT
      NCOL = KOL2 - KOL0
C
      CALL VCLR(WXY,1,NROT*NCOL)
C
C     ----- READ IN MO INTEGRALS TO CREATE -WXY- MATRIX -----
C     TRANSFORMED INTEGRALS ASSUMED IN REVERSE CANONICAL ORDER
C
      CALL SEQREW(NFTI)
      IF(MASWRK) READ(NFTI)
  170 CONTINUE
      CALL PREAD(NFTI,XX,IX,NX,NINTMX)
      IF(NX.EQ.0) GO TO 300
      MX=IABS(NX)
      IF(MX.GT.NINTMX) GO TO 9000
C
C     ----- UNPACK LABELS AND PROCESS INTEGRALS -----
C
      DO 200 M = 1,MX
      VAL   = XX(M)
C
                       NPACK = M
                       IF (LABSIZ .EQ. 2) THEN
#if !defined(SPEC_CPU_ILP64)
                         LABEL1 = IX( 2*NPACK - 1 )
                         LABEL2 = IX( 2*NPACK     )
                         IPACK = ISHFT( LABEL1, -16 )
                         JPACK = IAND( LABEL1, 65535 )
                         KPACK = ISHFT( LABEL2, -16 )
                         LPACK = IAND( LABEL2, 65535 )
#endif
#if defined(SPEC_CPU_ILP64)
                         LABEL = IX(NPACK)
                         IPACK = ISHFT( LABEL, -48 )
                         JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
                         KPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
                         LPACK = IAND( LABEL, 65535 )
#endif
                       ELSE IF (LABSIZ .EQ. 1) THEN
#if !defined(SPEC_CPU_ILP64)
                         LABEL = IX(NPACK)
                         IPACK = ISHFT( LABEL, -24 )
                         JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
                         KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
                         LPACK = IAND( LABEL, 255 )
#endif
#if defined(SPEC_CPU_ILP64)
                         IF ( MOD(NPACK,2) .EQ. 0 ) THEN
                           LABEL = IX( NPACK/2 )
                           IPACK = IAND( ISHFT( LABEL, -24 ), 255 )
                           JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
                           KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
                           LPACK = IAND( LABEL, 255 )
                         ELSE
                           LABEL = IX( (NPACK/2)+1 )
                           IPACK = ISHFT( LABEL, -56 )
                           JPACK = IAND( ISHFT( LABEL, -48 ), 255 )
                           KPACK = IAND( ISHFT( LABEL, -40 ), 255 )
                           LPACK = IAND( ISHFT( LABEL, -32 ), 255 )
                         END IF
#endif
                       END IF
                       K = IPACK
                       L = JPACK
                       I = KPACK
                       J = LPACK
C
      II = MAX(I,J)
      JJ = MIN(I,J)
      KK = MAX(K,L)
      LL = MIN(K,L)
      IF(KK.LT.II) GO TO 180
      IF(KK.EQ.II.AND.LL.LE.JJ) GO TO 180
      NN = II
      II = KK
      KK = NN
      NN = JJ
      JJ = LL
      LL = NN
  180 CONTINUE
      IF(II.LE.NOCC) GO TO 200
C
      IF(JJ.LE.NOCC) GO TO 190
      IF(KK.GT.NOCC) GO TO 200
C
C     ----- ( VIR VIR / OCC OCC ) -----
C
      IKROT = IROT(I,K)
      JLROT = IROT(J,L)
      IF(JLROT.GE.KOL1  .AND.  JLROT.LE.KOL2)
     *   WXY(IKROT,JLROT-KOL0) = WXY(IKROT,JLROT-KOL0) - VAL
      IF(IKROT.GE.KOL1  .AND.  IKROT.LE.KOL2)
     *   WXY(JLROT,IKROT-KOL0) = WXY(JLROT,IKROT-KOL0) - VAL
C
      IF(JJ.EQ.II.OR.LL.EQ.KK) GO TO 200
      ILROT = IROT(I,L)
      JKROT = IROT(J,K)
      IF(JKROT.GE.KOL1  .AND.  JKROT.LE.KOL2)
     *   WXY(ILROT,JKROT-KOL0) = WXY(ILROT,JKROT-KOL0) - VAL
      IF(ILROT.GE.KOL1  .AND.  ILROT.LE.KOL2)
     *   WXY(JKROT,ILROT-KOL0) = WXY(JKROT,ILROT-KOL0) - VAL
      GO TO 200
C
C     ----- ( VIR OCC / VIR OCC ) -----
C
  190 CONTINUE
      IF(KK.LE.NOCC) GO TO 200
      IF(LL.GT.NOCC) GO TO 200
      IJROT = IROT(I,J)
      KLROT = IROT(K,L)
      ILROT = IROT(I,L)
      JKROT = IROT(J,K)
      IF(KLROT.GE.KOL1  .AND.  KLROT.LE.KOL2)
     *   WXY(IJROT,KLROT-KOL0) = WXY(IJROT,KLROT-KOL0) + VAL*FOUR
      IF(IJROT.GE.KOL1  .AND.  IJROT.LE.KOL2)
     *   WXY(KLROT,IJROT-KOL0) = WXY(KLROT,IJROT-KOL0) + VAL*FOUR
      IF(JKROT.GE.KOL1  .AND.  JKROT.LE.KOL2)
     *   WXY(ILROT,JKROT-KOL0) = WXY(ILROT,JKROT-KOL0) - VAL
      IF(ILROT.GE.KOL1  .AND.  ILROT.LE.KOL2)
     *   WXY(JKROT,ILROT-KOL0) = WXY(JKROT,ILROT-KOL0) - VAL
C
  200 CONTINUE
      IF(NX .GT. 0) GO TO 170
C
C     ----- COMPLETE -WXY- MATRIX CONSTRUCTION -----
C     HALVE DIAGONAL, ADD ORBITAL ENERGY TERM, SCALE BY 4
C
  300 CONTINUE
      CALL SEQREW(NFTI)
      IF(GOPARR) CALL GSUMCP(2103,WXY,NROT*NCOL)
C
      MROT = 0
      DO 320 IVIR=1,NVIR
         DO 310 IOCC=1,NOCC
            MROT = MROT+1
            IF(MROT.LT.KOL1) GO TO 310
            IF(MROT.GT.KOL2) GO TO 310
            WXY(MROT,MROT-KOL0) = HALF*WXY(MROT,MROT-KOL0)
     *                          + (E(IVIR+NOCC)-E(IOCC))
  310    CONTINUE
  320 CONTINUE
C
      CALL DSCAL(NROT*NCOL,FOUR,WXY,1)
      IF(DBG) THEN
         WRITE(IW,9050) KOL1,KOL2
         CALL PRSQ(WXY,NCOL,NROT,NROT)
      END IF
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
      CALL SQWRIT(NFT16,WXY,NROT*NCOL)
      DSKWRK = SVDSKW
C
C         STORE DIAGONAL ELEMENT FOR LATER USE BY SOLVER
C
      DO 410 JROT=KOL1,KOL2
         WXYII(JROT) = WXY(JROT,JROT-KOL1+1)
  410 CONTINUE
      IF(KOL2.LT.NROT) GO TO 100
C
      IF(MASWRK) REWIND NFT16
      RETURN
C
 9000 IF (MASWRK) WRITE(IW,9999) MX,NINTMX
      CALL ABRT
      STOP
C
 9999 FORMAT(1X,'*** ERROR, MX=',I10,' EXCEEDS NINTMX=',I10)
 9050 FORMAT(1X,'SLICE OF -WXY- MATRIX FOR ROTATIONS',I5,' TO',I5)
 9030 FORMAT(1X,'UNEXPECTED INTERNAL TRAP ENCOUNTERED IN CPWXYO'/
     *       1X,'UNEXPECTEDLY, MROT.NE.NROT, MROT=',I10,' NROT=',I10/
     *       1X,'EXTRA INFO IS NOCC,L1=',2I10)
      END
C*MODULE CPHF    *DECK AOCPCL
      SUBROUTINE AOCPCL(WAX,C,YA,YNEW,RHS,DTEMP,FTEMP,EIG,WRK1,WRK2,
     *                  XX,IX,GHONDO,XINTS,DSH,DDIJ,NOCP,MODE,
     *                  NNXYZ,NUNIQ,NXYZF,NFOCK,NINT,NSCHWZ,
     *                  NROT,NOCC,NVIR,L1,L2,L3,NSH2,MAXG,MXG2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION WAX(NROT,NNXYZ),C(L1,L1),YA(NROT,NNXYZ),
     *          YNEW(NROT,NNXYZ),RHS(NROT,NUNIQ),
     *          DTEMP(NUNIQ*L2),FTEMP(NUNIQ*L2),
     *          WRK1(L1,L1),WRK2(L3),EIG(L1),NOCP(NNXYZ),
     *          GHONDO(MAXG),XINTS(NSH2),DSH(NSH2),DDIJ(16*MXG2),
     *          XX(*),IX(*)
C
C        --- CLOSED SHELL FOCK-LIKE MATRICES FOR CPHF EQUATIONS ---
C        WE CAN COMPUTE EITHER THE RIGHT HAND SIDE A*YA IN -RHS-
C        OR THE IMPROVED SOLUTION -YNEW- DEPENDING ON THE CALL -MODE-.
C        ONLY ONE OF -YNEW- OR -RHS- SHOULD BE ALLOCATED STORAGE.
C        THE VALUE -MODE- EQUALS 0 IS FOR THE DIIS SOLVER, WHILE
C        THE PCG SOLVER USES 1 AND 2 FOR ITS CALLS.
C
C        COUNT HOW MANY FOCK-LIKE MATRICES ARE NEEDED ON THIS ITERATION
C        -NXYZF- SHOULD BE LESS OR EQUAL TO -NUNIQ-
C
      NXYZF = 0
      DO 110 IXYZ = 1,NNXYZ
         IF (NOCP(IXYZ).EQ.0) NXYZF = NXYZF+1
  110 CONTINUE
      NFOCK = NFOCK+NXYZF
C
C        TRANSFORM CURRENT GUESS AT SOLUTION -YA- TO THE AO BASIS
C        THE RESULT ARE "DENSITY-LIKE MATRICES" STORED IN -DTEMP-
C
      IXYZF = 0
      IUNIQ = 0
      DO 270 IXYZ = 1,NNXYZ
         IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
         IF(NOCP(IXYZ).NE.0) GO TO 270
         IXYZF = IXYZF+1
C
                       IKOL = IXYZ
         IF(MODE.EQ.2) IKOL = IUNIQ
         CALL MRARTR(YA(1,IKOL),NOCC,NOCC,NVIR,C(1,NOCC+1),
     *               L1,L1,WRK2,L1)
         CALL MRARBR(C,L1,L1,NOCC,WRK2,L1,L1,WRK1,L1)
C
         IJ = 0
         DO 260 I=1,L1
            DO 250 J=1,I
               DTEMP(IXYZF+IJ) = WRK1(I,J) + WRK1(J,I)
               IJ = IJ + NXYZF
  250       CONTINUE
  260    CONTINUE
  270 CONTINUE
C
C  BUILD THE CORRESPONDING "FOCK-LIKE MATRICES" IN -FTEMP-
C
      CALL AOFLM2(DTEMP,FTEMP,GHONDO,XINTS,DSH,DDIJ,XX,IX,
     *            L1,NXYZF,MAXG,NSH2,MXG2,NINT,NSCHWZ)
C
C  TRANSFORM BACK INTO THE MO BASIS
C
      IXYZF = 0
      IUNIQ = 0
      DO 390 IXYZ = 1,NNXYZ
         IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
         IF(NOCP(IXYZ).NE.0) GO TO 390
C
         IXYZF = IXYZF+1
         CALL DCOPY(L2,FTEMP(IXYZF),NXYZF,WRK1,1)
         CALL EXPND(WRK1,WRK2,L1,0)
         CALL MRARBR(WRK2,L1,L1,L1,C(1,NOCC+1),L1,NVIR,WRK1,L1)
         CALL MRTRBR(C,L1,L1,NOCC,WRK1,L1,NVIR,WRK2,NOCC)
C
C     FORM THE NEW RESPONSE VECTOR.
C     NOTE THAT THE FACTOR OF 8 IS THE 2 FROM EQUATION 13 AND
C     ANOTHER TWO TAKING INTO ACCOUNT THE SYMMETRY OF THE TRANSFORMATION
C     (HAVE TWO TERMS THAT ARE SYMMETRIC, I CALCULATED ONE
C      AND NEED TO MULTIPLY BY TWO WHICH I AM DOING HERE)
C
         IF(MODE.EQ.0) THEN
            IJ = 0
            DO 320 IVIR = NOCC+1,NOCC+NVIR
               DO 310 IOCC= 1,NOCC
                  IJ = IJ + 1
                  YNEW(IJ,IXYZ) = (-WAX(IJ,IXYZ) - 8.0D+00*WRK2(IJ)) /
     *                            (4.0D+00*(EIG(IVIR) - EIG(IOCC)))
  310          CONTINUE
  320       CONTINUE
         ELSE
            IJ = 0
                          IKOL = IXYZ
            IF(MODE.EQ.2) IKOL = IUNIQ
            DO 360 IVIR = NOCC+1,NOCC+NVIR
               DO 350 IOCC= 1,NOCC
                  IJ = IJ + 1
                  RHS(IJ,IUNIQ) = 8.0D+00*WRK2(IJ)
     *                  + (4.0D+00*(EIG(IVIR) - EIG(IOCC)))*YA(IJ,IKOL)
  350          CONTINUE
  360       CONTINUE
         END IF
  390 CONTINUE
C
      RETURN
      END
C*MODULE CPHF    *DECK AOSHLD
      SUBROUTINE AOSHLD(D,DSH,IA,L1,L2,NSH2,NFO)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION D(NFO,L2),DSH(NSH2),IA(L1)
C
      PARAMETER (MXSH=1000, MXGTOT=5000)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
      PARAMETER (ZERO=0.0D+00)
C
C     ----- COMPRESS DENSITY OVER AOS TO DENSITY OVER SHELLS -----
C
      IJSH=0
      DO 240 ISH=1,NSHELL
         MINI = KLOC(ISH)
         MAXI = MINI + KMAX(ISH) - KMIN(ISH)
         DO 230 JSH=1,ISH
            MINJ = KLOC(JSH)
            MAXJ = MINJ + KMAX(JSH) - KMIN(JSH)
            IJSH = IJSH+1
            DMAX = ZERO
            DO 130 I=MINI,MAXI
               IF(ISH.EQ.JSH) MAXJ=I
               DO 120 J=MINJ,MAXJ
                  IJ = IA(I) + J
                  DO 110 IFO=1,NFO
                     IF(ABS(D(IFO,IJ)).GT.DMAX) DMAX = ABS(D(IFO,IJ))
  110             CONTINUE
  120          CONTINUE
  130       CONTINUE
            DSH(IJSH) = DMAX
  230    CONTINUE
  240 CONTINUE
      RETURN
      END
C*MODULE CPHF    *DECK AOFLM2
      SUBROUTINE AOFLM2(PMN,FMN,GHONDO,XINTS,DSH,DDIJ,BUF,IBUF,
     *                  NBF,NXYZ,MAXG,NSH2,MXG2,NINT,NSCHWZ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL PACK2E,SCHWRZ,DIRSCF,FDIFF,SHLOUT,TDSKWRK
C
      DIMENSION PMN(*), FMN(*), GHONDO(MAXG), XINTS(NSH2), DSH(NSH2),
     *          DDIJ(16*MXG2), BUF(NINTMX), IBUF(NINTMX)
C
      PARAMETER (MXSH=1000, MXATM=500, MXAO=2047)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTG76
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(400)
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SHLT  / SHLTOL,CUTOFF,ICOUNT,SHLOUT
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
C
      PARAMETER (HALF=0.5D+00)
C
#if !defined(SPEC_CPU_NO_HOLLERITH)
      DATA RHF/8HRHF     /
#else
      CHARACTER*8 :: RHF_STR
      EQUIVALENCE (RHF, RHF_STR)
      DATA RHF_STR/"RHF     "/
#endif
C
C           NOW FORM FOCK-LIKE MATRIX
C           DIRECT METHOD = RECOMPUTE 2E- AO INTEGRALS
C           STANDARD METHOD = PROCESS INTEGRALS FROM DISK
C           WE NEED TO TEMPORARILY TURN OFF SYMMETRY
C
      NTTEMP = NT
      NT = 1
      L1 = NBF
      L2 = (NBF*NBF+NBF)/2
      NINT  =0
      NSCHWZ=0
C
      IF(DIRSCF) THEN
         SCHWRZ = ISCHWZ.EQ.1
         IF(SCHWRZ) THEN
            CALL DAREAD(IDAF,IODA,XINTS,NSH2,54,0)
            CALL AOSHLD(PMN,DSH,IA,L1,L2,NSH2,NXYZ)
         END IF
         CALL VCLR(FMN,1,NXYZ*L2)
         CUTSV  = CUTOFF
         CUTOFF = MIN(CUTOFF,1.0D-10)
         CALL TWOEI(RHF,DIRSCF,.FALSE.,.FALSE.,.FALSE.,
     *              INTG76,SCHWRZ,NINT,NSCHWZ,L1,L2,
     *              DUMMY,DUMMY,IDUMMY,1,XINTS,NSH2,GHONDO,
     *              MAXG,DDIJ,IA,PMN,FMN,DUMMY,DUMMY,DSH,
     *              DUMMY,DUMMY,NXYZ)
         CUTOFF = CUTSV
         CALL DSCAL(NXYZ*L2,HALF,FMN,1)
         II=0
         DO 210 I=1,L1
            II = II+I
            IJ = (II-1)*NXYZ+1
            DO 200 J=0,NXYZ-1
               FMN(IJ+J) = FMN(IJ+J) + FMN(IJ+J)
  200       CONTINUE
  210    CONTINUE
C
      ELSE
         TDSKWRK = DSKWRK
         DSKWRK  = .TRUE.
         CALL SEQREW(IJK)
         CALL AOHST2(PMN,FMN,BUF,IBUF,NINTMX,IA,NOPK,NXYZ)
         DSKWRK  = TDSKWRK
      END IF
C
C   --- SUM UP PARTIAL FOCK MATRICES ---
C
      IF(GOPARR) THEN
         CALL DDI_GSUMF(1000,FMN   ,NXYZ*L2)
         CALL DDI_GSUMI(1001,NINT  ,1)
         CALL DDI_GSUMI(1002,NSCHWZ,1)
      END IF
C
C        RESTORE THE VALUE OF NT (SYMMETRY)
C
      NT = NTTEMP
      RETURN
      END
C*MODULE CPHF    *DECK AOHST2
      SUBROUTINE AOHST2(D,F,XX,IX,NINTMX,IA,NOPK,NXYZ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=500)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /ORDOPT/ NORDER(7)
      COMMON /PCKLAB/ LABSIZ
C
      DIMENSION D(NXYZ,*),F(NXYZ,*),IA(*),XX(NINTMX),IX(*)
C
      PARAMETER (HALF=0.5D+00)
C
C     ----- ROUTINE HSTAR FORMS THE SKELETON MATRIX
C                   F=( H' + H )/2
C
C              F(I,J)=(H**(I,J) + H**(J,I))/2
C
C     INDICES IN LABELS ARE IN STANDARD ORDER_
C      I.GE.J , K.GE.L , (IJ).GE.(KL)
C
C     ALL CONTRIBUTIONS ARE MADE INTO LOWER HALF OF
C     SKELETON MATRIX.
C     ONLY OFF-DIAGONAL ELEMENTS NEED BE DIVIDED BY TWO,
C     TO OBTAIN THE CORRECT F MATRIX.
C
      NUMTRI = NXYZ*(NUM*NUM+NUM)/2
      CALL VCLR(F,1,NUMTRI)
      I = 0
      J = 0
      K = 0
      L = 0
      NXX = 0
C jray: NOTE: this code is different from kit-68 version !!
#if defined(SPEC_CPU_ILP64)
      MASK32 = 2**32 - 1
#endif
      IF (NOPK .NE. 1) GO TO 300
C
C     ----- INTEGRALS ARE NOT IN SUPERMATRIX FORM (NOPK=.TRUE.) -----
C
  120 CONTINUE
      CALL PREAD(IS,XX,IX,NXX,NINTMX)
      IF (NXX .EQ. 0) GO TO 220
      NINT = IABS(NXX)
      IF (NINT .GT. NINTMX) CALL ABRT
      DO 200 M = 1,NINT
C
                       NPACK = M
                       IF (LABSIZ .EQ. 2) THEN
#if !defined(SPEC_CPU_ILP64)
                         LABEL1 = IX( 2*NPACK - 1 )
                         LABEL2 = IX( 2*NPACK     )
                         IPACK = ISHFT( LABEL1, -16 )
                         JPACK = IAND( LABEL1, 65535 )
                         KPACK = ISHFT( LABEL2, -16 )
                         LPACK = IAND( LABEL2, 65535 )
#endif
#if defined(SPEC_CPU_ILP64)
                         LABEL = IX(NPACK)
                         IPACK = ISHFT( LABEL, -48 )
                         JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
                         KPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
                         LPACK = IAND( LABEL, 65535 )
#endif
                       ELSE IF (LABSIZ .EQ. 1) THEN
#if !defined(SPEC_CPU_ILP64)
                         LABEL = IX(NPACK)
                         IPACK = ISHFT( LABEL, -24 )
                         JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
                         KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
                         LPACK = IAND( LABEL, 255 )
#endif
#if defined(SPEC_CPU_ILP64)
                         IF ( MOD(NPACK,2) .EQ. 0 ) THEN
                           LABEL = IX( NPACK/2 )
                           IPACK = IAND( ISHFT( LABEL, -24 ), 255 )
                           JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
                           KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
                           LPACK = IAND( LABEL, 255 )
                         ELSE
                           LABEL = IX( (NPACK/2)+1 )
                           IPACK = ISHFT( LABEL, -56 )
                           JPACK = IAND( ISHFT( LABEL, -48 ), 255 )
                           KPACK = IAND( ISHFT( LABEL, -40 ), 255 )
                           LPACK = IAND( ISHFT( LABEL, -32 ), 255 )
                         END IF
#endif
                       END IF
                       I = IPACK
                       J = JPACK
                       K = KPACK
                       L = LPACK
C
         VAL = XX(M)
         NIJ = IA(I)+J
         NKL = IA(K)+L
         IF (NORDER(7) .NE. 1) GO TO 130
C
C           USING SQUARE CANONICAL INTEGRAL FILE
C
         IF (NKL .GT. NIJ) GO TO 200
            IF (I .EQ. J) VAL=VAL*HALF
            IF (K .EQ. L) VAL=VAL*HALF
            IF (NIJ .EQ. NKL) VAL=VAL*HALF
C
  130 CONTINUE
      NIK = IA(I)+K
      NIL = IA(I)+L
      IF (J .LT. K) GO TO 140
      NJK = IA(J)+K
      NJL = IA(J)+L
      GO TO 180
C
  140 NJK = IA(K)+J
      IF (J .LT. L) GO TO 160
      NJL = IA(J)+L
      GO TO 180
C
  160 NJL = IA(L)+J
  180 CONTINUE
      VAL4 = (VAL+VAL)+(VAL+VAL)
      DO 190 IXYZ=1,NXYZ
        F(IXYZ,NIJ) = F(IXYZ,NIJ)+VAL4*D(IXYZ,NKL)
        F(IXYZ,NKL) = F(IXYZ,NKL)+VAL4*D(IXYZ,NIJ)
        F(IXYZ,NIK) = F(IXYZ,NIK)-VAL*D(IXYZ,NJL)
        F(IXYZ,NIL) = F(IXYZ,NIL)-VAL*D(IXYZ,NJK)
        F(IXYZ,NJK) = F(IXYZ,NJK)-VAL*D(IXYZ,NIL)
        F(IXYZ,NJL) = F(IXYZ,NJL)-VAL*D(IXYZ,NIK)
  190 CONTINUE
  200 CONTINUE
C
      IF (NXX .GT. 0) GO TO 120
C
C     DONE CONSTRUCTING MATRIX, OFF DIAGONAL ELEMENTS NEED HALVING
C
  220 CONTINUE
      CALL DSCAL(NUMTRI,HALF,F,1)
      II = 0
      DO 260 I=1,NUM
        II = II + I
        DO 250 IXYZ=1,NXYZ
           F(IXYZ,II) = F(IXYZ,II)+F(IXYZ,II)
  250   CONTINUE
  260 CONTINUE
      CALL SEQREW(IS)
      RETURN
C     ******
C
C     ----- INTEGRALS ARE IN SUPERMATRIX FORM (NOPK=.FALSE.) -----
C
  300 CONTINUE
      NIJ=0
      DO 310 M = 1,NUM
        NIJ = NIJ+M
        DO 305 IXYZ=1,NXYZ
          D(IXYZ,NIJ) = D(IXYZ,NIJ)*HALF
  305  CONTINUE
  310 CONTINUE
C
C     ---- SCALAR PROCESSING OF THE P INTEGRAL FILE -----
C
  320 CONTINUE
      CALL PREAD(IS,XX,IX,NXX,NINTMX)
      IF (NXX .EQ. 0) GO TO 400
C
      NINT = IABS(NXX)
      IF (NINT .GT. NINTMX) CALL ABRT
C
      DO 330 M = 1,NINT
C
                     NPACK = M
                     IF (LABSIZ .EQ. 2) THEN
#if !defined(SPEC_CPU_ILP64)
                       IPACK = IX( 2*NPACK - 1 )
                       JPACK = IX( 2*NPACK     )
#endif
#if defined(SPEC_CPU_ILP64)
                       LABEL = IX(NPACK)
                       IPACK = ISHFT( LABEL, -32 )
                       JPACK = IAND( LABEL, MASK32 )
#endif
                     ELSE IF (LABSIZ .EQ. 1) THEN
#if !defined(SPEC_CPU_ILP64)
                       LABEL = IX(NPACK)
                       IPACK = ISHFT( LABEL, -16 )
                       JPACK = IAND( LABEL, 65535 )
#endif
#if defined(SPEC_CPU_ILP64)
                       IF ( MOD(NPACK,2) .EQ. 0 ) THEN
                         LABEL = IX( NPACK/2 )
                         IPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
                         JPACK = IAND( LABEL, 65535 )
                       ELSE
                         LABEL = IX( (NPACK/2)+1 )
                         IPACK = ISHFT( LABEL, -48 )
                         JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
                       END IF
#endif
                     END IF
                     NIJ = IPACK
                     NKL = JPACK
C
         VAL = XX(M)
         DO 325 IXYZ=1,NXYZ
           F(IXYZ,NIJ) = F(IXYZ,NIJ) + VAL*D(IXYZ,NKL)
           F(IXYZ,NKL) = F(IXYZ,NKL) + VAL*D(IXYZ,NIJ)
  325    CONTINUE
  330 CONTINUE
      IF (NXX .GT. 0) GO TO 320
C
C     ----- RESTORE DENSITY MATRIX, HALVE FOCK MATRIX -----
C
  400 CONTINUE
      NIJ = 0
      DO 410 M = 1,NUM
        NIJ = NIJ+M
        DO 405 IXYZ=1,NXYZ
          D(IXYZ,NIJ) = D(IXYZ,NIJ)+D(IXYZ,NIJ)
  405   CONTINUE
  410 CONTINUE
C
      CALL DSCAL(NUMTRI,HALF,F,1)
      CALL SEQREW(IS)
      RETURN
      END
C*MODULE CPHF    *DECK AOCPCG
      SUBROUTINE AOCPCG(WAX,YA,RESID,ZRES,PDIR,
     *                  PRECND,BNORM,BKNUM,BKDEN,
     *                  VEC,EIG,DTEMP,FTEMP,WRK1,WRK2,
     *                  NOCP,GHONDO,XINTS,DSH,DDIJ,XX,IX,
     *                  NNXYZ,NUNIQ,NXYZF,NFOCK,NROT,NOCC,NVIR,
     *                  L1,L2,L3,NSH2,MAXG,MXG2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION WAX(NROT,NNXYZ),YA(NROT,NNXYZ),RESID(NROT,NUNIQ),
     *          ZRES(NROT,NUNIQ),PDIR(NROT,NUNIQ),PRECND(NROT),
     *          BNORM(NNXYZ),BKNUM(NNXYZ),BKDEN(NNXYZ),
     *          VEC(L1,L1),EIG(L1),DTEMP(NUNIQ,L2),FTEMP(NUNIQ,L2),
     *          WRK1(L1,L1),WRK2(L1,L1),NOCP(NNXYZ),
     *          GHONDO(MAXG),XINTS(NSH2),DSH(NSH2),DDIJ(16*MXG2),
     *          XX(*),IX(*)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DIRSCF,FDIFF
C
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(400)
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00, TOL=5.0D-05)
C
      DATA MAXIT/50/
C
C        --- SOLVE MULTIPLE SETS OF LINEAR EQUATIONS A*YA+WAX=0 ---
C        THIS ROUTINE USES THE ORDINARY PRECONDITIONED CONJUGATE
C        GRADIENT PROCEDURE.  NOTE THAT "ORDINARY" MEANS -A- IS A
C        POSITIVE DEFINITE SYMMETRIC MATRIX, I.E. THE ORBITAL HESSIAN.
C        THE DIMENSION OF -A- IS -NROT-, AND THERE ARE -NNXYZ- COLUMNS
C        IN BOTH THE INHOMOGENEITY (WHICH IS THE NEGATIVE OF -WAX-)
C        AND IN THE -YA- RESPONSE VECTORS BEING SOLVED FOR.  ONLY
C        -NUNIQ- RESPONSES ARE REQUIRED, DEPENDING ON SYMMETRY, WITH
C        THE LIST -NOCP- NAMING WHICH RESPONSES ARE ACTUALLY NEEDED.
C
C        WRITTEN BY MIKE SCHMIDT, AT TOKYO TORITSU DAIGAKU, JAN 2001.
C        THIS ROUTINE WAS INSPIRED BY -DCG- WRITTEN BY ANNE GREENBAUM
C        AND MARK SEEGER, IN THE SPARSE LINEAR ALGEBRA PACKAGE -SLAP-
C        WHICH WAS DOWNLOADED FROM NETLIB.
C        EXTENSIVE MODIFICATIONS HAVE BEEN MADE, EXCEPT TO THE ACTUAL
C        SOLVING TECHNIQUE, TO SUPPORT THE NEEDS OF QUANTUM CHEMISTRY.
C        MULTIPLE SOLUTIONS ARE SOUGHT, WITH THE A*YA MULTIPLICATIONS
C        DONE SIMULTANEOUSLY, ALTHOUGH EACH SOLVING REMAINS SEPARATE.
C        THE PRECONDITIONER CHOSEN IS THE RECIPROCAL OF THE DIAGONAL
C        ELEMENTS, APPROXIMATED IN THE SAME WAY AS GALINA CHABAN'S
C        SECOND ORDER SCF CONVERGER, SEE EQUATION 1.17 IN G.CHABAN,
C        M.W.SCHMIDT, M.S.GORDON, THEORET.CHIM.ACTA 97, 88-95(1997).
C        NOTE THAT AN APPROXIMATION IS NEEDED SINCE THE MATRIX A IS
C        NEVER GENERATED, INSTEAD PRODUCTS A*YA ARE FORMED DIRECTLY.
C        THE INITIAL GUESS WAS SUGGESTED BY JAN JENSEN, IT AMOUNTS
C        TO ASSUMING THE INITIAL RESPONSES ARE ZERO SO THAT THE
C        INTEGRAL CONTRIBUTIONS TO THE A MATRIX VANISH, LEAVING A
C        SIMPLE REARRANGEMENT TO PRODUCE THE INITIAL GUESS USED HERE.
C        CONVERGENCE CRITERION WAS SELECTED BY NUMERICAL EXPERIMENT.
C        FOR FURTHER INFORMATION, SEE THE COMMENTS IN THE ORIGINAL
C        SLAP LIBRARY ROUTINES, AND THE "NUMERICAL RECIPES" BOOK.
C        ANOTHER INTERESTING REFERENCE IS P.E.S.WORMER, F.VISSER,
C        J.PALDUS, J.COMPUT.PHYS. 48, 23-44(1982).
C
C        SET UP PRECONDITIONER AND INITIAL GUESS OF RESPONSES
C
      IROT = 0
      DO 130 IVIR = NOCC+1,NOCC+NVIR
         DO 120 IOCC= 1,NOCC
            IROT = IROT + 1
            PRECND(IROT) = 1.0D+00/(4.0D+00*(EIG(IVIR) - EIG(IOCC)))
            FACTOR = -PRECND(IROT)
            DO 110 IXYZ = 1,NNXYZ
               YA(IROT,IXYZ) = FACTOR * WAX(IROT,IXYZ)
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C         THE INITIAL ITERATION IS DONE BEFORE THE MAIN LOOP,
C         CALCULATE INITIAL ITERATION'S RESIDUAL -RESID-
C
      NFOCK = 0
      MODE = 1
      DUMMY = ZERO
      ITER=1
      CALL AOCPCL(WAX,VEC,YA,DUMMY,RESID,DTEMP,FTEMP,EIG,WRK1,WRK2,
     *            XX,IX,GHONDO,XINTS,DSH,DDIJ,NOCP,MODE,
     *            NNXYZ,NUNIQ,NXYZF,NFOCK,NINT,NSCHWZ,
     *            NROT,NOCC,NVIR,L1,L2,L3,NSH2,MAXG,MXG2)
C
      IUNIQ=0
      DO 160 IXYZ=1,NNXYZ
         IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
         IF(NOCP(IXYZ).NE.0) GO TO 160
         DO 150 IROT=1,NROT
            RESID(IROT,IUNIQ) =  -WAX(IROT,IXYZ) - RESID(IROT,IUNIQ)
  150    CONTINUE
  160 CONTINUE
C
C        CALCULATE INITIAL PSEUDORESIDUAL -ZRES-, CHECK CONVERGENCE
C
      ERR = ZERO
      IUNIQ=0
      DO 210 IXYZ=1,NNXYZ
         IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
         IF(NOCP(IXYZ).NE.0) GO TO 210
         DO IROT=1,NROT
            ZRES(IROT,IUNIQ) = PRECND(IROT)*RESID(IROT,IUNIQ)
         ENDDO
         BNORM(IXYZ)=SQRT(DDOT(NROT,  WAX(1, IXYZ),1,  WAX(1, IXYZ),1))
         RNORM      =SQRT(DDOT(NROT,RESID(1,IUNIQ),1,RESID(1,IUNIQ),1))
         TEST = RNORM/BNORM(IXYZ)
         IF(TEST.LT.TOL) NOCP(IXYZ)=2
         ERR = MAX(ERR,TEST)
  210 CONTINUE
      IF(MASWRK) THEN
         WRITE(IW,9000) TOL
         IF(DIRSCF) THEN
            WRITE(IW,9010)
            WRITE(IW,9020) ITER,ERR,NXYZF,NINT,NSCHWZ
         ELSE
            WRITE(IW,9030)
            WRITE(IW,9020) ITER,ERR,NXYZF
         END IF
         CALL FLSHBF(IW)
      END IF
      IF(ERR.LT.TOL) GO TO 800
C
C        THE REMAINING CG ITERATIONS START NOW...
C
      MODE=2
      BKDEN(1) = 1.0D+00   ! REMOVES SPURIOUS FTNCHEK COMPLAINT
      DO 400 ITER=2,MAXIT
C
C           CALCULATE COEFFICIENT -BK- AND DIRECTION VECTOR -PDIR-
C
         IUNIQ=0
         DO 320 IXYZ=1,NNXYZ
            IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
            IF(NOCP(IXYZ).NE.0) GO TO 320
            BKNUM(IXYZ) = DDOT(NROT,ZRES(1,IUNIQ),1,RESID(1,IUNIQ),1)
            IF(BKNUM(IXYZ).LE.-TOL) THEN
               IF(MASWRK) WRITE(IW,9040)
               CALL ABRT
            END IF
            IF(ITER.EQ.2) THEN
               CALL DCOPY(NROT,ZRES(1,IUNIQ),1,PDIR(1,IUNIQ),1)
            ELSE
               BK = BKNUM(IXYZ)/BKDEN(IXYZ)
               DO IROT=1,NROT
                  PDIR(IROT,IUNIQ) =    ZRES(IROT,IUNIQ)
     *                             + BK*PDIR(IROT,IUNIQ)
               ENDDO
            END IF
            BKDEN(IXYZ) = BKNUM(IXYZ)
  320    CONTINUE
C
C           CALCULATE COEFFICIENT -AK-, NEW ITERATE -YA-,
C           NEW RESIDUAL -RESID-, AND NEW PSEUDO-RESIDUAL -ZRES-.
C
         CALL AOCPCL(WAX,VEC,PDIR,DUMMY,ZRES,DTEMP,FTEMP,EIG,WRK1,WRK2,
     *               XX,IX,GHONDO,XINTS,DSH,DDIJ,NOCP,MODE,
     *               NNXYZ,NUNIQ,NXYZF,NFOCK,NINT,NSCHWZ,
     *               NROT,NOCC,NVIR,L1,L2,L3,NSH2,MAXG,MXG2)
C
         ERR = ZERO
         IUNIQ=0
         DO 340 IXYZ=1,NNXYZ
            IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
            IF(NOCP(IXYZ).NE.0) GO TO 340
            AKDEN = DDOT(NROT,PDIR(1,IUNIQ),1,ZRES(1,IUNIQ),1)
C
C              THIS TERMINATION IS SUPPOSED TO BE DUE TO THE
C              MATRIX -A-'S NOT BEING POSITIVE DEFINITE.  A TEST
C              CALCULATION SHOWED THAT A CASE WITH UHF INSTABILITY
C              DID NOT GET INTO THIS ERROR TERMINATION SECTION,
C              SO AN INSTABILITY IN THE ORBITAL HESSIAN MAY BE A
C              NECESSARY BUT NOT SUFFICIENT CONDITION TO GET HERE.
C
            IF(AKDEN.LE.-TOL) THEN
               IF(MASWRK) WRITE(IW,9050)
               IF(MASWRK) WRITE(IW,9060)
               CALL ABRT
            END IF
            AK = BKNUM(IXYZ)/AKDEN
            CALL DAXPY(NROT, AK,PDIR(1,IUNIQ),1,   YA(1, IXYZ),1)
            CALL DAXPY(NROT,-AK,ZRES(1,IUNIQ),1,RESID(1,IUNIQ),1)
            DO IROT=1,NROT
               ZRES(IROT,IUNIQ) = PRECND(IROT)*RESID(IROT,IUNIQ)
            ENDDO
C
C              CHECK CONVERGENCE
C
            RNORM = SQRT(DDOT(NROT,RESID(1,IUNIQ),1,RESID(1,IUNIQ),1))
            TEST = RNORM/BNORM(IXYZ)
            IF(TEST.LT.TOL) NOCP(IXYZ)=2
            ERR = MAX(ERR,TEST)
  340    CONTINUE
         IF(MASWRK) THEN
            IF(DIRSCF) THEN
               WRITE(IW,9020) ITER,ERR,NXYZF,NINT,NSCHWZ
            ELSE
               WRITE(IW,9020) ITER,ERR,NXYZF
            END IF
            CALL FLSHBF(IW)
         END IF
         IF(ERR.LT.TOL) GO TO 800
  400 CONTINUE
C
C        CALCULATION DID NOT CONVERGE AFTER TOO MANY CYCLES.
C
      IF(MASWRK) WRITE(IW,9070) MAXIT
      IF(MASWRK) WRITE(IW,9060)
      CALL ABRT
      STOP
C
C        PRINT CONVERGENCE MESSAGE, RESTORE ORIGINAL -NOCP- ARRAY
C
  800 CONTINUE
      IF(MASWRK) WRITE(IW,9080) ITER,NFOCK,NUNIQ
      DO IXYZ=1,NNXYZ
         IF(NOCP(IXYZ).EQ.2) NOCP(IXYZ)=0
      ENDDO
      RETURN
C
 9000 FORMAT(1X,'PRECONDITIONED CONJUGATE GRADIENT SOLVER',5X,
     *          'CONV. TOLERANCE=',1P,E8.2)
 9010 FORMAT(1X,12X,'MAXIMUM',10X,'RESPONSES',8X,'NONZERO',5X,'BLOCKS'/
     *       1X,'ITER',4X,'RESPONSE ERROR',8X,'IMPROVED',3X,
     *          'AO INTEGRALS',4X,'SKIPPED')
 9020 FORMAT(1X,I3,5X,1P,E13.5,0P,8X,I6,3X,I15,I11)
 9030 FORMAT(1X,'ITER',4X,'RESPONSE ERROR',8X,'IMPROVED')
 9040 FORMAT(1X,'THE PRECONDITIONER IS NOT POSITIVE DEFINITE.'/
     *       1X,'THIS MAY BE DUE TO PECULIAR ORBITAL ENERGIES.')
 9050 FORMAT(//1X,'THE ORBITAL HESSIAN IS NOT POSITIVE DEFINITE.'//)
 9060 FORMAT(1X,'MOST OFTEN THIS IS',
     *          ' CAUSED BY USE OF AN INAPPROPRIATE WAVEFUNCTION.'/
     *       1X,'CHANGE SCFTYP, OR CHECK HOMO/LUMO FILLING ORDER.'//)
 9070 FORMAT(//1X,'*** TOO MANY ITERATIONS IN AOCPCG *** MAXIT=',I5/
     *       1X,'THIS VALUE CANNOT BE RAISED BY THE INPUT BECAUSE'/
     *       1X,'MORE CPHF ITERATIONS ARE UNLIKELY TO HELP.'//)
 9080 FORMAT(1X,'THE CPHF HAS CONVERGED AFTER',I3,' ITERATIONS.'/
     *       1X,'IT REQUIRED',I6,' FOCK-LIKE BUILDS TO FIND THE',I4,
     *          ' SYMMETRY UNIQUE RESPONSES.')
      END
C*MODULE CPHF    *DECK AOCPDI
      SUBROUTINE AOCPDI(WAX,VEC,YA,YNEW,DTEMP,FTEMP,EIG,WRK1,WRK2,
     *                  ERR,ADIIS,XDIIS,IPVT,BDIIS,IODIIS,
     *                  XX,IX,GHONDO,XINTS,DSH,DDIJ,NOCP,
     *                  NROT,NNXYZ,NUNIQ,NOCC,NVIR,L1,L2,L3,
     *                  MAXIT,MAXIT2,MAXIO,MAXG,NSH2,MXG2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL CVGD,NOTOPN,GOPARR,DSKWRK,MASWRK
C            DTEMP/FTEMP DOUBLE AS WORK STORAGE FOR CPDIIS, SEE BELOW.
      DIMENSION WAX(NROT,NNXYZ),VEC(L1,L1),YA(NROT,NNXYZ),
     *          YNEW(NROT,NNXYZ),DTEMP(NUNIQ*L2),FTEMP(NUNIQ*L2),
     *          ERR(NROT,NNXYZ),WRK1(L1,L1),WRK2(L3),XX(*),IX(*),
     *          EIG(L1),ADIIS(MAXDII,MAXDII),XDIIS(MAXIT),IPVT(MAXIT),
     *          BDIIS(MAXIT2,NNXYZ),IODIIS(MAXIO),NOCP(NNXYZ),
     *          GHONDO(MAXG),XINTS(NSH2),DSH(NSH2),DDIJ(16*MXG2)
C
      COMMON /DIISSO/ SOGTOL,ETHRSH,MAXDII,IRAF
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (FOUR=4.0D+00, ZERO=0.0D+00, TOL=1.0D-10)
C
C     ----- SOLVE RHF RESPONSE EQUATIONS USING AO BASIS INTEGRALS -----
C     ON ENTRY, -WAX- IS THE USUAL INHOMOGENEITY, UNCHANGED ON EXIT.
C     ON EXIT, -YA- ARE THE USUAL CPHF RESPONSES, IN THE MO BASIS.
C
C     START WITH A GUESS OF YA = -WAX/4(EI-EJ) DUE TO JAN JENSEN.
C     THIS GUESS AMOUNTS TO THE ASSUMPTION THAT -YA- IS ZERO DURING
C     AN INITIAL ITERATION, SO THE INTEGRAL TERM VANISHES FROM
C     THE RESPONSE EQUATIONS.
C
      IROT = 0
      DO 22 IVIR = NOCC+1,NOCC+NVIR
         DO 21 IOCC= 1,NOCC
            IROT = IROT + 1
            FACTOR = -1.0D+00/(FOUR*(EIG(IVIR) - EIG(IOCC)))
            DO 20 IXYZ = 1,NNXYZ
               YA(IROT,IXYZ) = FACTOR * WAX(IROT,IXYZ)
   20       CONTINUE
   21    CONTINUE
   22 CONTINUE
C
      ERDIIS = ZERO
      NOTOPN = .TRUE.
      NFOCK = 0
      ITDIIS = 1
      ITER = 0
C
C     BEGIN DIIS ITERATIONS...
C
   30 CONTINUE
      ITER = ITER + 1
C
C        FORM PRODUCTS A*YA, AND PRODUCE IMPROVED RESPONSES YNEW
C
      MODE = 0
      DUMMY =0.0D+00
      CALL AOCPCL(WAX,VEC,YA,YNEW,DUMMY,DTEMP,FTEMP,EIG,WRK1,WRK2,
     *            XX,IX,GHONDO,XINTS,DSH,DDIJ,NOCP,MODE,
     *            NNXYZ,NUNIQ,NXYZF,NFOCK,NINT,NSCHWZ,
     *            NROT,NOCC,NVIR,L1,L2,L3,NSH2,MAXG,MXG2)
C
C        RUN DIIS EXTRAPOLATION, SO MUST FIRST GET THE ERROR MATRIX
C
      DO 260 IXYZ = 1, NNXYZ
         IF (NOCP(IXYZ).NE.0) GO TO 260
         DO 250 IJ = 1,NROT
            ERR(IJ,IXYZ) = YNEW(IJ,IXYZ) - YA(IJ,IXYZ)
  250    CONTINUE
  260 CONTINUE
C
C  THIS IS SNEAKY: -DTEMP- AND -FTEMP- ARE CONSECUTIVE STORAGE,
C  AND ARE NO LONGER NEEDED BY THIS ITERATION.  THEREFORE THEY
C  ARE PASSED TO -CPDIIS- TO BE ITS NROT*NNXYZ WORKING VECTOR.
C  THIS MAY EXCEED 2*NUNIQ*L2, SO ALLOCATOR HAS TO TAKE -MAX-.
C
      CALL CPDIIS(IW,ITDIIS,YNEW,ERR,DTEMP,ADIIS,XDIIS,IPVT,
     *            BDIIS,IODIIS,NOCP,MAXIT,MAXIT2,MAXIO,
     *            ERDIIS,NOTOPN,NROT,NOCC,NVIR,NNXYZ)
      IF(MASWRK) THEN
         WRITE(IW,9020) ITER,NXYZF,ERDIIS
         CALL FLSHBF(IW)
      END IF
C
C  CHECK THE CONVERGENCE
C
      CVGD = .TRUE.
      DO 310 IXYZ=1,NNXYZ
         IF (NOCP(IXYZ).NE.0) GO TO 310
         DEL = 0
         DO 300 IJ = 1,NROT
            DEL = DEL + (YNEW(IJ,IXYZ) - YA(IJ,IXYZ))**2
            YA(IJ,IXYZ) = YNEW(IJ,IXYZ)
  300    CONTINUE
         DEL = SQRT(DEL/NROT)
         IF (DEL.GT.TOL) THEN
            CVGD=.FALSE.
         ELSE
            IF(NOCP(IXYZ).EQ.0) NOCP(IXYZ)=2
         END IF
  310 CONTINUE
C
C         NOTE THAT ITDIIS EXCEEDS MAXIT BY ONE IN -CPDIIS-
C
      IF(ITER.GE.MAXIT-1) THEN
         IF(MASWRK) WRITE(IW,9030) ITER
         CALL ABRT
         STOP
      END IF
      IF (.NOT.CVGD) GO TO 30
C
C     DIIS HAS CONVERGED...
C
      IF(MASWRK) WRITE(IW,9040) ITER,NFOCK,NUNIQ
      CALL RACLOS(IRAF,'DELETE')
      NOTOPN=.TRUE.
C
C  RESTORE THE NOCP VECTOR
C
      DO 800 I=1,NNXYZ
         IF(NOCP(I).EQ.2) NOCP(I)=0
  800 CONTINUE
      RETURN
C
 9020 FORMAT(1X,'CPHF ITER',I3,' IMPROVED',I4,
     *          ' RESPONSES, MAXIMUM RESPONSE ERROR=',1P,E13.5)
 9030 FORMAT(5X,'WARNING! THE CPHF IS NOT CONVERGED AFTER ',
     *         I3,' ITERATIONS.')
 9040 FORMAT(1X,'THE CPHF HAS CONVERGED AFTER',I3,' ITERATIONS.'/
     *       1X,'IT REQUIRED',I6,' FOCK-LIKE BUILDS TO FIND THE',I4,
     *          ' SYMMETRY UNIQUE RESPONSES.')
      END
C*MODULE CPHF    *DECK XDELTA
      SUBROUTINE XDELTA(XLAGR,DLAGR,ZKL,E,X,Y,PMN,XLMN,BUF,IBUF,
     *                  NOCC,NVIR,NORB,NUM,NUM2,NUM3,NOCACT,NFZC,NINTMX)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION XLAGR(NORB,NORB),DLAGR(NOCC,NVIR),ZKL(NOCACT,NFZC),
     *          E(NORB),X(NUM3),Y(NUM3),PMN(NUM2),XLMN(NUM2),
     *          BUF(NINTMX),IBUF(*)
C
C        --- FORM THE ASYMMETRY OF THE CI LAGRANGIAN ---
C
      DO 10 I=1,NVIR
         DO 20 J=1,NOCC
           DLAGR(J,I)=XLAGR(I+NOCC,J)-XLAGR(J,I+NOCC)
  20     CONTINUE
  10  CONTINUE
C
      IF(NFZC.EQ.0) RETURN
C
C     -- IF FROZEN CORE CALCULATE CORE-VALENCE DENSITY CORRECTION ZKL --
C
      DO 30 K=1,NOCACT
         DO 40 L=1,NFZC
            DLK=E(L)-E(K+NFZC)
            ZKL(K,L)=(XLAGR(K+NFZC,L)-XLAGR(L,K+NFZC))/DLK
  40     CONTINUE
  30  CONTINUE
C
C    --- FOR FROZEN CORE NEED EXTRA TERM IN LAGRANGIAN ---
C
      CALL CILAI(ZKL,PMN,X,Y,XLMN,BUF,IBUF,DLAGR,
     *           NOCACT,NFZC,NOCC,NVIR,NUM,NUM2,NUM3,XLAGR)
      RETURN
      END
C*MODULE CPHF    *DECK ZDENCI
      SUBROUTINE ZDENCI(PCORR,V,ZCV,X,Y,
     *                  NOC,NBF,NBF2,NBF3,NVIR,NFZC,NOCACT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, FOUR=4.0D+00, PT25=0.25D+00)
C
      DIMENSION PCORR(*),V(NBF,NBF),ZCV(NOCACT,NFZC),X(NBF3),Y(NBF3)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(400)
C
C     ---- THIS ROUTINE TRANSFORMS THE Z-VECTOR INTO THE AO BASIS ----
C     ---- AND ADDS 4*Z (AO) TO THE 1-PARTICLE DENSITY            ----
C
      CALL TRPOSE(PCORR,X,NOC,NVIR,1)
C
      CALL VCLR(X,1,NBF3)
      CALL VCLR(Y,1,NBF3)
C
C     ---- GET ORBITAL COEFFICIENTS ----
C
      CALL DAREAD(IDAF,IODA,V,NBF3,15,0)
C
C     ---- TRNSFORM Z-VECTOR TO AO BASIS ----
C
      CALL MRARTR(PCORR,NVIR,NVIR,NOC,V,NBF,NBF,X,NBF)
      CALL DGEMM('N','N',NBF,NBF,NVIR,ONE,V(1,NOC+1),
     *            NBF,X,NBF,ZERO,Y,NBF)
C
      IF(NFZC.GT.0) THEN
         DO 50 I=1,NOCACT
            DO 60 J=1,NFZC
               ZCV(I,J)=ZCV(I,J)*PT25
   60       CONTINUE
   50    CONTINUE
         CALL MRARTR(ZCV,NOCACT,NOCACT,NFZC,V,NBF,NBF,X,NBF)
         CALL DGEMM('N','N',NBF,NBF,NOCACT,ONE,V(1,NFZC+1),
     *              NBF,X,NBF,ONE,Y,NBF)
      END IF
C
      CALL DCOPY(NBF3,Y,1,V,1)
C
      MUNU = 0
      DO 110 MU=1,NBF
         DO 100 NU=1,MU
            MUNU=MUNU+1
            X(MUNU) = FOUR*(V(MU,NU) + V(NU,MU))
  100    CONTINUE
  110 CONTINUE
C
C     ---- ADD TO CI 1-PARTICLE DENSITY ----
C
      CALL DAREAD(IDAF,IODA,Y,NBF2,16,0)
      CALL VADD(X,1,Y,1,Y,1,NBF2)
C
C     ---- WRITE RELAXED DENSITY TO DAF ----
C
      CALL DAWRIT(IDAF,IODA,Y,NBF2,16,0)
      RETURN
      END
C*MODULE CPHF    *DECK ZGRDCI
      SUBROUTINE ZGRDCI(Z,B,BCV,ZCV,NVIR,NOCC,NXYZ,NAT,NFZC,NOCACT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=500,TWO=2.0D+00, PT5=0.5D+00)
C
      DIMENSION B(NOCC,NVIR,NXYZ), Z(NOCC,NVIR), BCV(NFZC,NOCACT,NXYZ)
      DIMENSION ZCV(NOCACT,NFZC)
C
      COMMON /GRAD  / DE(3,MXATM)
C
C        PLACE Z-VECTOR CONTRIBUTIONS INTO THE CI GRADIENT
C
      DO 10 NA=1,NAT
         NAI=3*(NA-1)
         DO 20 I=1,NVIR
            DO 30 J=1,NOCC
               DE(1,NA)=DE(1,NA) + TWO*B(J,I,NAI+1)*Z(J,I)
               DE(2,NA)=DE(2,NA) + TWO*B(J,I,NAI+2)*Z(J,I)
               DE(3,NA)=DE(3,NA) + TWO*B(J,I,NAI+3)*Z(J,I)
   30       CONTINUE
   20    CONTINUE
   10 CONTINUE
C
C     --- FOR FROZEN CORE NEED CORE-VALENCE CONTRIBUTIONS ---
C     --- THE EQUATIONS CALL FOR A FACTOR OF 2 BUT WE MUST DIVIDE ---
C     --- THIS BY 4 TO ACCOUNT FOR B WHICH IS 4 TIMES TOO BIG     ---
C
      IF (NFZC.GT.0) THEN
         DO 50 NA=1,NAT
            NAI=3*(NA-1)
            DO 60 I=1,NOCACT
               DO 70 J=1,NFZC
                  DE(1,NA)=DE(1,NA) + PT5*BCV(J,I,NAI+1)*ZCV(I,J)
                  DE(2,NA)=DE(2,NA) + PT5*BCV(J,I,NAI+2)*ZCV(I,J)
                  DE(3,NA)=DE(3,NA) + PT5*BCV(J,I,NAI+3)*ZCV(I,J)
   70          CONTINUE
   60       CONTINUE
   50    CONTINUE
      END IF
C
      RETURN
      END
C*MODULE CPHF    *DECK LINEQU
      SUBROUTINE LINEQU(A,LDA,B,N,IB,T,DETA,IERR,NODCMP)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION A(LDA,*),B(N),IB(N),T(N)
C
C     ----- SOLVE A * X = B , WITH X RETURNED IN B -----
C
      IF(NODCMP.NE.1) GO TO 20
C
      CALL LUDCMP(A,LDA,N,IB,T,DETA,IERR)
      DO 10 J=1,N
   10 DETA=DETA*A(J,J)
C
   20 CONTINUE
      CALL LUBKSB(A,LDA,N,IB,B)
C
      RETURN
      END
C*MODULE CPHF    *DECK LUBKSB
      SUBROUTINE LUBKSB(A,LDA,N,IB,B)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION A(LDA,*),IB(N),B(N)
C
      DATA ZERO /0.0D+00/
C
C     ----- NUMERICAL RECIPES (P.37), CAMBRIDGE UNIVERSITY PRESS -----
C          W.H.PRESS, B.P.FLANNERY, S.A.TEUKOLSKY, W.T.VETTERLING
C
      II=0
      DO 12 I=1,N
         LL=IB(I)
         SUM=B(LL)
         B(LL)=B(I)
         IF(II.NE.0) THEN
            DO 11 J=II,I-1
               SUM=SUM-A(I,J)*B(J)
   11       CONTINUE
         ELSE IF (SUM.NE.ZERO) THEN
            II=I
         END IF
         B(I)=SUM
   12 CONTINUE
      DO 14 I=N,1,-1
         SUM=B(I)
         IF(I.LT.N) THEN
            DO 13 J=I+1,N
               SUM=SUM-A(I,J)*B(J)
   13       CONTINUE
         END IF
         B(I)=SUM/A(I,I)
   14 CONTINUE
      RETURN
      END
C*MODULE CPHF    *DECK LUDCMP
      SUBROUTINE LUDCMP(A,LDA,N,IB,VV,D,IERR)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION A(LDA,*),IB(N),VV(N)
C
      DATA TINY     /1.0D-20/
      DATA ZERO,ONE /0.0D+00,1.0D+00/
C
C     ----- NUMERICAL RECIPES (P.35), CAMBRIDGE UNIVERSITY PRESS -----
C          W.H.PRESS, B.P.FLANNERY, S.A.TEUKOLSKY, W.T.VETTERLING
C
      IERR=0
      D=ONE
      IMAX=0
      DO 12 I=1,N
         AAMAX=ZERO
         DO 11 J=1,N
            IF( ABS(A(I,J)).GT.AAMAX) AAMAX= ABS(A(I,J))
   11    CONTINUE
         IF(AAMAX.EQ.ZERO) THEN
            IERR=1
            RETURN
         END IF
         VV(I)=ONE/AAMAX
   12 CONTINUE
      DO 19 J=1,N
         IF(J.GT.1) THEN
            DO 14 I=1,J-1
               SUM=A(I,J)
               IF(I.GT.1) THEN
                  DO 13 K=1,I-1
                     SUM=SUM-A(I,K)*A(K,J)
   13             CONTINUE
                  A(I,J)=SUM
               END IF
   14       CONTINUE
         END IF
         AAMAX=ZERO
         DO 16 I=J,N
            SUM=A(I,J)
            IF(J.GT.1) THEN
               DO 15 K=1,J-1
                  SUM=SUM-A(I,K)*A(K,J)
   15          CONTINUE
               A(I,J)=SUM
            END IF
            DUM=VV(I)* ABS(SUM)
            IF(DUM.GE.AAMAX) THEN
               IMAX=I
               AAMAX=DUM
            END IF
   16    CONTINUE
         IF(J.NE.IMAX) THEN
            DO 17 K=1,N
               DUM=A(IMAX,K)
               A(IMAX,K)=A(J,K)
               A(J,K)=DUM
   17       CONTINUE
            D=-D
            VV(IMAX)=VV(J)
         END IF
         IB(J)=IMAX
         IF(J.NE.N) THEN
            IF(A(J,J).EQ.ZERO) A(J,J)=TINY
            DUM=ONE/A(J,J)
            DO 18 I=J+1,N
               A(I,J)=A(I,J)*DUM
   18       CONTINUE
         END IF
   19 CONTINUE
      IF(A(N,N).EQ.ZERO) A(N,N)=TINY
      RETURN
      END
C*MODULE CPHF    *DECK SOLVCG
      SUBROUTINE SOLVCG(A,B,X,ADIAG,N,NITER,NPASS,INCORE,NWIDTH,NFT16,
     *                  WRK1,WRK2,XI,XJ,NOCP,BNORM,RESDU,NSOLV)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL CVGING,INCORE,GOPARR,DSKWRK,MASWRK
C
      DIMENSION A(N,NWIDTH),X(N,NSOLV),B(N,NSOLV),WRK1(N,NSOLV),
     *          WRK2(N,NSOLV),XI(N,NSOLV),XJ(N,NSOLV),NOCP(NSOLV),
     *          BNORM(NSOLV),RESDU(NSOLV),ADIAG(N)
C
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(400)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00, EPS=1.0D-05, ONE=1.0D+00)
C
C     ----- SOLVE A * X = B -----
C     USING AN ITERATIVE CONJUGATE GRADIENT ALGORITHM
C
C     SEE "NUMERICAL RECIPES (FORTRAN VERSION)", PAGE 70
C     W.H.PRESS, B.P.FLANNERY, S.A.TEUKOLSKY, W.T.VETTERLING
C     CAMBRIDGE UNIVERSITY PRESS, 1989.
C
C     THIS CODE HAS BEEN SPECIALIZED TO THE CPHF PROBLEM OCCURING IN
C     QUANTUM CHEMISTRY, I.E. THE COEFFICIENT MATRIX -A- IS ASSUMED
C     TO BE SYMMETRIC BY SPARAX AND SPARXA.
C
      EPS2=N*EPS*EPS
      IF(.NOT.INCORE) CALL SEQREW(NFT16)
C
C        EVALUATE MAGNITUDE OF RIGHT HAND SIDE
C
      CALL SPARAX(A,X,XI,ADIAG,NOCP,INCORE,NFT16,N,NWIDTH,NSOLV)
C
      DO 140 ISOLV=1,NSOLV
         IF(NOCP(ISOLV).GT.0) GO TO 140
         DO 130 J=1,N
            XI(J,ISOLV) = XI(J,ISOLV)-B(J,ISOLV)
  130    CONTINUE
         BNORM(ISOLV)= DDOT(N, B(1,ISOLV),1, B(1,ISOLV),1)
         RESDU(ISOLV)= DDOT(N,XI(1,ISOLV),1,XI(1,ISOLV),1)
  140 CONTINUE
C
C        EVALUATE THE STARTING GRADIENT
C
      CALL SPARXA(A,XI,WRK1,ADIAG,NOCP,INCORE,NFT16,N,NWIDTH,NSOLV)
C
      DO 180 ISOLV=1,NSOLV
         IF(NOCP(ISOLV).GT.0) GO TO 180
         DO 170 J=1,N
            WRK1(J,ISOLV) = -WRK1(J,ISOLV)
            WRK2(J,ISOLV) =  WRK1(J,ISOLV)
  170    CONTINUE
  180 CONTINUE
C
C        ----- BEGIN ITERATIONS HERE -----
C        IF OUT OF CORE, WE'VE ALREADY READ THE DISK FILE ONCE
C
      MAXCP = 50
      MAXCP2= 200
      ITER = 0
      NPASS = 1
      RSQMAX = ZERO
      RSQPRV = ZERO
  200 CONTINUE
      ITER  = ITER+1
      NPASS = NPASS+1
      CVGING = RSQMAX .LT. RSQPRV
      RSQPRV = RSQMAX
C
      CALL SPARAX(A,WRK2,XI,ADIAG,NOCP,INCORE,NFT16,N,NWIDTH,NSOLV)
C
      DO 340 ISOLV=1,NSOLV
         IF(NOCP(ISOLV).GT.0) GO TO 340
         NITER = NITER+1
         ANUM = DDOT(N,WRK1(1,ISOLV),1,WRK2(1,ISOLV),1)
         ADEN = DDOT(N,  XI(1,ISOLV),1,  XI(1,ISOLV),1)
         IF(ADEN.EQ.ZERO) THEN
            IF(ANUM.NE.ZERO) THEN
               IF(MASWRK) WRITE(IW,*) 'VERY SINGULAR MATRIX IN SOLVCG'
               CALL ABRT
               STOP
            ELSE
               ANUM=ONE
               ADEN=ONE
            END IF
         END IF
         ANUM=ANUM/ADEN
         CALL DCOPY(N,X(1,ISOLV),1,XI(1,ISOLV),1)
         CALL DAXPY(N,ANUM,WRK2(1,ISOLV),1,X(1,ISOLV),1)
  340 CONTINUE
C
      CALL SPARAX(A,X,XJ,ADIAG,NOCP,INCORE,NFT16,N,NWIDTH,NSOLV)
C
      NRSQ = 0
      RSQMAX = ZERO
      DO 440 ISOLV=1,NSOLV
         IF(NOCP(ISOLV).GT.0) GO TO 440
         DO 420 J=1,N
            XJ(J,ISOLV) = XJ(J,ISOLV) - B(J,ISOLV)
  420    CONTINUE
         RSQ = DDOT(N,XJ(1,ISOLV),1,XJ(1,ISOLV),1)
         NRSQ   = NRSQ+1
         RSQMAX = MAX(RSQ,RSQMAX)
C
C                          NORMAL CONVERGENCE FOR SOLUTION -ISOLV-
C
         IF(RSQ.EQ.RESDU(ISOLV) .OR. RSQ.LE.BNORM(ISOLV)*EPS2) THEN
            NOCP(ISOLV) = 2
         ELSE
            RESDU(ISOLV) = RSQ
         END IF
  440 CONTINUE
C
C            PRINT RESULT FOR THIS ITERATION
C
      IF(MASWRK) WRITE(IW,9020) ITER,NRSQ,RSQMAX
      CALL FLSHBF(IW)
C
C                  RETURN IF WE'VE FOUND ALL SOLUTIONS.
C
      DO 500 ISOLV=1,NSOLV
         IF(NOCP(ISOLV).EQ.0) GO TO 510
 500  CONTINUE
      RETURN
C
 510  CONTINUE
      CALL SPARXA(A,XJ,XI,ADIAG,NOCP,INCORE,NFT16,N,NWIDTH,NSOLV)
C
      DO 540 ISOLV=1,NSOLV
         IF(NOCP(ISOLV).GT.0) GO TO 540
C
C                                     RARE, BUT NORMAL SOLUTION
C
         GG = DDOT(N,WRK1(1,ISOLV),1,WRK1(1,ISOLV),1)
         IF(GG.EQ.ZERO) THEN
            NOCP(ISOLV)=2
            GO TO 540
         END IF
C
         DGG=ZERO
         DO 520 J=1,N
            DGG=DGG + (XI(J,ISOLV) + WRK1(J,ISOLV)) * XI(J,ISOLV)
  520    CONTINUE
         GAM=DGG/GG
         DO 530 J=1,N
            WRK1(J,ISOLV)= -XI(J,ISOLV)
            WRK2(J,ISOLV)=WRK1(J,ISOLV) + GAM*WRK2(J,ISOLV)
  530    CONTINUE
  540 CONTINUE
C
C                  RETURN IF WE'VE FOUND ALL SOLUTIONS.
C
      DO 580 ISOLV=1,NSOLV
         IF(NOCP(ISOLV).EQ.0) GO TO 590
  580 CONTINUE
      RETURN
C     ******
C
C          THE STRATEGY IS TO ALLOW AT MOST -MAXCP2- ITERATIONS,
C          BUT WE ALSO WILL STOP AFTER -MAXCP- ITERATIONS UNLESS
C          WE HAVE MADE SOME PROGRESS ON CURRENT OR PREVIOUS ITER.
C
  590 CONTINUE
      IF(ITER.GT.MAXCP2) GO TO 700
      IF(ITER.LE.MAXCP)  GO TO 200
      IF(CVGING  .OR.  RSQMAX.LT.2.0D+00*RSQPRV) GO TO 200
C
C       WE ARE NOT CONVERGING...
C
  700 CONTINUE
      IF (MASWRK) WRITE(IW,9000) MAXCP
      CALL ABRT
      STOP
 9000 FORMAT(1X,'*** TOO MANY ITERATIONS IN SOLVCG *** MAXCP=',I5//
     *       1X,'THIS VALUE CANNOT BE RAISED BY THE INPUT BECAUSE MORE',
     *          ' ITERATIONS WILL NOT HELP.'/
     *       1X,'THE FAILURE TO SOLVE IS DUE TO THE ILL CONDITIONED',
     *          ' ORBITAL HESSIAN,'/1X,'MOST OFTEN THIS IS',
     *          ' CAUSED BY USE OF AN INAPPROPRIATE WAVEFUNCTION.'/
     *       1X,'CHANGE SCFTYP, OR CHECK HOMO/LUMO FILLING ORDER.'/)
 9020 FORMAT(1X,'ITER',I4,' IMPROVED',I5,' RESPONSES, MAX RESIDUE=',
     *       1P,E15.7)
      END
C*MODULE CPHF    *DECK SOLVCP
      SUBROUTINE SOLVCP(WXY,WAX,YA,NROT,NXYZ,NOCP,WXYII,
     *                  WRK1,WRK2,WRK3,WRK4,BNORM,RESDU,
     *                  NITER,NPASS,NWIDTH,NSOLV,INCORE,
     *                  NFT16,MAXEQU)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL INCORE
C
      DIMENSION WXY(NROT,NWIDTH),WAX(NROT,NXYZ),YA(NROT,NXYZ),
     *          WXYII(NROT),NOCP(NXYZ),
     *          WRK1(NROT,NSOLV),WRK2(NROT,NSOLV),WRK3(NROT,NSOLV),
     *          WRK4(NROT,NSOLV),BNORM(NSOLV),RESDU(NSOLV)
C
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TOL=1.0D-10)
C
C     ----- SOLVE LINEAR EQUATIONS WXY * YA - WAX = 0 -----
C
C     THE EQUATIONS ARE OF DIMENSION -NROT-, AND THERE ARE -NXYZ-
C     INHOMOGENEITIES.  -NOCP- TELLS WHICH SOLUTIONS -YA- ARE NOT
C     NEEDED DUE TO SYMMETRY OF THE MOLECULE, 0/1=SOLVE/SKIP.
C
C     SMALL (.LE.-MAXEQU-) SYSTEMS OF EQUATIONS ARE SOLVED DIRECTLY
C     BY USING LU DECOMPOSITION, LARGER SYSTEMS BY AN ITERATIVE
C     CONJUGATE GRADIENT MINIMIZATION.  LARGER SYSTEMS MAY OR MAY
C     NOT HOLD ALL OF -WXY- IN MEMORY, DEPENDING ON -INCORE-.
C
C     THE INHOMOGENEITY -WAX-, SOLUTIONS -YA-, AND SEVERAL WORK
C     VECTORS ARE ASSUMED ALWAYS TO FIT IN MEMORY.  ON EXIT, A
C     MEMORY RESIDENT -WXY- IS DESTROYED, BUT -WAX- IS UNCHANGED.
C
C     WHEN -INCORE- IS TRUE, -NWIDTH- EQUALS -NROT-, AND THE MATRIX
C     MUST EXIST ALREADY IN -WXY-.   BOTH IN MEMORY ALGORITHMS ARE
C     GENERAL, WITH NO ASSUMPTION ABOUT THE SYMMETRY OF -WXY-.
C     THE SMALL SYSTEM METHOD SEEKS SOLUTIONS ONE AT A TIME, SO THAT
C     THE VALUE FOR -NSOLV- SHOULD BE 1.  FOR THE LARGER METHODS,
C     -NSOLV- SHOULD EQUAL -NXYZ- TO DEVELOP ALL SOLUTIONS AT ONCE,
C     WHICH MINIMIZES DISK I/O ON THE EXTERNAL -WXY- MATRIX, OR
C     MEMORY ACCESSES ON -WXY- IF IT SITS IN MEMORY.
C
C     WHEN -INCORE- IS FALSE, THE -WXY- MATRIX IS STORED ON DISK
C     FILE -NFT16-, IN STRIPS WHICH ARE -NWIDTH- COLUMNS WIDE.
C     THE INITIAL MATRIX -WXY- MUST BE SYMMETRIC, WHICH FACT WHICH
C     IS EXPLOITED IN THE OUT OF MEMORY SOLVER.  ON ENTRY, -WXYII-
C     MUST CONTAIN THE DIAGONAL OF THE EXTERNALLY STORED -WXY-.
C
C     ORIGINAL VERSION OF THIS ROUTINE IS DUE TO MICHEL DUPUIS.
C     OUT OF MEMORY STORAGE OF -WXY- CODED BY MWS, OCTOBER 1990,
C     AND MODIFIED IN JANUARY 1992 AND AGAIN IN JANUARY 1996.
C
C     ----- PRE-CONDITION DIAGONAL OF THE EQUATIONS TO ONE -----
C
      IF(INCORE) THEN
         DO 110 IROT=1,NROT
            WXYII(IROT) = ONE/WXY(IROT,IROT)
  110    CONTINUE
      ELSE
         DO 120 IROT=1,NROT
            WXYII(IROT) = ONE/WXYII(IROT)
  120    CONTINUE
      END IF
C
C     CONDITIONING FOR LINPACK IN MEMORY SOLVER
C     CONDITIONING OF -WXY- IS DONE INSIDE THE CONJUGATE GRADIENT SOLVER
C
      IF(NROT.LE.MAXEQU) THEN
         DO 230 JROT=1,NROT
            DO 220 IROT=1,NROT
               WXY(IROT,JROT)=WXY(IROT,JROT)*WXYII(IROT)
  220       CONTINUE
  230    CONTINUE
      END IF
C
C     AND OF COURSE CONDITION THE INHOMOGENEITY AS WELL
C
      DO 320 IXYZ=1,NXYZ
         DO 310 IROT=1,NROT
            WAX(IROT,IXYZ)=WAX(IROT,IXYZ)*WXYII(IROT)
  310    CONTINUE
  320 CONTINUE
C
C     ----- GENERATE INITIAL GUESS AT THE SOLUTIONS -----
C     WE ALSO CHANGE THE SIGN OF THE INHOMOGENEITY HERE.
C     IF INHOMOGENEITY IS SMALL, WE CAN SKIP THAT SOLUTION.
C
      DO 420 IXYZ=1,NXYZ
         IF(NOCP(IXYZ).EQ.0) THEN
            WAXMAX=ZERO
            DO 410 IROT=1,NROT
               WAXI = -WAX(IROT,IXYZ)
               IF(ABS(WAXI).GT.WAXMAX) WAXMAX=ABS(WAXI)
               WAX(IROT,IXYZ) = WAXI
                YA(IROT,IXYZ) = WAXI
  410       CONTINUE
            IF(WAXMAX.LT.TOL) NOCP(IXYZ)=2
         END IF
         IF(NOCP(IXYZ).GT.0) CALL VCLR(YA(1,IXYZ),1,NROT)
  420 CONTINUE
C
C     ----- THE LINPACK SOLVER LOOPS OVER SOLVING EACH EQUATION -----
C     ----- FOR CONJUGATE GRADIENT, SEEK SOLUTIONS SIMULTANEOUSLY -----
C
      IF(NROT.LE.MAXEQU) THEN
         NODCMP=1
         DO 500 IXYZ=1,NXYZ
            IF(NOCP(IXYZ).GT.0) GO TO 500
            CALL LINEQU(WXY,NROT,YA(1,IXYZ),NROT,
     *                  WRK1,WRK2,DETWXY,IERR,NODCMP)
            NODCMP=0
  500    CONTINUE
      ELSE
         CALL SOLVCG(WXY,WAX,YA,WXYII,NROT,NITER,NPASS,INCORE,NWIDTH,
     *               NFT16,WRK1,WRK2,WRK3,WRK4,NOCP,BNORM,RESDU,NSOLV)
      END IF
C
C     FINALLY, RESTORE ORIGINAL -NOCP- AND -WAX- MATRIX
C
      DO 600 IXYZ=1,NXYZ
         IF(NOCP(IXYZ).EQ.2) NOCP(IXYZ)=0
  600 CONTINUE
C
      DO 610 IROT=1,NROT
         WXYII(IROT)=ONE/WXYII(IROT)
  610 CONTINUE
C
      DO 640 IXYZ=1,NXYZ
         IF(NOCP(IXYZ).EQ.0) THEN
            DO 620 IROT=1,NROT
               WAX(IROT,IXYZ) = -WAX(IROT,IXYZ) * WXYII(IROT)
  620       CONTINUE
         ELSE
            DO 630 IROT=1,NROT
               WAX(IROT,IXYZ) =  WAX(IROT,IXYZ) * WXYII(IROT)
  630       CONTINUE
         END IF
  640 CONTINUE
      RETURN
      END
C*MODULE CPHF    *DECK SPARAX
      SUBROUTINE SPARAX(A,X,AX,ADIAG,NOCP,INCORE,NFT16,N,NWIDTH,NSOLV)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL INCORE
C
      DIMENSION A(N,NWIDTH),X(N,NSOLV),AX(N,NSOLV),ADIAG(N),NOCP(NSOLV)
C
C     ----- THIS ROUTINE COMPUTES AX = A * X -----
C     A IS SYMMETRIC, SO ITS COLUMNS ARE ITS ROWS, NEEDED FOR
C     THE MULTIPLY, BUT COLUMNS HAVE THE ADVANTAGE OF UNIT STRIDE.
C     TO EXPLOIT THIS, WE MUST ACCOUNT FOR A'S CONDITIONING AFTER
C     FORMING A*X, SINCE A PRECONDITIONED -A- IS NOT SYMMETRIC.
C
      IF(INCORE) THEN
         DO 150 I=1,N
            DO 140 ISOLV=1,NSOLV
               IF(NOCP(ISOLV).GT.0) GO TO 140
               AX(I,ISOLV) = DDOT(N,A(1,I),1,X(1,ISOLV),1)
  140       CONTINUE
  150    CONTINUE
      ELSE
         KOL2 = 0
  310    CONTINUE
            KOL0=KOL2
            KOL1=KOL2+1
            KOL2=KOL2+NWIDTH
            IF(KOL2.GT.N) KOL2=N
            NCOL = KOL2-KOL1+1
C
            LEN = N*NCOL
            CALL SQREAD(NFT16,A,LEN)
C
            DO 350 I=1,NCOL
               DO 340 ISOLV=1,NSOLV
                  IF(NOCP(ISOLV).GT.0) GO TO 340
                  AX(I+KOL0,ISOLV) = DDOT(N,A(1,I),1,X(1,ISOLV),1)
  340          CONTINUE
  350       CONTINUE
         IF(KOL2.LT.N) GO TO 310
         CALL SEQREW(NFT16)
      END IF
C
C        APPLY CONDITIONING FACTOR OF -A- MATRIX TO A*X PRODUCT.
C
      DO 420 ISOLV=1,NSOLV
         IF(NOCP(ISOLV).GT.0) GO TO 420
         DO 410 I=1,N
            AX(I,ISOLV) = ADIAG(I) * AX(I,ISOLV)
  410    CONTINUE
  420 CONTINUE
C
      RETURN
      END
C*MODULE CPHF    *DECK SPARXA
      SUBROUTINE SPARXA(A,X,XA,ADIAG,NOCP,INCORE,NFT16,N,NWIDTH,NSOLV)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL INCORE
C
      DIMENSION A(N,NWIDTH),X(N,NSOLV),XA(N,NSOLV),NOCP(NSOLV),ADIAG(N)
C
C     ----- THIS ROUTINE COMPUTES XA = X-TRANSPOSE * A -----
C
C     APPLY CONDITIONING FACTOR OF -A- MATRIX TO X-TRANSPOSE.
C
      DO 120 ISOLV=1,NSOLV
         IF(NOCP(ISOLV).GT.0) GO TO 120
         DO 110 I=1,N
            X(I,ISOLV) = ADIAG(I) * X(I,ISOLV)
  110    CONTINUE
  120 CONTINUE
C
      IF(INCORE) THEN
         DO 250 I=1,N
            DO 240 ISOLV=1,NSOLV
               IF(NOCP(ISOLV).GT.0) GO TO 240
               XA(I,ISOLV) = DDOT(N,X(1,ISOLV),1,A(1,I),1)
  240       CONTINUE
  250    CONTINUE
      ELSE
         KOL2 = 0
  310    CONTINUE
            KOL0=KOL2
            KOL1=KOL2+1
            KOL2=KOL2+NWIDTH
            IF(KOL2.GT.N) KOL2=N
            NCOL = KOL2-KOL1+1
C
            LEN = N*NCOL
            CALL SQREAD(NFT16,A,LEN)
C
            DO 350 I=1,NCOL
               DO 340 ISOLV=1,NSOLV
                  IF(NOCP(ISOLV).GT.0) GO TO 340
                  XA(I+KOL0,ISOLV) = DDOT(N,X(1,ISOLV),1,A(1,I),1)
  340          CONTINUE
  350       CONTINUE
         IF(KOL2.LT.N) GO TO 310
         CALL SEQREW(NFT16)
      END IF
C
      RETURN
      END
C*MODULE CPHF    *DECK GSUMCP
      SUBROUTINE GSUMCP(MSGID,A,LENA)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MAXMES=5*1024*1024)
      DIMENSION A(LENA)
C
C        DIVIDE LARGE GLOBAL SUM INTO BIGGEST MESSAGE TCGMSG SUPPORTS.
C        ITS BIG_MESSAGE PARAMETER IS 40 MBYTES, I.E. 5 MWORDS.
C
      IF(LENA.LE.MAXMES) THEN
         CALL DDI_GSUMF(MSGID,A,LENA)
      ELSE
         LOC = 1
         LEN = MAXMES
         NCHUNK = LENA/MAXMES + 1
         DO 100 I=1,NCHUNK
            IF(I.EQ.NCHUNK) LEN=LENA - MAXMES*(NCHUNK-1)
            CALL DDI_GSUMF(MSGID,A(LOC),LEN)
            LOC = LOC+MAXMES
  100    CONTINUE
      END IF
      RETURN
      END
